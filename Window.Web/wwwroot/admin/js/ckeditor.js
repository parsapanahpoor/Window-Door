/*!
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function (t) {
    t["fa"] = Object.assign(t["fa"] || {}, {
        a: "نوارابزار جدول",
        b: "تعداد لغات : 0%",
        c: "تعداد حروف : 0%",
        d: " بلوک نقل قول",
        e: "انتخاب عنوان",
        f: "عنوان",
        g: "پیوند",
        h: "درج جدول",
        i: "ستون سربرگ",
        j: "درج ستون در سمت چپ",
        k: "درج ستون در سمت راست",
        l: "حذف ستون",
        m: "ستون",
        n: "سطر سربرگ",
        o: "درج سطر در پایین",
        p: "درج سطر در بالا",
        q: "حذف سطر",
        r: "سطر",
        s: "ادغام سلول بالا",
        t: "ادغام سلول راست",
        u: "ادغام سلول پایین",
        v: "ادغام سلول چپ",
        w: "تقسیم عمودی سلول",
        x: "تقسیم افقی سلول",
        y: "ادغام سلول ها",
        z: "Insert code block",
        aa: "تراز چپ",
        ab: "تراز راست",
        ac: "تراز وسط",
        ad: "هم تراز کردن",
        ae: "تراز متن",
        af: "نوارابزار تراز متن",
        ag: "افزایش تورفتگی",
        ah: "کاهش تورفتگی",
        ai: "درشت",
        aj: "کج",
        ak: "ابزاره تصویر",
        al: "قرار دادن تصویر",
        am: "آپلود ناموفق بود",
        an: "آپلود در حال انجام",
        ao: "اندازه فونت",
        ap: "پیش فرض",
        aq: "بسیار کوچک",
        ar: "کوچک",
        as: "بزرگ",
        at: "بسیار بزرگ",
        au: "رنگ فونت",
        av: "نوار ابزارک ها",
        aw: "پاراگراف",
        ax: "عنوان 1",
        ay: "عنوان 2",
        az: "عنوان 3",
        ba: "عنوان 4",
        bb: "عنوان 5",
        bc: "عنوان 6",
        bd: "تغییر متن جایگزین تصویر",
        be: "بازکردن در برگه جدید",
        bf: "قابل بارگیری",
        bg: "نوارابزار ویرایشگر",
        bh: "Show more items",
        bi: "نوارابزار کشویی",
        /*bj: "ویرایشگر متن غنی",
        bk: "ویرایشگر متن غنی، %0",*/
        bj: "",
        bk: "",
        bl: "حذف رنگ",
        bm: "رنگ اسناد",
        bn: "بازگردانی",
        bo: "باز انجام",
        bp: "Plain text",
        bq: "0% از 1%",
        br: "قبلی",
        bs: "بعدی",
        bt: "ذخیره",
        bu: "لغو",
        bv: "متن جایگزین",
        bw: "سیاه",
        bx: "خاکستری تیره",
        by: "خاکستری",
        bz: "خاکستری روشن",
        ca: "سفید",
        cb: "قرمز",
        cc: "نارنجی",
        cd: "زرد",
        ce: "سبز روشن",
        cf: "سبز",
        cg: "زمرد کبود",
        ch: "فیروزه ای",
        ci: "آبی روشن",
        cj: "آبی",
        ck: "بنفش",
        cl: "لغو پیوند",
        cm: "ویرایش پیوند",
        cn: "باز کردن پیوند در برگه جدید",
        co: "این پیوند نشانی اینترنتی ندارد",
        cp: "نشانی اینترنتی پیوند"
    })
}
)(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
(function t(e, n) {
    if (typeof exports === "object" && typeof module === "object")
        module.exports = n();
    else if (typeof define === "function" && define.amd)
        define([], n);
    else if (typeof exports === "object")
        exports["ClassicEditor"] = n();
    else
        e["ClassicEditor"] = n()
}
)(window, (function () {
    return function (t) {
        var e = {};
        function n(i) {
            if (e[i]) {
                return e[i].exports
            }
            var o = e[i] = {
                i: i,
                l: false,
                exports: {}
            };
            t[i].call(o.exports, o, o.exports, n);
            o.l = true;
            return o.exports
        }
        n.m = t;
        n.c = e;
        n.d = function (t, e, i) {
            if (!n.o(t, e)) {
                Object.defineProperty(t, e, {
                    enumerable: true,
                    get: i
                })
            }
        }
            ;
        n.r = function (t) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                })
            }
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        }
            ;
        n.t = function (t, e) {
            if (e & 1)
                t = n(t);
            if (e & 8)
                return t;
            if (e & 4 && typeof t === "object" && t && t.__esModule)
                return t;
            var i = Object.create(null);
            n.r(i);
            Object.defineProperty(i, "default", {
                enumerable: true,
                value: t
            });
            if (e & 2 && typeof t != "string")
                for (var o in t)
                    n.d(i, o, function (e) {
                        return t[e]
                    }
                        .bind(null, o));
            return i
        }
            ;
        n.n = function (t) {
            var e = t && t.__esModule ? function e() {
                return t["default"]
            }
                : function e() {
                    return t
                }
                ;
            n.d(e, "a", e);
            return e
        }
            ;
        n.o = function (t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }
            ;
        n.p = "";
        return n(n.s = 94)
    }([function (t, e, n) {
        "use strict";
        n.d(e, "b", (function () {
            return o
        }
        ));
        n.d(e, "a", (function () {
            return s
        }
        ));
        const i = "https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html";
        class o extends Error {
            constructor(t, e, n) {
                t = s(t);
                if (n) {
                    t += " " + JSON.stringify(n)
                }
                super(t);
                this.name = "CKEditorError";
                this.context = e;
                this.data = n
            }
            is(t) {
                return t === "CKEditorError"
            }
            static rethrowUnexpectedError(t, e) {
                if (t.is && t.is("CKEditorError")) {
                    throw t
                }
                const n = new o(t.message, e);
                n.stack = t.stack;
                throw n
            }
        }
        function s(t) {
            const e = t.match(/^([^:]+):/);
            if (!e) {
                return t
            }
            return t + ` Read more: ${i}#error-${e[1]}\n`
        }
    }
        , function (t, e, n) {
            "use strict";
            var i = function t() {
                var e;
                return function t() {
                    if (typeof e === "undefined") {
                        e = Boolean(window && document && document.all && !window.atob)
                    }
                    return e
                }
            }();
            var o = function t() {
                var e = {};
                return function t(n) {
                    if (typeof e[n] === "undefined") {
                        var i = document.querySelector(n);
                        if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) {
                            try {
                                i = i.contentDocument.head
                            } catch (t) {
                                i = null
                            }
                        }
                        e[n] = i
                    }
                    return e[n]
                }
            }();
            var s = [];
            function r(t) {
                var e = -1;
                for (var n = 0; n < s.length; n++) {
                    if (s[n].identifier === t) {
                        e = n;
                        break
                    }
                }
                return e
            }
            function a(t, e) {
                var n = {};
                var i = [];
                for (var o = 0; o < t.length; o++) {
                    var a = t[o];
                    var c = e.base ? a[0] + e.base : a[0];
                    var l = n[c] || 0;
                    var d = "".concat(c, " ").concat(l);
                    n[c] = l + 1;
                    var u = r(d);
                    var h = {
                        css: a[1],
                        media: a[2],
                        sourceMap: a[3]
                    };
                    if (u !== -1) {
                        s[u].references++;
                        s[u].updater(h)
                    } else {
                        s.push({
                            identifier: d,
                            updater: g(h, e),
                            references: 1
                        })
                    }
                    i.push(d)
                }
                return i
            }
            function c(t) {
                var e = document.createElement("style");
                var i = t.attributes || {};
                if (typeof i.nonce === "undefined") {
                    var s = true ? n.nc : undefined;
                    if (s) {
                        i.nonce = s
                    }
                }
                Object.keys(i).forEach((function (t) {
                    e.setAttribute(t, i[t])
                }
                ));
                if (typeof t.insert === "function") {
                    t.insert(e)
                } else {
                    var r = o(t.insert || "head");
                    if (!r) {
                        throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.")
                    }
                    r.appendChild(e)
                }
                return e
            }
            function l(t) {
                if (t.parentNode === null) {
                    return false
                }
                t.parentNode.removeChild(t)
            }
            var d = function t() {
                var e = [];
                return function t(n, i) {
                    e[n] = i;
                    return e.filter(Boolean).join("\n")
                }
            }();
            function u(t, e, n, i) {
                var o = n ? "" : i.media ? "@media ".concat(i.media, " {").concat(i.css, "}") : i.css;
                if (t.styleSheet) {
                    t.styleSheet.cssText = d(e, o)
                } else {
                    var s = document.createTextNode(o);
                    var r = t.childNodes;
                    if (r[e]) {
                        t.removeChild(r[e])
                    }
                    if (r.length) {
                        t.insertBefore(s, r[e])
                    } else {
                        t.appendChild(s)
                    }
                }
            }
            function h(t, e, n) {
                var i = n.css;
                var o = n.media;
                var s = n.sourceMap;
                if (o) {
                    t.setAttribute("media", o)
                } else {
                    t.removeAttribute("media")
                }
                if (s && btoa) {
                    i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " */")
                }
                if (t.styleSheet) {
                    t.styleSheet.cssText = i
                } else {
                    while (t.firstChild) {
                        t.removeChild(t.firstChild)
                    }
                    t.appendChild(document.createTextNode(i))
                }
            }
            var f = null;
            var p = 0;
            function g(t, e) {
                var n;
                var i;
                var o;
                if (e.singleton) {
                    var s = p++;
                    n = f || (f = c(e));
                    i = u.bind(null, n, s, false);
                    o = u.bind(null, n, s, true)
                } else {
                    n = c(e);
                    i = h.bind(null, n, e);
                    o = function t() {
                        l(n)
                    }
                }
                i(t);
                return function e(n) {
                    if (n) {
                        if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) {
                            return
                        }
                        i(t = n)
                    } else {
                        o()
                    }
                }
            }
            t.exports = function (t, e) {
                e = e || {};
                if (!e.singleton && typeof e.singleton !== "boolean") {
                    e.singleton = i()
                }
                t = t || [];
                var n = a(t, e);
                return function t(i) {
                    i = i || [];
                    if (Object.prototype.toString.call(i) !== "[object Array]") {
                        return
                    }
                    for (var o = 0; o < n.length; o++) {
                        var c = n[o];
                        var l = r(c);
                        s[l].references--
                    }
                    var d = a(i, e);
                    for (var u = 0; u < n.length; u++) {
                        var h = n[u];
                        var f = r(h);
                        if (s[f].references === 0) {
                            s[f].updater();
                            s.splice(f, 1)
                        }
                    }
                    n = d
                }
            }
        }
        , , function (t, e, n) {
            "use strict";
            var i = n(7);
            var o = typeof self == "object" && self && self.Object === Object && self;
            var s = i["a"] || o || Function("return this")();
            e["a"] = s
        }
        , function (t, e, n) {
            "use strict";
            (function (t) {
                var i = n(3);
                var o = n(12);
                var s = typeof exports == "object" && exports && !exports.nodeType && exports;
                var r = s && typeof t == "object" && t && !t.nodeType && t;
                var a = r && r.exports === s;
                var c = a ? i["a"].Buffer : undefined;
                var l = c ? c.isBuffer : undefined;
                var d = l || o["a"];
                e["a"] = d
            }
            ).call(this, n(9)(t))
        }
        , function (t, e, n) {
            "use strict";
            (function (t) {
                var i = n(7);
                var o = typeof exports == "object" && exports && !exports.nodeType && exports;
                var s = o && typeof t == "object" && t && !t.nodeType && t;
                var r = s && s.exports === o;
                var a = r && i["a"].process;
                var c = function () {
                    try {
                        var t = s && s.require && s.require("util").types;
                        if (t) {
                            return t
                        }
                        return a && a.binding && a.binding("util")
                    } catch (t) { }
                }();
                e["a"] = c
            }
            ).call(this, n(9)(t))
        }
        , function (t, e, n) {
            "use strict";
            (function (t) {
                var e = n(0);
                const i = "17.0.0";
                const o = typeof window === "object" ? window : t;
                if (o.CKEDITOR_VERSION) {
                    throw new e["b"]("ckeditor-duplicated-modules: Some CKEditor 5 modules are duplicated.", null)
                } else {
                    o.CKEDITOR_VERSION = i
                }
            }
            ).call(this, n(10))
        }
        , function (t, e, n) {
            "use strict";
            (function (t) {
                var n = typeof t == "object" && t && t.Object === Object && t;
                e["a"] = n
            }
            ).call(this, n(10))
        }
        , function (t, e, n) {
            "use strict";
            (function (t) {
                var i = n(3);
                var o = typeof exports == "object" && exports && !exports.nodeType && exports;
                var s = o && typeof t == "object" && t && !t.nodeType && t;
                var r = s && s.exports === o;
                var a = r ? i["a"].Buffer : undefined
                    , c = a ? a.allocUnsafe : undefined;
                function l(t, e) {
                    if (e) {
                        return t.slice()
                    }
                    var n = t.length
                        , i = c ? c(n) : new t.constructor(n);
                    t.copy(i);
                    return i
                }
                e["a"] = l
            }
            ).call(this, n(9)(t))
        }
        , function (t, e) {
            t.exports = function (t) {
                if (!t.webpackPolyfill) {
                    var e = Object.create(t);
                    if (!e.children)
                        e.children = [];
                    Object.defineProperty(e, "loaded", {
                        enumerable: true,
                        get: function () {
                            return e.l
                        }
                    });
                    Object.defineProperty(e, "id", {
                        enumerable: true,
                        get: function () {
                            return e.i
                        }
                    });
                    Object.defineProperty(e, "exports", {
                        enumerable: true
                    });
                    e.webpackPolyfill = 1
                }
                return e
            }
        }
        , function (t, e) {
            var n;
            n = function () {
                return this
            }();
            try {
                n = n || new Function("return this")()
            } catch (t) {
                if (typeof window === "object")
                    n = window
            }
            t.exports = n
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(45);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e, n) {
            "use strict";
            function i() {
                return false
            }
            e["a"] = i
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(14);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-placeholder:before,.ck .ck-placeholder:before{content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(16);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999);--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border:#1f89e5;--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#5c5c5c;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(18);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(20);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(22);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(24);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}:root{--ck-dropdown-arrow-size:calc(0.5*var(--ck-icon-size))}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(26);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(28);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_n{top:calc(-1*var(--ck-tooltip-arrow-size));transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(-1*var(--ck-tooltip-arrow-size));transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}'
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(30);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(-1*var(--ck-spacing-small));margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(-1*var(--ck-spacing-small));margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(32);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(0.2*var(--ck-line-height-base)*var(--ck-font-size-base)) calc(0.4*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(1.2*var(--ck-line-height-base)*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(34);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:1.3846153847em}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(2*var(--ck-spacing-large))}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(2*var(--ck-spacing-large))}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(0.5*var(--ck-border-radius))}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(-1*var(--ck-switch-button-translation)))}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(36);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-toolbar-dropdown .ck.ck-toolbar .ck.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar-dropdown .ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(38);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(40);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar>.ck-toolbar__items>*{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact .ck-toolbar__items>.ck{margin:0}.ck.ck-toolbar.ck-toolbar_compact .ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact .ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact .ck-toolbar__items>.ck:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck-toolbar__items>*,.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;margin-top:0;margin-bottom:0;background:var(--ck-color-toolbar-border)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__grouped-dropdown,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{padding-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__items>*,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__items>*{margin-left:var(--ck-spacing-small);margin-right:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__items>:last-child,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__items>:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__grouped-dropdown,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{padding-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__items>:last-child,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__items>:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{margin-right:var(--ck-spacing-small)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(42);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(44);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}"
        }
        , function (t, e) {
            t.exports = ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(47);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-resizer-size:10px;--ck-resizer-border-width:1px;--ck-resizer-border-radius:2px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-tooltip-offset:10px;--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2}.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness))}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle:hover,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck-editor__editable.ck-read-only .ck-widget{--ck-widget-outline-thickness:0}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(49);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-labeled-input .ck-labeled-input__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-input .ck-labeled-input__status_error{color:var(--ck-color-base-error)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(51);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ":root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{box-shadow:var(--ck-inner-shadow),0 0;background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .2s ease-in-out,border .2s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),var(--ck-inner-shadow)}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(53);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-input{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-input{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}.ck.ck-text-alternative-form{padding:var(--ck-spacing-standard)}.ck.ck-text-alternative-form:focus{outline:none}[dir=ltr] .ck.ck-text-alternative-form>:not(:first-child),[dir=rtl] .ck.ck-text-alternative-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-text-alternative-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-text-alternative-form .ck-labeled-input{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-text-alternative-form .ck-labeled-input .ck-input-text{min-width:0;width:100%}.ck.ck-text-alternative-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-text-alternative-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-text-alternative-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-text-alternative-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(55);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(2*var(--ck-balloon-arrow-half-width));top:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(-1*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(2*var(--ck-balloon-arrow-half-width));bottom:calc(-1*var(--ck-balloon-arrow-height))}'
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(57);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(59);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(61);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image>img{display:block;margin:0 auto;max-width:100%;min-width:50px}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(63);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(65);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}'
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(67);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}'
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(69);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(71);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-input{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form{padding:var(--ck-spacing-standard)}.ck.ck-link-form:focus{outline:none}[dir=ltr] .ck.ck-link-form>:not(:first-child),[dir=rtl] .ck.ck-link-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-form{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-form .ck-labeled-input{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-form .ck-labeled-input .ck-input-text{min-width:0;width:100%}.ck.ck-link-form .ck-button{padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-input{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-input .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button:first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin-left:0}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(73);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions{padding:var(--ck-spacing-standard)}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}.ck.ck-link-actions:focus{outline:none}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions{padding:0;width:calc(0.8*var(--ck-input-text-width))}.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):first-of-type{border-right:1px solid var(--ck-color-base-border)}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview):last-of-type{border-right:1px solid var(--ck-color-base-border)}}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(75);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ":root{--ck-color-table-focused-cell-background:#f5fafe}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(77);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(79);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck-content .table{margin:1em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border-color:#d9d9d9}.ck-content .table table th{font-weight:700;background:#fafafa}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(81);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0;outline:1px solid var(--ck-color-resizer)}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all;width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nesw-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nesw-resize}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(83);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck-content .image.image_resized{max-width:100%;display:block;box-sizing:border-box}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(85);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-radius:0}.ck-rounded-corners [dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow,[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-left-color:var(--ck-color-split-button-hover-border)}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-right-color:var(--ck-color-split-button-hover-border)}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(87);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck-content pre{padding:1em;color:#353535;background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;text-align:left;direction:ltr;tab-size:4;white-space:pre-wrap;font-style:normal;min-width:200px}.ck-content pre code{background:unset;padding:0;border-radius:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{top:-1px;right:10px;background:var(--ck-color-code-block-label-background);font-size:10px;font-family:var(--ck-font-face);line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);color:#fff;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-y:auto;overflow-x:hidden}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(89);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(91);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".ck .ck-button.ck-color-table__remove-color{display:flex;align-items:center;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}"
        }
        , function (t, e, n) {
            var i = n(1);
            var o = n(93);
            o = o.__esModule ? o.default : o;
            if (typeof o === "string") {
                o = [[t.i, o, ""]]
            }
            var s = {
                injectType: "singletonStyleTag"
            };
            s.insert = "head";
            s.singleton = true;
            var r = i(o, s);
            var a = o.locals ? o.locals : {};
            t.exports = a
        }
        , function (t, e) {
            t.exports = ".text-tiny{font-size:.7em}.text-small{font-size:.85em}.text-big{font-size:1.4em}.text-huge{font-size:1.8em}"
        }
        , function (t, e, n) {
            "use strict";
            n.r(e);
            var i = n(3);
            var o = i["a"].Symbol;
            var s = o;
            var r = Object.prototype;
            var a = r.hasOwnProperty;
            var c = r.toString;
            var l = s ? s.toStringTag : undefined;
            function d(t) {
                var e = a.call(t, l)
                    , n = t[l];
                try {
                    t[l] = undefined;
                    var i = true
                } catch (t) { }
                var o = c.call(t);
                if (i) {
                    if (e) {
                        t[l] = n
                    } else {
                        delete t[l]
                    }
                }
                return o
            }
            var u = d;
            var h = Object.prototype;
            var f = h.toString;
            function p(t) {
                return f.call(t)
            }
            var g = p;
            var m = "[object Null]"
                , b = "[object Undefined]";
            var w = s ? s.toStringTag : undefined;
            function k(t) {
                if (t == null) {
                    return t === undefined ? b : m
                }
                return w && w in Object(t) ? u(t) : g(t)
            }
            var _ = k;
            function v(t, e) {
                return function (n) {
                    return t(e(n))
                }
            }
            var y = v;
            var x = y(Object.getPrototypeOf, Object);
            var C = x;
            function A(t) {
                return t != null && typeof t == "object"
            }
            var P = A;
            var T = "[object Object]";
            var S = Function.prototype
                , E = Object.prototype;
            var R = S.toString;
            var O = E.hasOwnProperty;
            var M = R.call(Object);
            function N(t) {
                if (!P(t) || _(t) != T) {
                    return false
                }
                var e = C(t);
                if (e === null) {
                    return true
                }
                var n = O.call(e, "constructor") && e.constructor;
                return typeof n == "function" && n instanceof n && R.call(n) == M
            }
            var I = N;
            function V() {
                this.__data__ = [];
                this.size = 0
            }
            var B = V;
            function F(t, e) {
                return t === e || t !== t && e !== e
            }
            var D = F;
            function z(t, e) {
                var n = t.length;
                while (n--) {
                    if (D(t[n][0], e)) {
                        return n
                    }
                }
                return -1
            }
            var L = z;
            var j = Array.prototype;
            var H = j.splice;
            function q(t) {
                var e = this.__data__
                    , n = L(e, t);
                if (n < 0) {
                    return false
                }
                var i = e.length - 1;
                if (n == i) {
                    e.pop()
                } else {
                    H.call(e, n, 1)
                }
                --this.size;
                return true
            }
            var W = q;
            function U(t) {
                var e = this.__data__
                    , n = L(e, t);
                return n < 0 ? undefined : e[n][1]
            }
            var $ = U;
            function G(t) {
                return L(this.__data__, t) > -1
            }
            var K = G;
            function J(t, e) {
                var n = this.__data__
                    , i = L(n, t);
                if (i < 0) {
                    ++this.size;
                    n.push([t, e])
                } else {
                    n[i][1] = e
                }
                return this
            }
            var Q = J;
            function Y(t) {
                var e = -1
                    , n = t == null ? 0 : t.length;
                this.clear();
                while (++e < n) {
                    var i = t[e];
                    this.set(i[0], i[1])
                }
            }
            Y.prototype.clear = B;
            Y.prototype["delete"] = W;
            Y.prototype.get = $;
            Y.prototype.has = K;
            Y.prototype.set = Q;
            var X = Y;
            function Z() {
                this.__data__ = new X;
                this.size = 0
            }
            var tt = Z;
            function et(t) {
                var e = this.__data__
                    , n = e["delete"](t);
                this.size = e.size;
                return n
            }
            var nt = et;
            function it(t) {
                return this.__data__.get(t)
            }
            var ot = it;
            function st(t) {
                return this.__data__.has(t)
            }
            var rt = st;
            function at(t) {
                var e = typeof t;
                return t != null && (e == "object" || e == "function")
            }
            var ct = at;
            var lt = "[object AsyncFunction]"
                , dt = "[object Function]"
                , ut = "[object GeneratorFunction]"
                , ht = "[object Proxy]";
            function ft(t) {
                if (!ct(t)) {
                    return false
                }
                var e = _(t);
                return e == dt || e == ut || e == lt || e == ht
            }
            var pt = ft;
            var gt = i["a"]["__core-js_shared__"];
            var mt = gt;
            var bt = function () {
                var t = /[^.]+$/.exec(mt && mt.keys && mt.keys.IE_PROTO || "");
                return t ? "Symbol(src)_1." + t : ""
            }();
            function wt(t) {
                return !!bt && bt in t
            }
            var kt = wt;
            var _t = Function.prototype;
            var vt = _t.toString;
            function yt(t) {
                if (t != null) {
                    try {
                        return vt.call(t)
                    } catch (t) { }
                    try {
                        return t + ""
                    } catch (t) { }
                }
                return ""
            }
            var xt = yt;
            var Ct = /[\\^$.*+?()[\]{}|]/g;
            var At = /^\[object .+?Constructor\]$/;
            var Pt = Function.prototype
                , Tt = Object.prototype;
            var St = Pt.toString;
            var Et = Tt.hasOwnProperty;
            var Rt = RegExp("^" + St.call(Et).replace(Ct, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            function Ot(t) {
                if (!ct(t) || kt(t)) {
                    return false
                }
                var e = pt(t) ? Rt : At;
                return e.test(xt(t))
            }
            var Mt = Ot;
            function Nt(t, e) {
                return t == null ? undefined : t[e]
            }
            var It = Nt;
            function Vt(t, e) {
                var n = It(t, e);
                return Mt(n) ? n : undefined
            }
            var Bt = Vt;
            var Ft = Bt(i["a"], "Map");
            var Dt = Ft;
            var zt = Bt(Object, "create");
            var Lt = zt;
            function jt() {
                this.__data__ = Lt ? Lt(null) : {};
                this.size = 0
            }
            var Ht = jt;
            function qt(t) {
                var e = this.has(t) && delete this.__data__[t];
                this.size -= e ? 1 : 0;
                return e
            }
            var Wt = qt;
            var Ut = "__lodash_hash_undefined__";
            var $t = Object.prototype;
            var Gt = $t.hasOwnProperty;
            function Kt(t) {
                var e = this.__data__;
                if (Lt) {
                    var n = e[t];
                    return n === Ut ? undefined : n
                }
                return Gt.call(e, t) ? e[t] : undefined
            }
            var Jt = Kt;
            var Qt = Object.prototype;
            var Yt = Qt.hasOwnProperty;
            function Xt(t) {
                var e = this.__data__;
                return Lt ? e[t] !== undefined : Yt.call(e, t)
            }
            var Zt = Xt;
            var te = "__lodash_hash_undefined__";
            function ee(t, e) {
                var n = this.__data__;
                this.size += this.has(t) ? 0 : 1;
                n[t] = Lt && e === undefined ? te : e;
                return this
            }
            var ne = ee;
            function ie(t) {
                var e = -1
                    , n = t == null ? 0 : t.length;
                this.clear();
                while (++e < n) {
                    var i = t[e];
                    this.set(i[0], i[1])
                }
            }
            ie.prototype.clear = Ht;
            ie.prototype["delete"] = Wt;
            ie.prototype.get = Jt;
            ie.prototype.has = Zt;
            ie.prototype.set = ne;
            var oe = ie;
            function se() {
                this.size = 0;
                this.__data__ = {
                    hash: new oe,
                    map: new (Dt || X),
                    string: new oe
                }
            }
            var re = se;
            function ae(t) {
                var e = typeof t;
                return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
            }
            var ce = ae;
            function le(t, e) {
                var n = t.__data__;
                return ce(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
            }
            var de = le;
            function ue(t) {
                var e = de(this, t)["delete"](t);
                this.size -= e ? 1 : 0;
                return e
            }
            var he = ue;
            function fe(t) {
                return de(this, t).get(t)
            }
            var pe = fe;
            function ge(t) {
                return de(this, t).has(t)
            }
            var me = ge;
            function be(t, e) {
                var n = de(this, t)
                    , i = n.size;
                n.set(t, e);
                this.size += n.size == i ? 0 : 1;
                return this
            }
            var we = be;
            function ke(t) {
                var e = -1
                    , n = t == null ? 0 : t.length;
                this.clear();
                while (++e < n) {
                    var i = t[e];
                    this.set(i[0], i[1])
                }
            }
            ke.prototype.clear = re;
            ke.prototype["delete"] = he;
            ke.prototype.get = pe;
            ke.prototype.has = me;
            ke.prototype.set = we;
            var _e = ke;
            var ve = 200;
            function ye(t, e) {
                var n = this.__data__;
                if (n instanceof X) {
                    var i = n.__data__;
                    if (!Dt || i.length < ve - 1) {
                        i.push([t, e]);
                        this.size = ++n.size;
                        return this
                    }
                    n = this.__data__ = new _e(i)
                }
                n.set(t, e);
                this.size = n.size;
                return this
            }
            var xe = ye;
            function Ce(t) {
                var e = this.__data__ = new X(t);
                this.size = e.size
            }
            Ce.prototype.clear = tt;
            Ce.prototype["delete"] = nt;
            Ce.prototype.get = ot;
            Ce.prototype.has = rt;
            Ce.prototype.set = xe;
            var Ae = Ce;
            function Pe(t, e) {
                var n = -1
                    , i = t == null ? 0 : t.length;
                while (++n < i) {
                    if (e(t[n], n, t) === false) {
                        break
                    }
                }
                return t
            }
            var Te = Pe;
            var Se = function () {
                try {
                    var t = Bt(Object, "defineProperty");
                    t({}, "", {});
                    return t
                } catch (t) { }
            }();
            var Ee = Se;
            function Re(t, e, n) {
                if (e == "__proto__" && Ee) {
                    Ee(t, e, {
                        configurable: true,
                        enumerable: true,
                        value: n,
                        writable: true
                    })
                } else {
                    t[e] = n
                }
            }
            var Oe = Re;
            var Me = Object.prototype;
            var Ne = Me.hasOwnProperty;
            function Ie(t, e, n) {
                var i = t[e];
                if (!(Ne.call(t, e) && D(i, n)) || n === undefined && !(e in t)) {
                    Oe(t, e, n)
                }
            }
            var Ve = Ie;
            function Be(t, e, n, i) {
                var o = !n;
                n || (n = {});
                var s = -1
                    , r = e.length;
                while (++s < r) {
                    var a = e[s];
                    var c = i ? i(n[a], t[a], a, n, t) : undefined;
                    if (c === undefined) {
                        c = t[a]
                    }
                    if (o) {
                        Oe(n, a, c)
                    } else {
                        Ve(n, a, c)
                    }
                }
                return n
            }
            var Fe = Be;
            function De(t, e) {
                var n = -1
                    , i = Array(t);
                while (++n < t) {
                    i[n] = e(n)
                }
                return i
            }
            var ze = De;
            var Le = "[object Arguments]";
            function je(t) {
                return P(t) && _(t) == Le
            }
            var He = je;
            var qe = Object.prototype;
            var We = qe.hasOwnProperty;
            var Ue = qe.propertyIsEnumerable;
            var $e = He(function () {
                return arguments
            }()) ? He : function (t) {
                return P(t) && We.call(t, "callee") && !Ue.call(t, "callee")
            }
                ;
            var Ge = $e;
            var Ke = Array.isArray;
            var Je = Ke;
            var Qe = n(4);
            var Ye = 9007199254740991;
            var Xe = /^(?:0|[1-9]\d*)$/;
            function Ze(t, e) {
                var n = typeof t;
                e = e == null ? Ye : e;
                return !!e && (n == "number" || n != "symbol" && Xe.test(t)) && (t > -1 && t % 1 == 0 && t < e)
            }
            var tn = Ze;
            var en = 9007199254740991;
            function nn(t) {
                return typeof t == "number" && t > -1 && t % 1 == 0 && t <= en
            }
            var on = nn;
            var sn = "[object Arguments]"
                , rn = "[object Array]"
                , an = "[object Boolean]"
                , cn = "[object Date]"
                , ln = "[object Error]"
                , dn = "[object Function]"
                , un = "[object Map]"
                , hn = "[object Number]"
                , fn = "[object Object]"
                , pn = "[object RegExp]"
                , gn = "[object Set]"
                , mn = "[object String]"
                , bn = "[object WeakMap]";
            var wn = "[object ArrayBuffer]"
                , kn = "[object DataView]"
                , _n = "[object Float32Array]"
                , vn = "[object Float64Array]"
                , yn = "[object Int8Array]"
                , xn = "[object Int16Array]"
                , Cn = "[object Int32Array]"
                , An = "[object Uint8Array]"
                , Pn = "[object Uint8ClampedArray]"
                , Tn = "[object Uint16Array]"
                , Sn = "[object Uint32Array]";
            var En = {};
            En[_n] = En[vn] = En[yn] = En[xn] = En[Cn] = En[An] = En[Pn] = En[Tn] = En[Sn] = true;
            En[sn] = En[rn] = En[wn] = En[an] = En[kn] = En[cn] = En[ln] = En[dn] = En[un] = En[hn] = En[fn] = En[pn] = En[gn] = En[mn] = En[bn] = false;
            function Rn(t) {
                return P(t) && on(t.length) && !!En[_(t)]
            }
            var On = Rn;
            function Mn(t) {
                return function (e) {
                    return t(e)
                }
            }
            var Nn = Mn;
            var In = n(5);
            var Vn = In["a"] && In["a"].isTypedArray;
            var Bn = Vn ? Nn(Vn) : On;
            var Fn = Bn;
            var Dn = Object.prototype;
            var zn = Dn.hasOwnProperty;
            function Ln(t, e) {
                var n = Je(t)
                    , i = !n && Ge(t)
                    , o = !n && !i && Object(Qe["a"])(t)
                    , s = !n && !i && !o && Fn(t)
                    , r = n || i || o || s
                    , a = r ? ze(t.length, String) : []
                    , c = a.length;
                for (var l in t) {
                    if ((e || zn.call(t, l)) && !(r && (l == "length" || o && (l == "offset" || l == "parent") || s && (l == "buffer" || l == "byteLength" || l == "byteOffset") || tn(l, c)))) {
                        a.push(l)
                    }
                }
                return a
            }
            var jn = Ln;
            var Hn = Object.prototype;
            function qn(t) {
                var e = t && t.constructor
                    , n = typeof e == "function" && e.prototype || Hn;
                return t === n
            }
            var Wn = qn;
            var Un = y(Object.keys, Object);
            var $n = Un;
            var Gn = Object.prototype;
            var Kn = Gn.hasOwnProperty;
            function Jn(t) {
                if (!Wn(t)) {
                    return $n(t)
                }
                var e = [];
                for (var n in Object(t)) {
                    if (Kn.call(t, n) && n != "constructor") {
                        e.push(n)
                    }
                }
                return e
            }
            var Qn = Jn;
            function Yn(t) {
                return t != null && on(t.length) && !pt(t)
            }
            var Xn = Yn;
            function Zn(t) {
                return Xn(t) ? jn(t) : Qn(t)
            }
            var ti = Zn;
            function ei(t, e) {
                return t && Fe(e, ti(e), t)
            }
            var ni = ei;
            function ii(t) {
                var e = [];
                if (t != null) {
                    for (var n in Object(t)) {
                        e.push(n)
                    }
                }
                return e
            }
            var oi = ii;
            var si = Object.prototype;
            var ri = si.hasOwnProperty;
            function ai(t) {
                if (!ct(t)) {
                    return oi(t)
                }
                var e = Wn(t)
                    , n = [];
                for (var i in t) {
                    if (!(i == "constructor" && (e || !ri.call(t, i)))) {
                        n.push(i)
                    }
                }
                return n
            }
            var ci = ai;
            function li(t) {
                return Xn(t) ? jn(t, true) : ci(t)
            }
            var di = li;
            function ui(t, e) {
                return t && Fe(e, di(e), t)
            }
            var hi = ui;
            var fi = n(8);
            function pi(t, e) {
                var n = -1
                    , i = t.length;
                e || (e = Array(i));
                while (++n < i) {
                    e[n] = t[n]
                }
                return e
            }
            var gi = pi;
            function mi(t, e) {
                var n = -1
                    , i = t == null ? 0 : t.length
                    , o = 0
                    , s = [];
                while (++n < i) {
                    var r = t[n];
                    if (e(r, n, t)) {
                        s[o++] = r
                    }
                }
                return s
            }
            var bi = mi;
            function wi() {
                return []
            }
            var ki = wi;
            var _i = Object.prototype;
            var vi = _i.propertyIsEnumerable;
            var yi = Object.getOwnPropertySymbols;
            var xi = !yi ? ki : function (t) {
                if (t == null) {
                    return []
                }
                t = Object(t);
                return bi(yi(t), (function (e) {
                    return vi.call(t, e)
                }
                ))
            }
                ;
            var Ci = xi;
            function Ai(t, e) {
                return Fe(t, Ci(t), e)
            }
            var Pi = Ai;
            function Ti(t, e) {
                var n = -1
                    , i = e.length
                    , o = t.length;
                while (++n < i) {
                    t[o + n] = e[n]
                }
                return t
            }
            var Si = Ti;
            var Ei = Object.getOwnPropertySymbols;
            var Ri = !Ei ? ki : function (t) {
                var e = [];
                while (t) {
                    Si(e, Ci(t));
                    t = C(t)
                }
                return e
            }
                ;
            var Oi = Ri;
            function Mi(t, e) {
                return Fe(t, Oi(t), e)
            }
            var Ni = Mi;
            function Ii(t, e, n) {
                var i = e(t);
                return Je(t) ? i : Si(i, n(t))
            }
            var Vi = Ii;
            function Bi(t) {
                return Vi(t, ti, Ci)
            }
            var Fi = Bi;
            function Di(t) {
                return Vi(t, di, Oi)
            }
            var zi = Di;
            var Li = Bt(i["a"], "DataView");
            var ji = Li;
            var Hi = Bt(i["a"], "Promise");
            var qi = Hi;
            var Wi = Bt(i["a"], "Set");
            var Ui = Wi;
            var $i = Bt(i["a"], "WeakMap");
            var Gi = $i;
            var Ki = "[object Map]"
                , Ji = "[object Object]"
                , Qi = "[object Promise]"
                , Yi = "[object Set]"
                , Xi = "[object WeakMap]";
            var Zi = "[object DataView]";
            var to = xt(ji)
                , eo = xt(Dt)
                , no = xt(qi)
                , io = xt(Ui)
                , oo = xt(Gi);
            var so = _;
            if (ji && so(new ji(new ArrayBuffer(1))) != Zi || Dt && so(new Dt) != Ki || qi && so(qi.resolve()) != Qi || Ui && so(new Ui) != Yi || Gi && so(new Gi) != Xi) {
                so = function (t) {
                    var e = _(t)
                        , n = e == Ji ? t.constructor : undefined
                        , i = n ? xt(n) : "";
                    if (i) {
                        switch (i) {
                            case to:
                                return Zi;
                            case eo:
                                return Ki;
                            case no:
                                return Qi;
                            case io:
                                return Yi;
                            case oo:
                                return Xi
                        }
                    }
                    return e
                }
            }
            var ro = so;
            var ao = Object.prototype;
            var co = ao.hasOwnProperty;
            function lo(t) {
                var e = t.length
                    , n = new t.constructor(e);
                if (e && typeof t[0] == "string" && co.call(t, "index")) {
                    n.index = t.index;
                    n.input = t.input
                }
                return n
            }
            var uo = lo;
            var ho = i["a"].Uint8Array;
            var fo = ho;
            function po(t) {
                var e = new t.constructor(t.byteLength);
                new fo(e).set(new fo(t));
                return e
            }
            var go = po;
            function mo(t, e) {
                var n = e ? go(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.byteLength)
            }
            var bo = mo;
            var wo = /\w*$/;
            function ko(t) {
                var e = new t.constructor(t.source, wo.exec(t));
                e.lastIndex = t.lastIndex;
                return e
            }
            var _o = ko;
            var vo = s ? s.prototype : undefined
                , yo = vo ? vo.valueOf : undefined;
            function xo(t) {
                return yo ? Object(yo.call(t)) : {}
            }
            var Co = xo;
            function Ao(t, e) {
                var n = e ? go(t.buffer) : t.buffer;
                return new t.constructor(n, t.byteOffset, t.length)
            }
            var Po = Ao;
            var To = "[object Boolean]"
                , So = "[object Date]"
                , Eo = "[object Map]"
                , Ro = "[object Number]"
                , Oo = "[object RegExp]"
                , Mo = "[object Set]"
                , No = "[object String]"
                , Io = "[object Symbol]";
            var Vo = "[object ArrayBuffer]"
                , Bo = "[object DataView]"
                , Fo = "[object Float32Array]"
                , Do = "[object Float64Array]"
                , zo = "[object Int8Array]"
                , Lo = "[object Int16Array]"
                , jo = "[object Int32Array]"
                , Ho = "[object Uint8Array]"
                , qo = "[object Uint8ClampedArray]"
                , Wo = "[object Uint16Array]"
                , Uo = "[object Uint32Array]";
            function $o(t, e, n) {
                var i = t.constructor;
                switch (e) {
                    case Vo:
                        return go(t);
                    case To:
                    case So:
                        return new i(+t);
                    case Bo:
                        return bo(t, n);
                    case Fo:
                    case Do:
                    case zo:
                    case Lo:
                    case jo:
                    case Ho:
                    case qo:
                    case Wo:
                    case Uo:
                        return Po(t, n);
                    case Eo:
                        return new i;
                    case Ro:
                    case No:
                        return new i(t);
                    case Oo:
                        return _o(t);
                    case Mo:
                        return new i;
                    case Io:
                        return Co(t)
                }
            }
            var Go = $o;
            var Ko = Object.create;
            var Jo = function () {
                function t() { }
                return function (e) {
                    if (!ct(e)) {
                        return {}
                    }
                    if (Ko) {
                        return Ko(e)
                    }
                    t.prototype = e;
                    var n = new t;
                    t.prototype = undefined;
                    return n
                }
            }();
            var Qo = Jo;
            function Yo(t) {
                return typeof t.constructor == "function" && !Wn(t) ? Qo(C(t)) : {}
            }
            var Xo = Yo;
            var Zo = "[object Map]";
            function ts(t) {
                return P(t) && ro(t) == Zo
            }
            var es = ts;
            var ns = In["a"] && In["a"].isMap;
            var is = ns ? Nn(ns) : es;
            var os = is;
            var ss = "[object Set]";
            function rs(t) {
                return P(t) && ro(t) == ss
            }
            var as = rs;
            var cs = In["a"] && In["a"].isSet;
            var ls = cs ? Nn(cs) : as;
            var ds = ls;
            var us = 1
                , hs = 2
                , fs = 4;
            var ps = "[object Arguments]"
                , gs = "[object Array]"
                , ms = "[object Boolean]"
                , bs = "[object Date]"
                , ws = "[object Error]"
                , ks = "[object Function]"
                , _s = "[object GeneratorFunction]"
                , vs = "[object Map]"
                , ys = "[object Number]"
                , xs = "[object Object]"
                , Cs = "[object RegExp]"
                , As = "[object Set]"
                , Ps = "[object String]"
                , Ts = "[object Symbol]"
                , Ss = "[object WeakMap]";
            var Es = "[object ArrayBuffer]"
                , Rs = "[object DataView]"
                , Os = "[object Float32Array]"
                , Ms = "[object Float64Array]"
                , Ns = "[object Int8Array]"
                , Is = "[object Int16Array]"
                , Vs = "[object Int32Array]"
                , Bs = "[object Uint8Array]"
                , Fs = "[object Uint8ClampedArray]"
                , Ds = "[object Uint16Array]"
                , zs = "[object Uint32Array]";
            var Ls = {};
            Ls[ps] = Ls[gs] = Ls[Es] = Ls[Rs] = Ls[ms] = Ls[bs] = Ls[Os] = Ls[Ms] = Ls[Ns] = Ls[Is] = Ls[Vs] = Ls[vs] = Ls[ys] = Ls[xs] = Ls[Cs] = Ls[As] = Ls[Ps] = Ls[Ts] = Ls[Bs] = Ls[Fs] = Ls[Ds] = Ls[zs] = true;
            Ls[ws] = Ls[ks] = Ls[Ss] = false;
            function js(t, e, n, i, o, s) {
                var r, a = e & us, c = e & hs, l = e & fs;
                if (n) {
                    r = o ? n(t, i, o, s) : n(t)
                }
                if (r !== undefined) {
                    return r
                }
                if (!ct(t)) {
                    return t
                }
                var d = Je(t);
                if (d) {
                    r = uo(t);
                    if (!a) {
                        return gi(t, r)
                    }
                } else {
                    var u = ro(t)
                        , h = u == ks || u == _s;
                    if (Object(Qe["a"])(t)) {
                        return Object(fi["a"])(t, a)
                    }
                    if (u == xs || u == ps || h && !o) {
                        r = c || h ? {} : Xo(t);
                        if (!a) {
                            return c ? Ni(t, hi(r, t)) : Pi(t, ni(r, t))
                        }
                    } else {
                        if (!Ls[u]) {
                            return o ? t : {}
                        }
                        r = Go(t, u, a)
                    }
                }
                s || (s = new Ae);
                var f = s.get(t);
                if (f) {
                    return f
                }
                s.set(t, r);
                if (ds(t)) {
                    t.forEach((function (i) {
                        r.add(js(i, e, n, i, t, s))
                    }
                    ))
                } else if (os(t)) {
                    t.forEach((function (i, o) {
                        r.set(o, js(i, e, n, o, t, s))
                    }
                    ))
                }
                var p = l ? c ? zi : Fi : c ? keysIn : ti;
                var g = d ? undefined : p(t);
                Te(g || t, (function (i, o) {
                    if (g) {
                        o = i;
                        i = t[o]
                    }
                    Ve(r, o, js(i, e, n, o, t, s))
                }
                ));
                return r
            }
            var Hs = js;
            var qs = 1
                , Ws = 4;
            function Us(t, e) {
                e = typeof e == "function" ? e : undefined;
                return Hs(t, qs | Ws, e)
            }
            var $s = Us;
            function Gs(t) {
                return P(t) && t.nodeType === 1 && !I(t)
            }
            var Ks = Gs;
            class Js {
                constructor(t, e) {
                    this._config = {};
                    if (e) {
                        this.define(Qs(e))
                    }
                    if (t) {
                        this._setObjectToTarget(this._config, t)
                    }
                }
                set(t, e) {
                    this._setToTarget(this._config, t, e)
                }
                define(t, e) {
                    const n = true;
                    this._setToTarget(this._config, t, e, n)
                }
                get(t) {
                    return this._getFromSource(this._config, t)
                }
                *names() {
                    for (const t of Object.keys(this._config)) {
                        yield t
                    }
                }
                _setToTarget(t, e, n, i = false) {
                    if (I(e)) {
                        this._setObjectToTarget(t, e, i);
                        return
                    }
                    const o = e.split(".");
                    e = o.pop();
                    for (const e of o) {
                        if (!I(t[e])) {
                            t[e] = {}
                        }
                        t = t[e]
                    }
                    if (I(n)) {
                        if (!I(t[e])) {
                            t[e] = {}
                        }
                        t = t[e];
                        this._setObjectToTarget(t, n, i);
                        return
                    }
                    if (i && typeof t[e] != "undefined") {
                        return
                    }
                    t[e] = n
                }
                _getFromSource(t, e) {
                    const n = e.split(".");
                    e = n.pop();
                    for (const e of n) {
                        if (!I(t[e])) {
                            t = null;
                            break
                        }
                        t = t[e]
                    }
                    return t ? Qs(t[e]) : undefined
                }
                _setObjectToTarget(t, e, n) {
                    Object.keys(e).forEach(i => {
                        this._setToTarget(t, i, e[i], n)
                    }
                    )
                }
            }
            function Qs(t) {
                return $s(t, Ys)
            }
            function Ys(t) {
                return Ks(t) ? t : undefined
            }
            function Xs() {
                return function t() {
                    t.called = true
                }
            }
            var Zs = Xs;
            class tr {
                constructor(t, e) {
                    this.source = t;
                    this.name = e;
                    this.path = [];
                    this.stop = Zs();
                    this.off = Zs()
                }
            }
            const er = new Array(256).fill().map((t, e) => ("0" + e.toString(16)).slice(-2));
            function nr() {
                const t = Math.random() * 4294967296 >>> 0;
                const e = Math.random() * 4294967296 >>> 0;
                const n = Math.random() * 4294967296 >>> 0;
                const i = Math.random() * 4294967296 >>> 0;
                return "e" + er[t >> 0 & 255] + er[t >> 8 & 255] + er[t >> 16 & 255] + er[t >> 24 & 255] + er[e >> 0 & 255] + er[e >> 8 & 255] + er[e >> 16 & 255] + er[e >> 24 & 255] + er[n >> 0 & 255] + er[n >> 8 & 255] + er[n >> 16 & 255] + er[n >> 24 & 255] + er[i >> 0 & 255] + er[i >> 8 & 255] + er[i >> 16 & 255] + er[i >> 24 & 255]
            }
            const ir = {
                get(t) {
                    if (typeof t != "number") {
                        return this[t] || this.normal
                    } else {
                        return t
                    }
                },
                highest: 1e5,
                high: 1e3,
                normal: 0,
                low: -1e3,
                lowest: -1e5
            };
            var or = ir;
            var sr = n(6);
            var rr = n(0);
            const ar = Symbol("listeningTo");
            const cr = Symbol("emitterId");
            const lr = {
                on(t, e, n = {}) {
                    this.listenTo(this, t, e, n)
                },
                once(t, e, n) {
                    let i = false;
                    const o = function (t, ...n) {
                        if (!i) {
                            i = true;
                            t.off();
                            e.call(this, t, ...n)
                        }
                    };
                    this.listenTo(this, t, o, n)
                },
                off(t, e) {
                    this.stopListening(this, t, e)
                },
                listenTo(t, e, n, i = {}) {
                    let o, s;
                    if (!this[ar]) {
                        this[ar] = {}
                    }
                    const r = this[ar];
                    if (!fr(t)) {
                        hr(t)
                    }
                    const a = fr(t);
                    if (!(o = r[a])) {
                        o = r[a] = {
                            emitter: t,
                            callbacks: {}
                        }
                    }
                    if (!(s = o.callbacks[e])) {
                        s = o.callbacks[e] = []
                    }
                    s.push(n);
                    mr(t, e);
                    const c = br(t, e);
                    const l = or.get(i.priority);
                    const d = {
                        callback: n,
                        priority: l
                    };
                    for (const t of c) {
                        let e = false;
                        for (let n = 0; n < t.length; n++) {
                            if (t[n].priority < l) {
                                t.splice(n, 0, d);
                                e = true;
                                break
                            }
                        }
                        if (!e) {
                            t.push(d)
                        }
                    }
                },
                stopListening(t, e, n) {
                    const i = this[ar];
                    let o = t && fr(t);
                    const s = i && o && i[o];
                    const r = s && e && s.callbacks[e];
                    if (!i || t && !s || e && !r) {
                        return
                    }
                    if (n) {
                        _r(t, e, n)
                    } else if (r) {
                        while (n = r.pop()) {
                            _r(t, e, n)
                        }
                        delete s.callbacks[e]
                    } else if (s) {
                        for (e in s.callbacks) {
                            this.stopListening(t, e)
                        }
                        delete i[o]
                    } else {
                        for (o in i) {
                            this.stopListening(i[o].emitter)
                        }
                        delete this[ar]
                    }
                },
                fire(t, ...e) {
                    try {
                        const n = t instanceof tr ? t : new tr(this, t);
                        const i = n.name;
                        let o = wr(this, i);
                        n.path.push(this);
                        if (o) {
                            const t = [n, ...e];
                            o = Array.from(o);
                            for (let e = 0; e < o.length; e++) {
                                o[e].callback.apply(this, t);
                                if (n.off.called) {
                                    delete n.off.called;
                                    _r(this, i, o[e].callback)
                                }
                                if (n.stop.called) {
                                    break
                                }
                            }
                        }
                        if (this._delegations) {
                            const t = this._delegations.get(i);
                            const o = this._delegations.get("*");
                            if (t) {
                                kr(t, n, e)
                            }
                            if (o) {
                                kr(o, n, e)
                            }
                        }
                        return n.return
                    } catch (t) {
                        rr["b"].rethrowUnexpectedError(t, this)
                    }
                },
                delegate(...t) {
                    return {
                        to: (e, n) => {
                            if (!this._delegations) {
                                this._delegations = new Map
                            }
                            t.forEach(t => {
                                const i = this._delegations.get(t);
                                if (!i) {
                                    this._delegations.set(t, new Map([[e, n]]))
                                } else {
                                    i.set(e, n)
                                }
                            }
                            )
                        }
                    }
                },
                stopDelegating(t, e) {
                    if (!this._delegations) {
                        return
                    }
                    if (!t) {
                        this._delegations.clear()
                    } else if (!e) {
                        this._delegations.delete(t)
                    } else {
                        const n = this._delegations.get(t);
                        if (n) {
                            n.delete(e)
                        }
                    }
                }
            };
            var dr = lr;
            function ur(t, e) {
                if (t[ar] && t[ar][e]) {
                    return t[ar][e].emitter
                }
                return null
            }
            function hr(t, e) {
                if (!t[cr]) {
                    t[cr] = e || nr()
                }
            }
            function fr(t) {
                return t[cr]
            }
            function pr(t) {
                if (!t._events) {
                    Object.defineProperty(t, "_events", {
                        value: {}
                    })
                }
                return t._events
            }
            function gr() {
                return {
                    callbacks: [],
                    childEvents: []
                }
            }
            function mr(t, e) {
                const n = pr(t);
                if (n[e]) {
                    return
                }
                let i = e;
                let o = null;
                const s = [];
                while (i !== "") {
                    if (n[i]) {
                        break
                    }
                    n[i] = gr();
                    s.push(n[i]);
                    if (o) {
                        n[i].childEvents.push(o)
                    }
                    o = i;
                    i = i.substr(0, i.lastIndexOf(":"))
                }
                if (i !== "") {
                    for (const t of s) {
                        t.callbacks = n[i].callbacks.slice()
                    }
                    n[i].childEvents.push(o)
                }
            }
            function br(t, e) {
                const n = pr(t)[e];
                if (!n) {
                    return []
                }
                let i = [n.callbacks];
                for (let e = 0; e < n.childEvents.length; e++) {
                    const o = br(t, n.childEvents[e]);
                    i = i.concat(o)
                }
                return i
            }
            function wr(t, e) {
                let n;
                if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
                    if (e.indexOf(":") > -1) {
                        return wr(t, e.substr(0, e.lastIndexOf(":")))
                    } else {
                        return null
                    }
                }
                return n.callbacks
            }
            function kr(t, e, n) {
                for (let [i, o] of t) {
                    if (!o) {
                        o = e.name
                    } else if (typeof o == "function") {
                        o = o(e.name)
                    }
                    const t = new tr(e.source, o);
                    t.path = [...e.path];
                    i.fire(t, ...n)
                }
            }
            function _r(t, e, n) {
                const i = br(t, e);
                for (const t of i) {
                    for (let e = 0; e < t.length; e++) {
                        if (t[e].callback == n) {
                            t.splice(e, 1);
                            e--
                        }
                    }
                }
            }
            function vr(t, ...e) {
                e.forEach(e => {
                    Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)).forEach(n => {
                        if (n in t.prototype) {
                            return
                        }
                        const i = Object.getOwnPropertyDescriptor(e, n);
                        i.enumerable = false;
                        Object.defineProperty(t.prototype, n, i)
                    }
                    )
                }
                )
            }
            class yr {
                constructor(t = {}) {
                    this._items = [];
                    this._itemMap = new Map;
                    this._idProperty = t.idProperty || "id";
                    this._bindToExternalToInternalMap = new WeakMap;
                    this._bindToInternalToExternalMap = new WeakMap;
                    this._skippedIndexesFromExternal = []
                }
                get length() {
                    return this._items.length
                }
                get first() {
                    return this._items[0] || null
                }
                get last() {
                    return this._items[this.length - 1] || null
                }
                add(t, e) {
                    let n;
                    const i = this._idProperty;
                    if (i in t) {
                        n = t[i];
                        if (typeof n != "string") {
                            throw new rr["b"]("collection-add-invalid-id", this)
                        }
                        if (this.get(n)) {
                            throw new rr["b"]("collection-add-item-already-exists", this)
                        }
                    } else {
                        t[i] = n = nr()
                    }
                    if (e === undefined) {
                        e = this._items.length
                    } else if (e > this._items.length || e < 0) {
                        throw new rr["b"]("collection-add-item-invalid-index", this)
                    }
                    this._items.splice(e, 0, t);
                    this._itemMap.set(n, t);
                    this.fire("add", t, e);
                    return this
                }
                get(t) {
                    let e;
                    if (typeof t == "string") {
                        e = this._itemMap.get(t)
                    } else if (typeof t == "number") {
                        e = this._items[t]
                    } else {
                        throw new rr["b"]("collection-get-invalid-arg: Index or id must be given.", this)
                    }
                    return e || null
                }
                has(t) {
                    if (typeof t == "string") {
                        return this._itemMap.has(t)
                    } else {
                        const e = this._idProperty;
                        const n = t[e];
                        return this._itemMap.has(n)
                    }
                }
                getIndex(t) {
                    let e;
                    if (typeof t == "string") {
                        e = this._itemMap.get(t)
                    } else {
                        e = t
                    }
                    return this._items.indexOf(e)
                }
                remove(t) {
                    let e, n, i;
                    let o = false;
                    const s = this._idProperty;
                    if (typeof t == "string") {
                        n = t;
                        i = this._itemMap.get(n);
                        o = !i;
                        if (i) {
                            e = this._items.indexOf(i)
                        }
                    } else if (typeof t == "number") {
                        e = t;
                        i = this._items[e];
                        o = !i;
                        if (i) {
                            n = i[s]
                        }
                    } else {
                        i = t;
                        n = i[s];
                        e = this._items.indexOf(i);
                        o = e == -1 || !this._itemMap.get(n)
                    }
                    if (o) {
                        throw new rr["b"]("collection-remove-404: Item not found.", this)
                    }
                    this._items.splice(e, 1);
                    this._itemMap.delete(n);
                    const r = this._bindToInternalToExternalMap.get(i);
                    this._bindToInternalToExternalMap.delete(i);
                    this._bindToExternalToInternalMap.delete(r);
                    this.fire("remove", i, e);
                    return i
                }
                map(t, e) {
                    return this._items.map(t, e)
                }
                find(t, e) {
                    return this._items.find(t, e)
                }
                filter(t, e) {
                    return this._items.filter(t, e)
                }
                clear() {
                    if (this._bindToCollection) {
                        this.stopListening(this._bindToCollection);
                        this._bindToCollection = null
                    }
                    while (this.length) {
                        this.remove(0)
                    }
                }
                bindTo(t) {
                    if (this._bindToCollection) {
                        throw new rr["b"]("collection-bind-to-rebind: The collection cannot be bound more than once.", this)
                    }
                    this._bindToCollection = t;
                    return {
                        as: t => {
                            this._setUpBindToBinding(e => new t(e))
                        }
                        ,
                        using: t => {
                            if (typeof t == "function") {
                                this._setUpBindToBinding(e => t(e))
                            } else {
                                this._setUpBindToBinding(e => e[t])
                            }
                        }
                    }
                }
                _setUpBindToBinding(t) {
                    const e = this._bindToCollection;
                    const n = (n, i, o) => {
                        const s = e._bindToCollection == this;
                        const r = e._bindToInternalToExternalMap.get(i);
                        if (s && r) {
                            this._bindToExternalToInternalMap.set(i, r);
                            this._bindToInternalToExternalMap.set(r, i)
                        } else {
                            const n = t(i);
                            if (!n) {
                                this._skippedIndexesFromExternal.push(o);
                                return
                            }
                            let s = o;
                            for (const t of this._skippedIndexesFromExternal) {
                                if (o > t) {
                                    s--
                                }
                            }
                            for (const t of e._skippedIndexesFromExternal) {
                                if (s >= t) {
                                    s++
                                }
                            }
                            this._bindToExternalToInternalMap.set(i, n);
                            this._bindToInternalToExternalMap.set(n, i);
                            this.add(n, s);
                            for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                                if (s <= e._skippedIndexesFromExternal[t]) {
                                    e._skippedIndexesFromExternal[t]++
                                }
                            }
                        }
                    }
                        ;
                    for (const t of e) {
                        n(null, t, e.getIndex(t))
                    }
                    this.listenTo(e, "add", n);
                    this.listenTo(e, "remove", (t, e, n) => {
                        const i = this._bindToExternalToInternalMap.get(e);
                        if (i) {
                            this.remove(i)
                        }
                        this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t, e) => {
                            if (n < e) {
                                t.push(e - 1)
                            }
                            if (n > e) {
                                t.push(e)
                            }
                            return t
                        }
                            , [])
                    }
                    )
                }
                [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }
            }
            vr(yr, dr);
            class xr {
                constructor(t, e = [], n = []) {
                    this._context = t;
                    this._plugins = new Map;
                    this._availablePlugins = new Map;
                    for (const t of e) {
                        if (t.pluginName) {
                            this._availablePlugins.set(t.pluginName, t)
                        }
                    }
                    this._contextPlugins = new Map;
                    for (const [t, e] of n) {
                        this._contextPlugins.set(t, e);
                        this._contextPlugins.set(e, t);
                        if (t.pluginName) {
                            this._availablePlugins.set(t.pluginName, t)
                        }
                    }
                }
                *[Symbol.iterator]() {
                    for (const t of this._plugins) {
                        if (typeof t[0] == "function") {
                            yield t
                        }
                    }
                }
                get(t) {
                    const e = this._plugins.get(t);
                    if (!e) {
                        const e = "plugincollection-plugin-not-loaded: The requested plugin is not loaded.";
                        let n = t;
                        if (typeof t == "function") {
                            n = t.pluginName || t.name
                        }
                        throw new rr["b"](e, this._context, {
                            plugin: n
                        })
                    }
                    return e
                }
                has(t) {
                    return this._plugins.has(t)
                }
                init(t, e = []) {
                    const n = this;
                    const i = this._context;
                    const o = new Set;
                    const s = [];
                    const r = p(t);
                    const a = p(e);
                    const c = f(t);
                    if (c) {
                        const t = "plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.";
                        console.error(Object(rr["a"])(t), {
                            plugins: c
                        });
                        return Promise.reject(new rr["b"](t, i, {
                            plugins: c
                        }))
                    }
                    return Promise.all(r.map(l)).then(() => d(s, "init")).then(() => d(s, "afterInit")).then(() => s);
                    function l(t) {
                        if (a.includes(t)) {
                            return
                        }
                        if (n._plugins.has(t) || o.has(t)) {
                            return
                        }
                        return u(t).catch(e => {
                            console.error(Object(rr["a"])("plugincollection-load: It was not possible to load the plugin."), {
                                plugin: t
                            });
                            throw e
                        }
                        )
                    }
                    function d(t, e) {
                        return t.reduce((t, i) => {
                            if (!i[e]) {
                                return t
                            }
                            if (n._contextPlugins.has(i)) {
                                return t
                            }
                            return t.then(i[e].bind(i))
                        }
                            , Promise.resolve())
                    }
                    function u(t) {
                        return new Promise(r => {
                            o.add(t);
                            if (t.requires) {
                                t.requires.forEach(n => {
                                    const o = h(n);
                                    if (t.isContextPlugin && !o.isContextPlugin) {
                                        throw new rr["b"]("plugincollection-context-required: Context plugin can not require plugin which is not a context plugin", null, {
                                            plugin: o.name,
                                            requiredBy: t.name
                                        })
                                    }
                                    if (e.includes(o)) {
                                        throw new rr["b"]("plugincollection-required: Cannot load a plugin because one of its dependencies is listed in" + "the `removePlugins` option.", i, {
                                            plugin: o.name,
                                            requiredBy: t.name
                                        })
                                    }
                                    l(o)
                                }
                                )
                            }
                            const a = n._contextPlugins.get(t) || new t(i);
                            n._add(t, a);
                            s.push(a);
                            r()
                        }
                        )
                    }
                    function h(t) {
                        if (typeof t == "function") {
                            return t
                        }
                        return n._availablePlugins.get(t)
                    }
                    function f(t) {
                        const e = [];
                        for (const n of t) {
                            if (!h(n)) {
                                e.push(n)
                            }
                        }
                        return e.length ? e : null
                    }
                    function p(t) {
                        return t.map(t => h(t)).filter(t => !!t)
                    }
                }
                destroy() {
                    const t = [];
                    for (const [, e] of this) {
                        if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) {
                            t.push(e.destroy())
                        }
                    }
                    return Promise.all(t)
                }
                _add(t, e) {
                    this._plugins.set(t, e);
                    const n = t.pluginName;
                    if (!n) {
                        return
                    }
                    if (this._plugins.has(n)) {
                        throw new rr["b"]("plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.", null, {
                            pluginName: n,
                            plugin1: this._plugins.get(n).constructor,
                            plugin2: t
                        })
                    }
                    this._plugins.set(n, e)
                }
            }
            vr(xr, dr);
            if (!window.CKEDITOR_TRANSLATIONS) {
                window.CKEDITOR_TRANSLATIONS = {}
            }
            function Cr(t, e) {
                const n = window.CKEDITOR_TRANSLATIONS[t] || (window.CKEDITOR_TRANSLATIONS[t] = {});
                Object.assign(n, e)
            }
            function Ar(t, e) {
                const n = Sr();
                if (n === 1) {
                    t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]
                }
                if (n === 0 || !Tr(t, e)) {
                    return e.replace(/ \[context: [^\]]+\]$/, "")
                }
                const i = window.CKEDITOR_TRANSLATIONS[t];
                return i[e].replace(/ \[context: [^\]]+\]$/, "")
            }
            function Pr() {
                window.CKEDITOR_TRANSLATIONS = {}
            }
            function Tr(t, e) {
                return t in window.CKEDITOR_TRANSLATIONS && e in window.CKEDITOR_TRANSLATIONS[t]
            }
            function Sr() {
                return Object.keys(window.CKEDITOR_TRANSLATIONS).length
            }
            const Er = ["ar", "fa", "he", "ku", "ug"];
            class Rr {
                constructor(t = {}) {
                    this.uiLanguage = t.uiLanguage || "en";
                    this.contentLanguage = t.contentLanguage || this.uiLanguage;
                    this.uiLanguageDirection = Or(this.uiLanguage);
                    this.contentLanguageDirection = Or(this.contentLanguage);
                    this.t = (...t) => this._t(...t)
                }
                get language() {
                    console.warn("locale-deprecated-language-property: " + "The Locale#language property has been deprecated and will be removed in the near future. " + "Please use #uiLanguage and #contentLanguage properties instead.");
                    return this.uiLanguage
                }
                _t(t, e) {
                    let n = Ar(this.uiLanguage, t);
                    if (e) {
                        n = n.replace(/%(\d+)/g, (t, n) => n < e.length ? e[n] : t)
                    }
                    return n
                }
            }
            function Or(t) {
                return Er.includes(t) ? "rtl" : "ltr"
            }
            class Mr {
                constructor(t) {
                    this.config = new Js(t, this.constructor.defaultConfig);
                    const e = this.constructor.builtinPlugins;
                    this.config.define("plugins", e);
                    this.plugins = new xr(this, e);
                    const n = this.config.get("language") || {};
                    this.locale = new Rr({
                        uiLanguage: typeof n === "string" ? n : n.ui,
                        contentLanguage: this.config.get("language.content")
                    });
                    this.t = this.locale.t;
                    this.editors = new yr;
                    this._contextOwner = null
                }
                initPlugins() {
                    const t = this.config.get("plugins") || [];
                    for (const e of t) {
                        if (typeof e != "function") {
                            throw new rr["b"]("context-initplugins-constructor-only: Only a constructor function is allowed as a context plugin.", null, {
                                Plugin: e
                            })
                        }
                        if (e.isContextPlugin !== true) {
                            throw new rr["b"]("context-initplugins-invalid-plugin: Only a plugin marked as a context plugin is allowed to be used with a context.", null, {
                                Plugin: e
                            })
                        }
                    }
                    return this.plugins.init(t)
                }
                destroy() {
                    return Promise.all(Array.from(this.editors, t => t.destroy())).then(() => this.plugins.destroy())
                }
                _addEditor(t, e) {
                    if (this._contextOwner) {
                        throw new rr["b"]("context-addEditor-private-context: Cannot add multiple editors to the context which is created by the editor.")
                    }
                    this.editors.add(t);
                    if (e) {
                        this._contextOwner = t
                    }
                }
                _removeEditor(t) {
                    if (this.editors.has(t)) {
                        this.editors.remove(t)
                    }
                    if (this._contextOwner === t) {
                        return this.destroy()
                    }
                    return Promise.resolve()
                }
                _getEditorConfig() {
                    const t = {};
                    for (const e of this.config.names()) {
                        if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
                            t[e] = this.config.get(e)
                        }
                    }
                    return t
                }
                static create(t) {
                    return new Promise(e => {
                        const n = new this(t);
                        e(n.initPlugins().then(() => n))
                    }
                    )
                }
            }
            function Nr(t, e) {
                const n = Math.min(t.length, e.length);
                for (let i = 0; i < n; i++) {
                    if (t[i] != e[i]) {
                        return i
                    }
                }
                if (t.length == e.length) {
                    return "same"
                } else if (t.length < e.length) {
                    return "prefix"
                } else {
                    return "extension"
                }
            }
            var Ir = 4;
            function Vr(t) {
                return Hs(t, Ir)
            }
            var Br = Vr;
            class Fr {
                constructor() {
                    this.parent = null
                }
                get index() {
                    let t;
                    if (!this.parent) {
                        return null
                    }
                    if ((t = this.parent.getChildIndex(this)) == -1) {
                        throw new rr["b"]("view-node-not-found-in-parent: The node's parent does not contain this node.", this)
                    }
                    return t
                }
                get nextSibling() {
                    const t = this.index;
                    return t !== null && this.parent.getChild(t + 1) || null
                }
                get previousSibling() {
                    const t = this.index;
                    return t !== null && this.parent.getChild(t - 1) || null
                }
                get root() {
                    let t = this;
                    while (t.parent) {
                        t = t.parent
                    }
                    return t
                }
                get document() {
                    if (this.parent instanceof Fr) {
                        return this.parent.document
                    } else {
                        return null
                    }
                }
                getPath() {
                    const t = [];
                    let e = this;
                    while (e.parent) {
                        t.unshift(e.index);
                        e = e.parent
                    }
                    return t
                }
                getAncestors(t = {
                    includeSelf: false,
                    parentFirst: false
                }) {
                    const e = [];
                    let n = t.includeSelf ? this : this.parent;
                    while (n) {
                        e[t.parentFirst ? "push" : "unshift"](n);
                        n = n.parent
                    }
                    return e
                }
                getCommonAncestor(t, e = {}) {
                    const n = this.getAncestors(e);
                    const i = t.getAncestors(e);
                    let o = 0;
                    while (n[o] == i[o] && n[o]) {
                        o++
                    }
                    return o === 0 ? null : n[o - 1]
                }
                isBefore(t) {
                    if (this == t) {
                        return false
                    }
                    if (this.root !== t.root) {
                        return false
                    }
                    const e = this.getPath();
                    const n = t.getPath();
                    const i = Nr(e, n);
                    switch (i) {
                        case "prefix":
                            return true;
                        case "extension":
                            return false;
                        default:
                            return e[i] < n[i]
                    }
                }
                isAfter(t) {
                    if (this == t) {
                        return false
                    }
                    if (this.root !== t.root) {
                        return false
                    }
                    return !this.isBefore(t)
                }
                _remove() {
                    this.parent._removeChildren(this.index)
                }
                _fireChange(t, e) {
                    this.fire("change:" + t, e);
                    if (this.parent) {
                        this.parent._fireChange(t, e)
                    }
                }
                toJSON() {
                    const t = Br(this);
                    delete t.parent;
                    return t
                }
                is(t) {
                    return t == "node" || t == "view:node"
                }
            }
            vr(Fr, dr);
            class Dr extends Fr {
                constructor(t) {
                    super();
                    this._textData = t
                }
                is(t) {
                    return t == "text" || t == "view:text" || super.is(t)
                }
                get data() {
                    return this._textData
                }
                get _data() {
                    return this.data
                }
                set _data(t) {
                    this._fireChange("text", this);
                    this._textData = t
                }
                isSimilar(t) {
                    if (!(t instanceof Dr)) {
                        return false
                    }
                    return this === t || this.data === t.data
                }
                _clone() {
                    return new Dr(this.data)
                }
            }
            class zr {
                constructor(t, e, n) {
                    this.textNode = t;
                    if (e < 0 || e > t.data.length) {
                        throw new rr["b"]("view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.", this)
                    }
                    if (n < 0 || e + n > t.data.length) {
                        throw new rr["b"]("view-textproxy-wrong-length: Given length value is incorrect.", this)
                    }
                    this.data = t.data.substring(e, e + n);
                    this.offsetInText = e
                }
                get offsetSize() {
                    return this.data.length
                }
                get isPartial() {
                    return this.data.length !== this.textNode.data.length
                }
                get parent() {
                    return this.textNode.parent
                }
                get root() {
                    return this.textNode.root
                }
                get document() {
                    return this.textNode.document
                }
                is(t) {
                    return t == "textProxy" || t == "view:textProxy"
                }
                getAncestors(t = {
                    includeSelf: false,
                    parentFirst: false
                }) {
                    const e = [];
                    let n = t.includeSelf ? this.textNode : this.parent;
                    while (n !== null) {
                        e[t.parentFirst ? "push" : "unshift"](n);
                        n = n.parent
                    }
                    return e
                }
            }
            function Lr(t) {
                const e = new Map;
                for (const n in t) {
                    e.set(n, t[n])
                }
                return e
            }
            function jr(t) {
                return !!(t && t[Symbol.iterator])
            }
            function Hr(t) {
                if (jr(t)) {
                    return new Map(t)
                } else {
                    return Lr(t)
                }
            }
            class qr {
                constructor(...t) {
                    this._patterns = [];
                    this.add(...t)
                }
                add(...t) {
                    for (let e of t) {
                        if (typeof e == "string" || e instanceof RegExp) {
                            e = {
                                name: e
                            }
                        }
                        if (e.classes && (typeof e.classes == "string" || e.classes instanceof RegExp)) {
                            e.classes = [e.classes]
                        }
                        this._patterns.push(e)
                    }
                }
                match(...t) {
                    for (const e of t) {
                        for (const t of this._patterns) {
                            const n = Wr(e, t);
                            if (n) {
                                return {
                                    element: e,
                                    pattern: t,
                                    match: n
                                }
                            }
                        }
                    }
                    return null
                }
                matchAll(...t) {
                    const e = [];
                    for (const n of t) {
                        for (const t of this._patterns) {
                            const i = Wr(n, t);
                            if (i) {
                                e.push({
                                    element: n,
                                    pattern: t,
                                    match: i
                                })
                            }
                        }
                    }
                    return e.length > 0 ? e : null
                }
                getElementName() {
                    if (this._patterns.length !== 1) {
                        return null
                    }
                    const t = this._patterns[0];
                    const e = t.name;
                    return typeof t != "function" && e && !(e instanceof RegExp) ? e : null
                }
            }
            function Wr(t, e) {
                if (typeof e == "function") {
                    return e(t)
                }
                const n = {};
                if (e.name) {
                    n.name = Ur(e.name, t.name);
                    if (!n.name) {
                        return null
                    }
                }
                if (e.attributes) {
                    n.attributes = $r(e.attributes, t);
                    if (!n.attributes) {
                        return null
                    }
                }
                if (e.classes) {
                    n.classes = Gr(e.classes, t);
                    if (!n.classes) {
                        return false
                    }
                }
                if (e.styles) {
                    n.styles = Kr(e.styles, t);
                    if (!n.styles) {
                        return false
                    }
                }
                return n
            }
            function Ur(t, e) {
                if (t instanceof RegExp) {
                    return t.test(e)
                }
                return t === e
            }
            function $r(t, e) {
                const n = [];
                for (const i in t) {
                    const o = t[i];
                    if (e.hasAttribute(i)) {
                        const t = e.getAttribute(i);
                        if (o === true) {
                            n.push(i)
                        } else if (o instanceof RegExp) {
                            if (o.test(t)) {
                                n.push(i)
                            } else {
                                return null
                            }
                        } else if (t === o) {
                            n.push(i)
                        } else {
                            return null
                        }
                    } else {
                        return null
                    }
                }
                return n
            }
            function Gr(t, e) {
                const n = [];
                for (const i of t) {
                    if (i instanceof RegExp) {
                        const t = e.getClassNames();
                        for (const e of t) {
                            if (i.test(e)) {
                                n.push(e)
                            }
                        }
                        if (n.length === 0) {
                            return null
                        }
                    } else if (e.hasClass(i)) {
                        n.push(i)
                    } else {
                        return null
                    }
                }
                return n
            }
            function Kr(t, e) {
                const n = [];
                for (const i in t) {
                    const o = t[i];
                    if (e.hasStyle(i)) {
                        const t = e.getStyle(i);
                        if (o instanceof RegExp) {
                            if (o.test(t)) {
                                n.push(i)
                            } else {
                                return null
                            }
                        } else if (t === o) {
                            n.push(i)
                        } else {
                            return null
                        }
                    } else {
                        return null
                    }
                }
                return n
            }
            var Jr = "[object Symbol]";
            function Qr(t) {
                return typeof t == "symbol" || P(t) && _(t) == Jr
            }
            var Yr = Qr;
            var Xr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
                , Zr = /^\w*$/;
            function ta(t, e) {
                if (Je(t)) {
                    return false
                }
                var n = typeof t;
                if (n == "number" || n == "symbol" || n == "boolean" || t == null || Yr(t)) {
                    return true
                }
                return Zr.test(t) || !Xr.test(t) || e != null && t in Object(e)
            }
            var ea = ta;
            var na = "Expected a function";
            function ia(t, e) {
                if (typeof t != "function" || e != null && typeof e != "function") {
                    throw new TypeError(na)
                }
                var n = function () {
                    var i = arguments
                        , o = e ? e.apply(this, i) : i[0]
                        , s = n.cache;
                    if (s.has(o)) {
                        return s.get(o)
                    }
                    var r = t.apply(this, i);
                    n.cache = s.set(o, r) || s;
                    return r
                };
                n.cache = new (ia.Cache || _e);
                return n
            }
            ia.Cache = _e;
            var oa = ia;
            var sa = 500;
            function ra(t) {
                var e = oa(t, (function (t) {
                    if (n.size === sa) {
                        n.clear()
                    }
                    return t
                }
                ));
                var n = e.cache;
                return e
            }
            var aa = ra;
            var ca = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var la = /\\(\\)?/g;
            var da = aa((function (t) {
                var e = [];
                if (t.charCodeAt(0) === 46) {
                    e.push("")
                }
                t.replace(ca, (function (t, n, i, o) {
                    e.push(i ? o.replace(la, "$1") : n || t)
                }
                ));
                return e
            }
            ));
            var ua = da;
            function ha(t, e) {
                var n = -1
                    , i = t == null ? 0 : t.length
                    , o = Array(i);
                while (++n < i) {
                    o[n] = e(t[n], n, t)
                }
                return o
            }
            var fa = ha;
            var pa = 1 / 0;
            var ga = s ? s.prototype : undefined
                , ma = ga ? ga.toString : undefined;
            function ba(t) {
                if (typeof t == "string") {
                    return t
                }
                if (Je(t)) {
                    return fa(t, ba) + ""
                }
                if (Yr(t)) {
                    return ma ? ma.call(t) : ""
                }
                var e = t + "";
                return e == "0" && 1 / t == -pa ? "-0" : e
            }
            var wa = ba;
            function ka(t) {
                return t == null ? "" : wa(t)
            }
            var _a = ka;
            function va(t, e) {
                if (Je(t)) {
                    return t
                }
                return ea(t, e) ? [t] : ua(_a(t))
            }
            var ya = va;
            function xa(t) {
                var e = t == null ? 0 : t.length;
                return e ? t[e - 1] : undefined
            }
            var Ca = xa;
            var Aa = 1 / 0;
            function Pa(t) {
                if (typeof t == "string" || Yr(t)) {
                    return t
                }
                var e = t + "";
                return e == "0" && 1 / t == -Aa ? "-0" : e
            }
            var Ta = Pa;
            function Sa(t, e) {
                e = ya(e, t);
                var n = 0
                    , i = e.length;
                while (t != null && n < i) {
                    t = t[Ta(e[n++])]
                }
                return n && n == i ? t : undefined
            }
            var Ea = Sa;
            function Ra(t, e, n) {
                var i = -1
                    , o = t.length;
                if (e < 0) {
                    e = -e > o ? 0 : o + e
                }
                n = n > o ? o : n;
                if (n < 0) {
                    n += o
                }
                o = e > n ? 0 : n - e >>> 0;
                e >>>= 0;
                var s = Array(o);
                while (++i < o) {
                    s[i] = t[i + e]
                }
                return s
            }
            var Oa = Ra;
            function Ma(t, e) {
                return e.length < 2 ? t : Ea(t, Oa(e, 0, -1))
            }
            var Na = Ma;
            function Ia(t, e) {
                e = ya(e, t);
                t = Na(t, e);
                return t == null || delete t[Ta(Ca(e))]
            }
            var Va = Ia;
            function Ba(t, e) {
                return t == null ? true : Va(t, e)
            }
            var Fa = Ba;
            function Da(t, e, n) {
                var i = t == null ? undefined : Ea(t, e);
                return i === undefined ? n : i
            }
            var za = Da;
            function La(t, e, n) {
                if (n !== undefined && !D(t[e], n) || n === undefined && !(e in t)) {
                    Oe(t, e, n)
                }
            }
            var ja = La;
            function Ha(t) {
                return function (e, n, i) {
                    var o = -1
                        , s = Object(e)
                        , r = i(e)
                        , a = r.length;
                    while (a--) {
                        var c = r[t ? a : ++o];
                        if (n(s[c], c, s) === false) {
                            break
                        }
                    }
                    return e
                }
            }
            var qa = Ha;
            var Wa = qa();
            var Ua = Wa;
            function $a(t) {
                return P(t) && Xn(t)
            }
            var Ga = $a;
            function Ka(t, e) {
                if (e === "constructor" && typeof t[e] === "function") {
                    return
                }
                if (e == "__proto__") {
                    return
                }
                return t[e]
            }
            var Ja = Ka;
            function Qa(t) {
                return Fe(t, di(t))
            }
            var Ya = Qa;
            function Xa(t, e, n, i, o, s, r) {
                var a = Ja(t, n)
                    , c = Ja(e, n)
                    , l = r.get(c);
                if (l) {
                    ja(t, n, l);
                    return
                }
                var d = s ? s(a, c, n + "", t, e, r) : undefined;
                var u = d === undefined;
                if (u) {
                    var h = Je(c)
                        , f = !h && Object(Qe["a"])(c)
                        , p = !h && !f && Fn(c);
                    d = c;
                    if (h || f || p) {
                        if (Je(a)) {
                            d = a
                        } else if (Ga(a)) {
                            d = gi(a)
                        } else if (f) {
                            u = false;
                            d = Object(fi["a"])(c, true)
                        } else if (p) {
                            u = false;
                            d = Po(c, true)
                        } else {
                            d = []
                        }
                    } else if (I(c) || Ge(c)) {
                        d = a;
                        if (Ge(a)) {
                            d = Ya(a)
                        } else if (!ct(a) || pt(a)) {
                            d = Xo(c)
                        }
                    } else {
                        u = false
                    }
                }
                if (u) {
                    r.set(c, d);
                    o(d, c, i, s, r);
                    r["delete"](c)
                }
                ja(t, n, d)
            }
            var Za = Xa;
            function tc(t, e, n, i, o) {
                if (t === e) {
                    return
                }
                Ua(e, (function (s, r) {
                    o || (o = new Ae);
                    if (ct(s)) {
                        Za(t, e, r, n, tc, i, o)
                    } else {
                        var a = i ? i(Ja(t, r), s, r + "", t, e, o) : undefined;
                        if (a === undefined) {
                            a = s
                        }
                        ja(t, r, a)
                    }
                }
                ), di)
            }
            var ec = tc;
            function nc(t) {
                return t
            }
            var ic = nc;
            function oc(t, e, n) {
                switch (n.length) {
                    case 0:
                        return t.call(e);
                    case 1:
                        return t.call(e, n[0]);
                    case 2:
                        return t.call(e, n[0], n[1]);
                    case 3:
                        return t.call(e, n[0], n[1], n[2])
                }
                return t.apply(e, n)
            }
            var sc = oc;
            var rc = Math.max;
            function ac(t, e, n) {
                e = rc(e === undefined ? t.length - 1 : e, 0);
                return function () {
                    var i = arguments
                        , o = -1
                        , s = rc(i.length - e, 0)
                        , r = Array(s);
                    while (++o < s) {
                        r[o] = i[e + o]
                    }
                    o = -1;
                    var a = Array(e + 1);
                    while (++o < e) {
                        a[o] = i[o]
                    }
                    a[e] = n(r);
                    return sc(t, this, a)
                }
            }
            var cc = ac;
            function lc(t) {
                return function () {
                    return t
                }
            }
            var dc = lc;
            var uc = !Ee ? ic : function (t, e) {
                return Ee(t, "toString", {
                    configurable: true,
                    enumerable: false,
                    value: dc(e),
                    writable: true
                })
            }
                ;
            var hc = uc;
            var fc = 800
                , pc = 16;
            var gc = Date.now;
            function mc(t) {
                var e = 0
                    , n = 0;
                return function () {
                    var i = gc()
                        , o = pc - (i - n);
                    n = i;
                    if (o > 0) {
                        if (++e >= fc) {
                            return arguments[0]
                        }
                    } else {
                        e = 0
                    }
                    return t.apply(undefined, arguments)
                }
            }
            var bc = mc;
            var wc = bc(hc);
            var kc = wc;
            function _c(t, e) {
                return kc(cc(t, e, ic), t + "")
            }
            var vc = _c;
            function yc(t, e, n) {
                if (!ct(n)) {
                    return false
                }
                var i = typeof e;
                if (i == "number" ? Xn(n) && tn(e, n.length) : i == "string" && e in n) {
                    return D(n[e], t)
                }
                return false
            }
            var xc = yc;
            function Cc(t) {
                return vc((function (e, n) {
                    var i = -1
                        , o = n.length
                        , s = o > 1 ? n[o - 1] : undefined
                        , r = o > 2 ? n[2] : undefined;
                    s = t.length > 3 && typeof s == "function" ? (o--,
                        s) : undefined;
                    if (r && xc(n[0], n[1], r)) {
                        s = o < 3 ? undefined : s;
                        o = 1
                    }
                    e = Object(e);
                    while (++i < o) {
                        var a = n[i];
                        if (a) {
                            t(e, a, i, s)
                        }
                    }
                    return e
                }
                ))
            }
            var Ac = Cc;
            var Pc = Ac((function (t, e, n) {
                ec(t, e, n)
            }
            ));
            var Tc = Pc;
            function Sc(t, e, n, i) {
                if (!ct(t)) {
                    return t
                }
                e = ya(e, t);
                var o = -1
                    , s = e.length
                    , r = s - 1
                    , a = t;
                while (a != null && ++o < s) {
                    var c = Ta(e[o])
                        , l = n;
                    if (o != r) {
                        var d = a[c];
                        l = i ? i(d, c, a) : undefined;
                        if (l === undefined) {
                            l = ct(d) ? d : tn(e[o + 1]) ? [] : {}
                        }
                    }
                    Ve(a, c, l);
                    a = a[c]
                }
                return t
            }
            var Ec = Sc;
            function Rc(t, e, n) {
                return t == null ? t : Ec(t, e, n)
            }
            var Oc = Rc;
            class Mc {
                constructor() {
                    this._styles = {};
                    Object.defineProperty(this, "_styleProcessor", {
                        get() {
                            return Mc._styleProcessor
                        },
                        enumerable: false
                    })
                }
                get isEmpty() {
                    const t = Object.entries(this._styles);
                    const e = Array.from(t);
                    return !e.length
                }
                get size() {
                    if (this.isEmpty) {
                        return 0
                    }
                    return this.getStyleNames().length
                }
                setTo(t) {
                    this.clear();
                    const e = Array.from(Ic(t).entries());
                    for (const [t, n] of e) {
                        this._styleProcessor.toNormalizedForm(t, n, this._styles)
                    }
                }
                has(t) {
                    if (this.isEmpty) {
                        return false
                    }
                    const e = this._styleProcessor.getReducedForm(t, this._styles);
                    const n = e.find(([e]) => e === t);
                    return Array.isArray(n)
                }
                set(t, e) {
                    if (ct(t)) {
                        for (const [e, n] of Object.entries(t)) {
                            this._styleProcessor.toNormalizedForm(e, n, this._styles)
                        }
                    } else {
                        this._styleProcessor.toNormalizedForm(t, e, this._styles)
                    }
                }
                remove(t) {
                    const e = Vc(t);
                    Fa(this._styles, e);
                    delete this._styles[t];
                    this._cleanEmptyObjectsOnPath(e)
                }
                getNormalized(t) {
                    return this._styleProcessor.getNormalized(t, this._styles)
                }
                toString() {
                    if (this.isEmpty) {
                        return ""
                    }
                    return this._getStylesEntries().map(t => t.join(":")).sort().join(";") + ";"
                }
                getAsString(t) {
                    if (this.isEmpty) {
                        return
                    }
                    if (this._styles[t] && !ct(this._styles[t])) {
                        return this._styles[t]
                    }
                    const e = this._styleProcessor.getReducedForm(t, this._styles);
                    const n = e.find(([e]) => e === t);
                    if (Array.isArray(n)) {
                        return n[1]
                    }
                }
                getStyleNames() {
                    if (this.isEmpty) {
                        return []
                    }
                    const t = this._getStylesEntries();
                    return t.map(([t]) => t)
                }
                clear() {
                    this._styles = {}
                }
                static getRelatedStyles(t) {
                    return this._styleProcessor.getRelatedStyles(t)
                }
                _getStylesEntries() {
                    const t = [];
                    const e = Object.keys(this._styles);
                    for (const n of e) {
                        t.push(...this._styleProcessor.getReducedForm(n, this._styles))
                    }
                    return t
                }
                _cleanEmptyObjectsOnPath(t) {
                    const e = t.split(".");
                    const n = e.length > 1;
                    if (!n) {
                        return
                    }
                    const i = e.splice(0, e.length - 1).join(".");
                    const o = za(this._styles, i);
                    if (!o) {
                        return
                    }
                    const s = !Array.from(Object.keys(o)).length;
                    if (s) {
                        this.remove(i)
                    }
                }
                static get _styleProcessor() {
                    if (!this._processor) {
                        this._processor = new Nc
                    }
                    return this._processor
                }
                static _setProcessor(t) {
                    this._processor = t
                }
            }
            class Nc {
                constructor() {
                    this._normalizers = new Map;
                    this._extractors = new Map;
                    this._reducers = new Map;
                    this._consumables = new Map
                }
                toNormalizedForm(t, e, n) {
                    if (ct(e)) {
                        Bc(n, Vc(t), e);
                        return
                    }
                    if (this._normalizers.has(t)) {
                        const i = this._normalizers.get(t);
                        const { path: o, value: s } = i(e);
                        Bc(n, o, s)
                    } else {
                        Bc(n, t, e)
                    }
                }
                getNormalized(t, e) {
                    if (!t) {
                        return Tc({}, e)
                    }
                    if (e[t] !== undefined) {
                        return e[t]
                    }
                    if (this._extractors.has(t)) {
                        const n = this._extractors.get(t);
                        if (typeof n === "string") {
                            return za(e, n)
                        }
                        const i = n(t, e);
                        if (i) {
                            return i
                        }
                    }
                    return za(e, Vc(t))
                }
                getReducedForm(t, e) {
                    const n = this.getNormalized(t, e);
                    if (n === undefined) {
                        return []
                    }
                    if (this._reducers.has(t)) {
                        const e = this._reducers.get(t);
                        return e(n)
                    }
                    return [[t, n]]
                }
                getRelatedStyles(t) {
                    return this._consumables.get(t) || []
                }
                setNormalizer(t, e) {
                    this._normalizers.set(t, e)
                }
                setExtractor(t, e) {
                    this._extractors.set(t, e)
                }
                setReducer(t, e) {
                    this._reducers.set(t, e)
                }
                setStyleRelation(t, e) {
                    this._mapStyleNames(t, e);
                    for (const n of e) {
                        this._mapStyleNames(n, [t])
                    }
                }
                _mapStyleNames(t, e) {
                    if (!this._consumables.has(t)) {
                        this._consumables.set(t, [])
                    }
                    this._consumables.get(t).push(...e)
                }
            }
            function Ic(t) {
                let e = null;
                let n = 0;
                let i = 0;
                let o = null;
                const s = new Map;
                if (t === "") {
                    return s
                }
                if (t.charAt(t.length - 1) != ";") {
                    t = t + ";"
                }
                for (let r = 0; r < t.length; r++) {
                    const a = t.charAt(r);
                    if (e === null) {
                        switch (a) {
                            case ":":
                                if (!o) {
                                    o = t.substr(n, r - n);
                                    i = r + 1
                                }
                                break;
                            case '"':
                            case "'":
                                e = a;
                                break;
                            case ";":
                                {
                                    const e = t.substr(i, r - i);
                                    if (o) {
                                        s.set(o.trim(), e.trim())
                                    }
                                    o = null;
                                    n = r + 1;
                                    break
                                }
                        }
                    } else if (a === e) {
                        e = null
                    }
                }
                return s
            }
            function Vc(t) {
                return t.replace("-", ".")
            }
            function Bc(t, e, n) {
                let i = n;
                if (ct(n)) {
                    i = Tc({}, za(t, e), n)
                }
                Oc(t, e, i)
            }
            class Fc extends Fr {
                constructor(t, e, n) {
                    super();
                    this.name = t;
                    this._attrs = Dc(e);
                    this._children = [];
                    if (n) {
                        this._insertChild(0, n)
                    }
                    this._classes = new Set;
                    if (this._attrs.has("class")) {
                        const t = this._attrs.get("class");
                        zc(this._classes, t);
                        this._attrs.delete("class")
                    }
                    this._styles = new Mc;
                    if (this._attrs.has("style")) {
                        this._styles.setTo(this._attrs.get("style"));
                        this._attrs.delete("style")
                    }
                    this._customProperties = new Map
                }
                get childCount() {
                    return this._children.length
                }
                get isEmpty() {
                    return this._children.length === 0
                }
                is(t, e = null) {
                    const n = t.replace(/^view:/, "");
                    if (!e) {
                        return n == "element" || n == this.name || super.is(t)
                    } else {
                        return n == "element" && e == this.name
                    }
                }
                getChild(t) {
                    return this._children[t]
                }
                getChildIndex(t) {
                    return this._children.indexOf(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                *getAttributeKeys() {
                    if (this._classes.size > 0) {
                        yield "class"
                    }
                    if (!this._styles.isEmpty) {
                        yield "style"
                    }
                    yield* this._attrs.keys()
                }
                *getAttributes() {
                    yield* this._attrs.entries();
                    if (this._classes.size > 0) {
                        yield ["class", this.getAttribute("class")]
                    }
                    if (!this._styles.isEmpty) {
                        yield ["style", this.getAttribute("style")]
                    }
                }
                getAttribute(t) {
                    if (t == "class") {
                        if (this._classes.size > 0) {
                            return [...this._classes].join(" ")
                        }
                        return undefined
                    }
                    if (t == "style") {
                        const t = this._styles.toString();
                        return t == "" ? undefined : t
                    }
                    return this._attrs.get(t)
                }
                hasAttribute(t) {
                    if (t == "class") {
                        return this._classes.size > 0
                    }
                    if (t == "style") {
                        return !this._styles.isEmpty
                    }
                    return this._attrs.has(t)
                }
                isSimilar(t) {
                    if (!(t instanceof Fc)) {
                        return false
                    }
                    if (this === t) {
                        return true
                    }
                    if (this.name != t.name) {
                        return false
                    }
                    if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) {
                        return false
                    }
                    for (const [e, n] of this._attrs) {
                        if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
                            return false
                        }
                    }
                    for (const e of this._classes) {
                        if (!t._classes.has(e)) {
                            return false
                        }
                    }
                    for (const e of this._styles.getStyleNames()) {
                        if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) {
                            return false
                        }
                    }
                    return true
                }
                hasClass(...t) {
                    for (const e of t) {
                        if (!this._classes.has(e)) {
                            return false
                        }
                    }
                    return true
                }
                getClassNames() {
                    return this._classes.keys()
                }
                getStyle(t) {
                    return this._styles.getAsString(t)
                }
                getNormalizedStyle(t) {
                    return this._styles.getNormalized(t)
                }
                getStyleNames() {
                    return this._styles.getStyleNames()
                }
                hasStyle(...t) {
                    for (const e of t) {
                        if (!this._styles.has(e)) {
                            return false
                        }
                    }
                    return true
                }
                findAncestor(...t) {
                    const e = new qr(...t);
                    let n = this.parent;
                    while (n) {
                        if (e.match(n)) {
                            return n
                        }
                        n = n.parent
                    }
                    return null
                }
                getCustomProperty(t) {
                    return this._customProperties.get(t)
                }
                *getCustomProperties() {
                    yield* this._customProperties.entries()
                }
                getIdentity() {
                    const t = Array.from(this._classes).sort().join(",");
                    const e = this._styles.toString();
                    const n = Array.from(this._attrs).map(t => `${t[0]}="${t[1]}"`).sort().join(" ");
                    return this.name + (t == "" ? "" : ` class="${t}"`) + (!e ? "" : ` style="${e}"`) + (n == "" ? "" : ` ${n}`)
                }
                _clone(t = false) {
                    const e = [];
                    if (t) {
                        for (const n of this.getChildren()) {
                            e.push(n._clone(t))
                        }
                    }
                    const n = new this.constructor(this.name, this._attrs, e);
                    n._classes = new Set(this._classes);
                    n._styles.set(this._styles.getNormalized());
                    n._customProperties = new Map(this._customProperties);
                    n.getFillerOffset = this.getFillerOffset;
                    return n
                }
                _appendChild(t) {
                    return this._insertChild(this.childCount, t)
                }
                _insertChild(t, e) {
                    this._fireChange("children", this);
                    let n = 0;
                    const i = Lc(e);
                    for (const e of i) {
                        if (e.parent !== null) {
                            e._remove()
                        }
                        e.parent = this;
                        this._children.splice(t, 0, e);
                        t++;
                        n++
                    }
                    return n
                }
                _removeChildren(t, e = 1) {
                    this._fireChange("children", this);
                    for (let n = t; n < t + e; n++) {
                        this._children[n].parent = null
                    }
                    return this._children.splice(t, e)
                }
                _setAttribute(t, e) {
                    e = String(e);
                    this._fireChange("attributes", this);
                    if (t == "class") {
                        zc(this._classes, e)
                    } else if (t == "style") {
                        this._styles.setTo(e)
                    } else {
                        this._attrs.set(t, e)
                    }
                }
                _removeAttribute(t) {
                    this._fireChange("attributes", this);
                    if (t == "class") {
                        if (this._classes.size > 0) {
                            this._classes.clear();
                            return true
                        }
                        return false
                    }
                    if (t == "style") {
                        if (!this._styles.isEmpty) {
                            this._styles.clear();
                            return true
                        }
                        return false
                    }
                    return this._attrs.delete(t)
                }
                _addClass(t) {
                    this._fireChange("attributes", this);
                    t = Array.isArray(t) ? t : [t];
                    t.forEach(t => this._classes.add(t))
                }
                _removeClass(t) {
                    this._fireChange("attributes", this);
                    t = Array.isArray(t) ? t : [t];
                    t.forEach(t => this._classes.delete(t))
                }
                _setStyle(t, e) {
                    this._fireChange("attributes", this);
                    this._styles.set(t, e)
                }
                _removeStyle(t) {
                    this._fireChange("attributes", this);
                    t = Array.isArray(t) ? t : [t];
                    t.forEach(t => this._styles.remove(t))
                }
                _setCustomProperty(t, e) {
                    this._customProperties.set(t, e)
                }
                _removeCustomProperty(t) {
                    return this._customProperties.delete(t)
                }
            }
            function Dc(t) {
                t = Hr(t);
                for (const [e, n] of t) {
                    if (n === null) {
                        t.delete(e)
                    } else if (typeof n != "string") {
                        t.set(e, String(n))
                    }
                }
                return t
            }
            function zc(t, e) {
                const n = e.split(/\s+/);
                t.clear();
                n.forEach(e => t.add(e))
            }
            function Lc(t) {
                if (typeof t == "string") {
                    return [new Dr(t)]
                }
                if (!jr(t)) {
                    t = [t]
                }
                return Array.from(t).map(t => {
                    if (typeof t == "string") {
                        return new Dr(t)
                    }
                    if (t instanceof zr) {
                        return new Dr(t.data)
                    }
                    return t
                }
                )
            }
            class jc extends Fc {
                constructor(t, e, n) {
                    super(t, e, n);
                    this.getFillerOffset = Hc
                }
                is(t, e = null) {
                    const n = t && t.replace(/^view:/, "");
                    if (!e) {
                        return n == "containerElement" || super.is(t)
                    } else {
                        return n == "containerElement" && e == this.name || super.is(t, e)
                    }
                }
            }
            function Hc() {
                const t = [...this.getChildren()];
                const e = t[this.childCount - 1];
                if (e && e.is("element", "br")) {
                    return this.childCount
                }
                for (const e of t) {
                    if (!e.is("uiElement")) {
                        return null
                    }
                }
                return this.childCount
            }
            var qc = Ac((function (t, e) {
                Fe(e, di(e), t)
            }
            ));
            var Wc = qc;
            const Uc = Symbol("observableProperties");
            const $c = Symbol("boundObservables");
            const Gc = Symbol("boundProperties");
            const Kc = {
                set(t, e) {
                    if (ct(t)) {
                        Object.keys(t).forEach(e => {
                            this.set(e, t[e])
                        }
                            , this);
                        return
                    }
                    Qc(this);
                    const n = this[Uc];
                    if (t in this && !n.has(t)) {
                        throw new rr["b"]("observable-set-cannot-override: Cannot override an existing property.", this)
                    }
                    Object.defineProperty(this, t, {
                        enumerable: true,
                        configurable: true,
                        get() {
                            return n.get(t)
                        },
                        set(e) {
                            const i = n.get(t);
                            let o = this.fire("set:" + t, t, e, i);
                            if (o === undefined) {
                                o = e
                            }
                            if (i !== o || !n.has(t)) {
                                n.set(t, o);
                                this.fire("change:" + t, t, o, i)
                            }
                        }
                    });
                    this[t] = e
                },
                bind(...t) {
                    if (!t.length || !tl(t)) {
                        throw new rr["b"]("observable-bind-wrong-properties: All properties must be strings.", this)
                    }
                    if (new Set(t).size !== t.length) {
                        throw new rr["b"]("observable-bind-duplicate-properties: Properties must be unique.", this)
                    }
                    Qc(this);
                    const e = this[Gc];
                    t.forEach(t => {
                        if (e.has(t)) {
                            throw new rr["b"]("observable-bind-rebind: Cannot bind the same property more than once.", this)
                        }
                    }
                    );
                    const n = new Map;
                    t.forEach(t => {
                        const i = {
                            property: t,
                            to: []
                        };
                        e.set(t, i);
                        n.set(t, i)
                    }
                    );
                    return {
                        to: Yc,
                        toMany: Xc,
                        _observable: this,
                        _bindProperties: t,
                        _to: [],
                        _bindings: n
                    }
                },
                unbind(...t) {
                    if (!(Uc in this)) {
                        return
                    }
                    const e = this[Gc];
                    const n = this[$c];
                    if (t.length) {
                        if (!tl(t)) {
                            throw new rr["b"]("observable-unbind-wrong-properties: Properties must be strings.", this)
                        }
                        t.forEach(t => {
                            const i = e.get(t);
                            if (!i) {
                                return
                            }
                            let o, s, r, a;
                            i.to.forEach(t => {
                                o = t[0];
                                s = t[1];
                                r = n.get(o);
                                a = r[s];
                                a.delete(i);
                                if (!a.size) {
                                    delete r[s]
                                }
                                if (!Object.keys(r).length) {
                                    n.delete(o);
                                    this.stopListening(o, "change")
                                }
                            }
                            );
                            e.delete(t)
                        }
                        )
                    } else {
                        n.forEach((t, e) => {
                            this.stopListening(e, "change")
                        }
                        );
                        n.clear();
                        e.clear()
                    }
                },
                decorate(t) {
                    const e = this[t];
                    if (!e) {
                        throw new rr["b"]("observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.", this, {
                            object: this,
                            methodName: t
                        })
                    }
                    this.on(t, (t, n) => {
                        t.return = e.apply(this, n)
                    }
                    );
                    this[t] = function (...e) {
                        return this.fire(t, e)
                    }
                }
            };
            Wc(Kc, dr);
            var Jc = Kc;
            function Qc(t) {
                if (Uc in t) {
                    return
                }
                Object.defineProperty(t, Uc, {
                    value: new Map
                });
                Object.defineProperty(t, $c, {
                    value: new Map
                });
                Object.defineProperty(t, Gc, {
                    value: new Map
                })
            }
            function Yc(...t) {
                const e = el(...t);
                const n = Array.from(this._bindings.keys());
                const i = n.length;
                if (!e.callback && e.to.length > 1) {
                    throw new rr["b"]("observable-bind-to-no-callback: Binding multiple observables only possible with callback.", this)
                }
                if (i > 1 && e.callback) {
                    throw new rr["b"]("observable-bind-to-extra-callback: Cannot bind multiple properties and use a callback in one binding.", this)
                }
                e.to.forEach(t => {
                    if (t.properties.length && t.properties.length !== i) {
                        throw new rr["b"]("observable-bind-to-properties-length: The number of properties must match.", this)
                    }
                    if (!t.properties.length) {
                        t.properties = this._bindProperties
                    }
                }
                );
                this._to = e.to;
                if (e.callback) {
                    this._bindings.get(n[0]).callback = e.callback
                }
                sl(this._observable, this._to);
                il(this);
                this._bindProperties.forEach(t => {
                    ol(this._observable, t)
                }
                )
            }
            function Xc(t, e, n) {
                if (this._bindings.size > 1) {
                    throw new rr["b"]("observable-bind-to-many-not-one-binding: Cannot bind multiple properties with toMany().", this)
                }
                this.to(...Zc(t, e), n)
            }
            function Zc(t, e) {
                const n = t.map(t => [t, e]);
                return Array.prototype.concat.apply([], n)
            }
            function tl(t) {
                return t.every(t => typeof t == "string")
            }
            function el(...t) {
                if (!t.length) {
                    throw new rr["b"]("observable-bind-to-parse-error: Invalid argument syntax in `to()`.", null)
                }
                const e = {
                    to: []
                };
                let n;
                if (typeof t[t.length - 1] == "function") {
                    e.callback = t.pop()
                }
                t.forEach(t => {
                    if (typeof t == "string") {
                        n.properties.push(t)
                    } else if (typeof t == "object") {
                        n = {
                            observable: t,
                            properties: []
                        };
                        e.to.push(n)
                    } else {
                        throw new rr["b"]("observable-bind-to-parse-error: Invalid argument syntax in `to()`.", null)
                    }
                }
                );
                return e
            }
            function nl(t, e, n, i) {
                const o = t[$c];
                const s = o.get(n);
                const r = s || {};
                if (!r[i]) {
                    r[i] = new Set
                }
                r[i].add(e);
                if (!s) {
                    o.set(n, r)
                }
            }
            function il(t) {
                let e;
                t._bindings.forEach((n, i) => {
                    t._to.forEach(o => {
                        e = o.properties[n.callback ? 0 : t._bindProperties.indexOf(i)];
                        n.to.push([o.observable, e]);
                        nl(t._observable, n, o.observable, e)
                    }
                    )
                }
                )
            }
            function ol(t, e) {
                const n = t[Gc];
                const i = n.get(e);
                let o;
                if (i.callback) {
                    o = i.callback.apply(t, i.to.map(t => t[0][t[1]]))
                } else {
                    o = i.to[0];
                    o = o[0][o[1]]
                }
                if (t.hasOwnProperty(e)) {
                    t[e] = o
                } else {
                    t.set(e, o)
                }
            }
            function sl(t, e) {
                e.forEach(e => {
                    const n = t[$c];
                    let i;
                    if (!n.get(e.observable)) {
                        t.listenTo(e.observable, "change", (o, s) => {
                            i = n.get(e.observable)[s];
                            if (i) {
                                i.forEach(e => {
                                    ol(t, e.property)
                                }
                                )
                            }
                        }
                        )
                    }
                }
                )
            }
            const rl = Symbol("document");
            class al extends jc {
                constructor(t, e, n) {
                    super(t, e, n);
                    this.set("isReadOnly", false);
                    this.set("isFocused", false)
                }
                is(t, e = null) {
                    const n = t && t.replace(/^view:/, "");
                    if (!e) {
                        return n == "editableElement" || super.is(t)
                    } else {
                        return n == "editableElement" && e == this.name || super.is(t, e)
                    }
                }
                destroy() {
                    this.stopListening()
                }
                get document() {
                    return this.getCustomProperty(rl)
                }
                set _document(t) {
                    if (this.getCustomProperty(rl)) {
                        throw new rr["b"]("view-editableelement-document-already-set: View document is already set.", this)
                    }
                    this._setCustomProperty(rl, t);
                    this.bind("isReadOnly").to(t);
                    this.bind("isFocused").to(t, "isFocused", e => e && t.selection.editableElement == this);
                    this.listenTo(t.selection, "change", () => {
                        this.isFocused = t.isFocused && t.selection.editableElement == this
                    }
                    )
                }
            }
            vr(al, Jc);
            const cl = Symbol("rootName");
            class ll extends al {
                constructor(t) {
                    super(t);
                    this.rootName = "main"
                }
                is(t, e = null) {
                    const n = t.replace(/^view:/, "");
                    if (!e) {
                        return n == "rootElement" || super.is(t)
                    } else {
                        return n == "rootElement" && e == this.name || super.is(t, e)
                    }
                }
                get rootName() {
                    return this.getCustomProperty(cl)
                }
                set rootName(t) {
                    this._setCustomProperty(cl, t)
                }
                set _name(t) {
                    this.name = t
                }
            }
            class dl {
                constructor(t = {}) {
                    if (!t.boundaries && !t.startPosition) {
                        throw new rr["b"]("view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.", null)
                    }
                    if (t.direction && t.direction != "forward" && t.direction != "backward") {
                        throw new rr["b"]("view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.", t.startPosition, {
                            direction: t.direction
                        })
                    }
                    this.boundaries = t.boundaries || null;
                    if (t.startPosition) {
                        this.position = ul._createAt(t.startPosition)
                    } else {
                        this.position = ul._createAt(t.boundaries[t.direction == "backward" ? "end" : "start"])
                    }
                    this.direction = t.direction || "forward";
                    this.singleCharacters = !!t.singleCharacters;
                    this.shallow = !!t.shallow;
                    this.ignoreElementEnd = !!t.ignoreElementEnd;
                    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
                }
                [Symbol.iterator]() {
                    return this
                }
                skip(t) {
                    let e, n, i;
                    do {
                        i = this.position;
                        ({ done: e, value: n } = this.next())
                    } while (!e && t(n)); if (!e) {
                        this.position = i
                    }
                }
                next() {
                    if (this.direction == "forward") {
                        return this._next()
                    } else {
                        return this._previous()
                    }
                }
                _next() {
                    let t = this.position.clone();
                    const e = this.position;
                    const n = t.parent;
                    if (n.parent === null && t.offset === n.childCount) {
                        return {
                            done: true
                        }
                    }
                    if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) {
                        return {
                            done: true
                        }
                    }
                    let i;
                    if (n instanceof Dr) {
                        if (t.isAtEnd) {
                            this.position = ul._createAfter(n);
                            return this._next()
                        }
                        i = n.data[t.offset]
                    } else {
                        i = n.getChild(t.offset)
                    }
                    if (i instanceof Fc) {
                        if (!this.shallow) {
                            t = new ul(i, 0)
                        } else {
                            t.offset++
                        }
                        this.position = t;
                        return this._formatReturnValue("elementStart", i, e, t, 1)
                    } else if (i instanceof Dr) {
                        if (this.singleCharacters) {
                            t = new ul(i, 0);
                            this.position = t;
                            return this._next()
                        } else {
                            let n = i.data.length;
                            let o;
                            if (i == this._boundaryEndParent) {
                                n = this.boundaries.end.offset;
                                o = new zr(i, 0, n);
                                t = ul._createAfter(o)
                            } else {
                                o = new zr(i, 0, i.data.length);
                                t.offset++
                            }
                            this.position = t;
                            return this._formatReturnValue("text", o, e, t, n)
                        }
                    } else if (typeof i == "string") {
                        let i;
                        if (this.singleCharacters) {
                            i = 1
                        } else {
                            const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length;
                            i = e - t.offset
                        }
                        const o = new zr(n, t.offset, i);
                        t.offset += i;
                        this.position = t;
                        return this._formatReturnValue("text", o, e, t, i)
                    } else {
                        t = ul._createAfter(n);
                        this.position = t;
                        if (this.ignoreElementEnd) {
                            return this._next()
                        } else {
                            return this._formatReturnValue("elementEnd", n, e, t)
                        }
                    }
                }
                _previous() {
                    let t = this.position.clone();
                    const e = this.position;
                    const n = t.parent;
                    if (n.parent === null && t.offset === 0) {
                        return {
                            done: true
                        }
                    }
                    if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) {
                        return {
                            done: true
                        }
                    }
                    let i;
                    if (n instanceof Dr) {
                        if (t.isAtStart) {
                            this.position = ul._createBefore(n);
                            return this._previous()
                        }
                        i = n.data[t.offset - 1]
                    } else {
                        i = n.getChild(t.offset - 1)
                    }
                    if (i instanceof Fc) {
                        if (!this.shallow) {
                            t = new ul(i, i.childCount);
                            this.position = t;
                            if (this.ignoreElementEnd) {
                                return this._previous()
                            } else {
                                return this._formatReturnValue("elementEnd", i, e, t)
                            }
                        } else {
                            t.offset--;
                            this.position = t;
                            return this._formatReturnValue("elementStart", i, e, t, 1)
                        }
                    } else if (i instanceof Dr) {
                        if (this.singleCharacters) {
                            t = new ul(i, i.data.length);
                            this.position = t;
                            return this._previous()
                        } else {
                            let n = i.data.length;
                            let o;
                            if (i == this._boundaryStartParent) {
                                const e = this.boundaries.start.offset;
                                o = new zr(i, e, i.data.length - e);
                                n = o.data.length;
                                t = ul._createBefore(o)
                            } else {
                                o = new zr(i, 0, i.data.length);
                                t.offset--
                            }
                            this.position = t;
                            return this._formatReturnValue("text", o, e, t, n)
                        }
                    } else if (typeof i == "string") {
                        let i;
                        if (!this.singleCharacters) {
                            const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                            i = t.offset - e
                        } else {
                            i = 1
                        }
                        t.offset -= i;
                        const o = new zr(n, t.offset, i);
                        this.position = t;
                        return this._formatReturnValue("text", o, e, t, i)
                    } else {
                        t = ul._createBefore(n);
                        this.position = t;
                        return this._formatReturnValue("elementStart", n, e, t, 1)
                    }
                }
                _formatReturnValue(t, e, n, i, o) {
                    if (e instanceof zr) {
                        if (e.offsetInText + e.data.length == e.textNode.data.length) {
                            if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
                                i = ul._createAfter(e.textNode);
                                this.position = i
                            } else {
                                n = ul._createAfter(e.textNode)
                            }
                        }
                        if (e.offsetInText === 0) {
                            if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
                                i = ul._createBefore(e.textNode);
                                this.position = i
                            } else {
                                n = ul._createBefore(e.textNode)
                            }
                        }
                    }
                    return {
                        done: false,
                        value: {
                            type: t,
                            item: e,
                            previousPosition: n,
                            nextPosition: i,
                            length: o
                        }
                    }
                }
            }
            class ul {
                constructor(t, e) {
                    this.parent = t;
                    this.offset = e
                }
                get nodeAfter() {
                    if (this.parent.is("text")) {
                        return null
                    }
                    return this.parent.getChild(this.offset) || null
                }
                get nodeBefore() {
                    if (this.parent.is("text")) {
                        return null
                    }
                    return this.parent.getChild(this.offset - 1) || null
                }
                get isAtStart() {
                    return this.offset === 0
                }
                get isAtEnd() {
                    const t = this.parent.is("text") ? this.parent.data.length : this.parent.childCount;
                    return this.offset === t
                }
                get root() {
                    return this.parent.root
                }
                get editableElement() {
                    let t = this.parent;
                    while (!(t instanceof al)) {
                        if (t.parent) {
                            t = t.parent
                        } else {
                            return null
                        }
                    }
                    return t
                }
                getShiftedBy(t) {
                    const e = ul._createAt(this);
                    const n = e.offset + t;
                    e.offset = n < 0 ? 0 : n;
                    return e
                }
                getLastMatchingPosition(t, e = {}) {
                    e.startPosition = this;
                    const n = new dl(e);
                    n.skip(t);
                    return n.position
                }
                getAncestors() {
                    if (this.parent.is("documentFragment")) {
                        return [this.parent]
                    } else {
                        return this.parent.getAncestors({
                            includeSelf: true
                        })
                    }
                }
                getCommonAncestor(t) {
                    const e = this.getAncestors();
                    const n = t.getAncestors();
                    let i = 0;
                    while (e[i] == n[i] && e[i]) {
                        i++
                    }
                    return i === 0 ? null : e[i - 1]
                }
                is(t) {
                    return t == "position" || t == "view:position"
                }
                isEqual(t) {
                    return this.parent == t.parent && this.offset == t.offset
                }
                isBefore(t) {
                    return this.compareWith(t) == "before"
                }
                isAfter(t) {
                    return this.compareWith(t) == "after"
                }
                compareWith(t) {
                    if (this.root !== t.root) {
                        return "different"
                    }
                    if (this.isEqual(t)) {
                        return "same"
                    }
                    const e = this.parent.is("node") ? this.parent.getPath() : [];
                    const n = t.parent.is("node") ? t.parent.getPath() : [];
                    e.push(this.offset);
                    n.push(t.offset);
                    const i = Nr(e, n);
                    switch (i) {
                        case "prefix":
                            return "before";
                        case "extension":
                            return "after";
                        default:
                            return e[i] < n[i] ? "before" : "after"
                    }
                }
                getWalker(t = {}) {
                    t.startPosition = this;
                    return new dl(t)
                }
                clone() {
                    return new ul(this.parent, this.offset)
                }
                static _createAt(t, e) {
                    if (t instanceof ul) {
                        return new this(t.parent, t.offset)
                    } else {
                        const n = t;
                        if (e == "end") {
                            e = n.is("text") ? n.data.length : n.childCount
                        } else if (e == "before") {
                            return this._createBefore(n)
                        } else if (e == "after") {
                            return this._createAfter(n)
                        } else if (e !== 0 && !e) {
                            throw new rr["b"]("view-createPositionAt-offset-required: " + "View#createPositionAt() requires the offset when the first parameter is a view item.", n)
                        }
                        return new ul(n, e)
                    }
                }
                static _createAfter(t) {
                    if (t.is("textProxy")) {
                        return new ul(t.textNode, t.offsetInText + t.data.length)
                    }
                    if (!t.parent) {
                        throw new rr["b"]("view-position-after-root: You can not make position after root.", t, {
                            root: t
                        })
                    }
                    return new ul(t.parent, t.index + 1)
                }
                static _createBefore(t) {
                    if (t.is("textProxy")) {
                        return new ul(t.textNode, t.offsetInText)
                    }
                    if (!t.parent) {
                        throw new rr["b"]("view-position-before-root: You can not make position before root.", t, {
                            root: t
                        })
                    }
                    return new ul(t.parent, t.index)
                }
            }
            class hl {
                constructor(t, e = null) {
                    this.start = t.clone();
                    this.end = e ? e.clone() : t.clone()
                }
                *[Symbol.iterator]() {
                    yield* new dl({
                        boundaries: this,
                        ignoreElementEnd: true
                    })
                }
                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }
                get isFlat() {
                    return this.start.parent === this.end.parent
                }
                get root() {
                    return this.start.root
                }
                getEnlarged() {
                    let t = this.start.getLastMatchingPosition(fl, {
                        direction: "backward"
                    });
                    let e = this.end.getLastMatchingPosition(fl);
                    if (t.parent.is("text") && t.isAtStart) {
                        t = ul._createBefore(t.parent)
                    }
                    if (e.parent.is("text") && e.isAtEnd) {
                        e = ul._createAfter(e.parent)
                    }
                    return new hl(t, e)
                }
                getTrimmed() {
                    let t = this.start.getLastMatchingPosition(fl);
                    if (t.isAfter(this.end) || t.isEqual(this.end)) {
                        return new hl(t, t)
                    }
                    let e = this.end.getLastMatchingPosition(fl, {
                        direction: "backward"
                    });
                    const n = t.nodeAfter;
                    const i = e.nodeBefore;
                    if (n && n.is("text")) {
                        t = new ul(n, 0)
                    }
                    if (i && i.is("text")) {
                        e = new ul(i, i.data.length)
                    }
                    return new hl(t, e)
                }
                isEqual(t) {
                    return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end)
                }
                containsPosition(t) {
                    return t.isAfter(this.start) && t.isBefore(this.end)
                }
                containsRange(t, e = false) {
                    if (t.isCollapsed) {
                        e = false
                    }
                    const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                    const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                    return n && i
                }
                getDifference(t) {
                    const e = [];
                    if (this.isIntersecting(t)) {
                        if (this.containsPosition(t.start)) {
                            e.push(new hl(this.start, t.start))
                        }
                        if (this.containsPosition(t.end)) {
                            e.push(new hl(t.end, this.end))
                        }
                    } else {
                        e.push(this.clone())
                    }
                    return e
                }
                getIntersection(t) {
                    if (this.isIntersecting(t)) {
                        let e = this.start;
                        let n = this.end;
                        if (this.containsPosition(t.start)) {
                            e = t.start
                        }
                        if (this.containsPosition(t.end)) {
                            n = t.end
                        }
                        return new hl(e, n)
                    }
                    return null
                }
                getWalker(t = {}) {
                    t.boundaries = this;
                    return new dl(t)
                }
                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }
                clone() {
                    return new hl(this.start, this.end)
                }
                *getItems(t = {}) {
                    t.boundaries = this;
                    t.ignoreElementEnd = true;
                    const e = new dl(t);
                    for (const t of e) {
                        yield t.item
                    }
                }
                *getPositions(t = {}) {
                    t.boundaries = this;
                    const e = new dl(t);
                    yield e.position;
                    for (const t of e) {
                        yield t.nextPosition
                    }
                }
                is(t) {
                    return t == "range" || t == "view:range"
                }
                isIntersecting(t) {
                    return this.start.isBefore(t.end) && this.end.isAfter(t.start)
                }
                static _createFromParentsAndOffsets(t, e, n, i) {
                    return new this(new ul(t, e), new ul(n, i))
                }
                static _createFromPositionAndShift(t, e) {
                    const n = t;
                    const i = t.getShiftedBy(e);
                    return e > 0 ? new this(n, i) : new this(i, n)
                }
                static _createIn(t) {
                    return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
                }
                static _createOn(t) {
                    const e = t.is("textProxy") ? t.offsetSize : 1;
                    return this._createFromPositionAndShift(ul._createBefore(t), e)
                }
            }
            function fl(t) {
                if (t.item.is("attributeElement") || t.item.is("uiElement")) {
                    return true
                }
                return false
            }
            function pl(t) {
                let e = 0;
                for (const n of t) {
                    e++
                }
                return e
            }
            class gl {
                constructor(t = null, e, n) {
                    this._ranges = [];
                    this._lastRangeBackward = false;
                    this._isFake = false;
                    this._fakeSelectionLabel = "";
                    this.setTo(t, e, n)
                }
                get isFake() {
                    return this._isFake
                }
                get fakeSelectionLabel() {
                    return this._fakeSelectionLabel
                }
                get anchor() {
                    if (!this._ranges.length) {
                        return null
                    }
                    const t = this._ranges[this._ranges.length - 1];
                    const e = this._lastRangeBackward ? t.end : t.start;
                    return e.clone()
                }
                get focus() {
                    if (!this._ranges.length) {
                        return null
                    }
                    const t = this._ranges[this._ranges.length - 1];
                    const e = this._lastRangeBackward ? t.start : t.end;
                    return e.clone()
                }
                get isCollapsed() {
                    return this.rangeCount === 1 && this._ranges[0].isCollapsed
                }
                get rangeCount() {
                    return this._ranges.length
                }
                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }
                get editableElement() {
                    if (this.anchor) {
                        return this.anchor.editableElement
                    }
                    return null
                }
                *getRanges() {
                    for (const t of this._ranges) {
                        yield t.clone()
                    }
                }
                getFirstRange() {
                    let t = null;
                    for (const e of this._ranges) {
                        if (!t || e.start.isBefore(t.start)) {
                            t = e
                        }
                    }
                    return t ? t.clone() : null
                }
                getLastRange() {
                    let t = null;
                    for (const e of this._ranges) {
                        if (!t || e.end.isAfter(t.end)) {
                            t = e
                        }
                    }
                    return t ? t.clone() : null
                }
                getFirstPosition() {
                    const t = this.getFirstRange();
                    return t ? t.start.clone() : null
                }
                getLastPosition() {
                    const t = this.getLastRange();
                    return t ? t.end.clone() : null
                }
                isEqual(t) {
                    if (this.isFake != t.isFake) {
                        return false
                    }
                    if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
                        return false
                    }
                    if (this.rangeCount != t.rangeCount) {
                        return false
                    } else if (this.rangeCount === 0) {
                        return true
                    }
                    if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                        return false
                    }
                    for (const e of this._ranges) {
                        let n = false;
                        for (const i of t._ranges) {
                            if (e.isEqual(i)) {
                                n = true;
                                break
                            }
                        }
                        if (!n) {
                            return false
                        }
                    }
                    return true
                }
                isSimilar(t) {
                    if (this.isBackward != t.isBackward) {
                        return false
                    }
                    const e = pl(this.getRanges());
                    const n = pl(t.getRanges());
                    if (e != n) {
                        return false
                    }
                    if (e == 0) {
                        return true
                    }
                    for (let e of this.getRanges()) {
                        e = e.getTrimmed();
                        let n = false;
                        for (let i of t.getRanges()) {
                            i = i.getTrimmed();
                            if (e.start.isEqual(i.start) && e.end.isEqual(i.end)) {
                                n = true;
                                break
                            }
                        }
                        if (!n) {
                            return false
                        }
                    }
                    return true
                }
                getSelectedElement() {
                    if (this.rangeCount !== 1) {
                        return null
                    }
                    const t = this.getFirstRange();
                    let e = t.start.nodeAfter;
                    let n = t.end.nodeBefore;
                    if (t.start.parent.is("text") && t.start.isAtEnd && t.start.parent.nextSibling) {
                        e = t.start.parent.nextSibling
                    }
                    if (t.end.parent.is("text") && t.end.isAtStart && t.end.parent.previousSibling) {
                        n = t.end.parent.previousSibling
                    }
                    return e instanceof Fc && e == n ? e : null
                }
                setTo(t, e, n) {
                    if (t === null) {
                        this._setRanges([]);
                        this._setFakeOptions(e)
                    } else if (t instanceof gl || t instanceof ml) {
                        this._setRanges(t.getRanges(), t.isBackward);
                        this._setFakeOptions({
                            fake: t.isFake,
                            label: t.fakeSelectionLabel
                        })
                    } else if (t instanceof hl) {
                        this._setRanges([t], e && e.backward);
                        this._setFakeOptions(e)
                    } else if (t instanceof ul) {
                        this._setRanges([new hl(t)]);
                        this._setFakeOptions(e)
                    } else if (t instanceof Fr) {
                        const i = !!n && !!n.backward;
                        let o;
                        if (e === undefined) {
                            throw new rr["b"]("view-selection-setTo-required-second-parameter: " + "selection.setTo requires the second parameter when the first parameter is a node.", this)
                        } else if (e == "in") {
                            o = hl._createIn(t)
                        } else if (e == "on") {
                            o = hl._createOn(t)
                        } else {
                            o = new hl(ul._createAt(t, e))
                        }
                        this._setRanges([o], i);
                        this._setFakeOptions(n)
                    } else if (jr(t)) {
                        this._setRanges(t, e && e.backward);
                        this._setFakeOptions(e)
                    } else {
                        throw new rr["b"]("view-selection-setTo-not-selectable: Cannot set selection to given place.", this)
                    }
                    this.fire("change")
                }
                setFocus(t, e) {
                    if (this.anchor === null) {
                        throw new rr["b"]("view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.", this)
                    }
                    const n = ul._createAt(t, e);
                    if (n.compareWith(this.focus) == "same") {
                        return
                    }
                    const i = this.anchor;
                    this._ranges.pop();
                    if (n.compareWith(i) == "before") {
                        this._addRange(new hl(n, i), true)
                    } else {
                        this._addRange(new hl(i, n))
                    }
                    this.fire("change")
                }
                is(t) {
                    return t == "selection" || t == "view:selection"
                }
                _setRanges(t, e = false) {
                    t = Array.from(t);
                    this._ranges = [];
                    for (const e of t) {
                        this._addRange(e)
                    }
                    this._lastRangeBackward = !!e
                }
                _setFakeOptions(t = {}) {
                    this._isFake = !!t.fake;
                    this._fakeSelectionLabel = t.fake ? t.label || "" : ""
                }
                _addRange(t, e = false) {
                    if (!(t instanceof hl)) {
                        throw new rr["b"]("view-selection-add-range-not-range: " + "Selection range set to an object that is not an instance of view.Range", this)
                    }
                    this._pushRange(t);
                    this._lastRangeBackward = !!e
                }
                _pushRange(t) {
                    for (const e of this._ranges) {
                        if (t.isIntersecting(e)) {
                            throw new rr["b"]("view-selection-range-intersects: Trying to add a range that intersects with another range from selection.", this, {
                                addedRange: t,
                                intersectingRange: e
                            })
                        }
                    }
                    this._ranges.push(new hl(t.start, t.end))
                }
            }
            vr(gl, dr);
            class ml {
                constructor(t = null, e, n) {
                    this._selection = new gl;
                    this._selection.delegate("change").to(this);
                    this._selection.setTo(t, e, n)
                }
                get isFake() {
                    return this._selection.isFake
                }
                get fakeSelectionLabel() {
                    return this._selection.fakeSelectionLabel
                }
                get anchor() {
                    return this._selection.anchor
                }
                get focus() {
                    return this._selection.focus
                }
                get isCollapsed() {
                    return this._selection.isCollapsed
                }
                get rangeCount() {
                    return this._selection.rangeCount
                }
                get isBackward() {
                    return this._selection.isBackward
                }
                get editableElement() {
                    return this._selection.editableElement
                }
                get _ranges() {
                    return this._selection._ranges
                }
                *getRanges() {
                    yield* this._selection.getRanges()
                }
                getFirstRange() {
                    return this._selection.getFirstRange()
                }
                getLastRange() {
                    return this._selection.getLastRange()
                }
                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }
                getLastPosition() {
                    return this._selection.getLastPosition()
                }
                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }
                isEqual(t) {
                    return this._selection.isEqual(t)
                }
                isSimilar(t) {
                    return this._selection.isSimilar(t)
                }
                is(t) {
                    return t == "selection" || t == "documentSelection" || t == "view:selection" || t == "view:documentSelection"
                }
                _setTo(t, e, n) {
                    this._selection.setTo(t, e, n)
                }
                _setFocus(t, e) {
                    this._selection.setFocus(t, e)
                }
            }
            vr(ml, dr);
            class bl {
                constructor() {
                    this.selection = new ml;
                    this.roots = new yr({
                        idProperty: "rootName"
                    });
                    this.set("isReadOnly", false);
                    this.set("isFocused", false);
                    this.set("isComposing", false);
                    this._postFixers = new Set
                }
                getRoot(t = "main") {
                    return this.roots.get(t)
                }
                registerPostFixer(t) {
                    this._postFixers.add(t)
                }
                destroy() {
                    this.roots.map(t => t.destroy());
                    this.stopListening()
                }
                addStyleProcessorRules(t) {
                    t(Mc._styleProcessor)
                }
                _callPostFixers(t) {
                    let e = false;
                    do {
                        for (const n of this._postFixers) {
                            e = n(t);
                            if (e) {
                                break
                            }
                        }
                    } while (e)
                }
            }
            vr(bl, Jc);
            const wl = 10;
            class kl extends Fc {
                constructor(t, e, n) {
                    super(t, e, n);
                    this.getFillerOffset = _l;
                    this._priority = wl;
                    this._id = null;
                    this._clonesGroup = null
                }
                get priority() {
                    return this._priority
                }
                get id() {
                    return this._id
                }
                getElementsWithSameId() {
                    if (this.id === null) {
                        throw new rr["b"]("attribute-element-get-elements-with-same-id-no-id: " + "Cannot get elements with the same id for an attribute element without id.", this)
                    }
                    return new Set(this._clonesGroup)
                }
                is(t, e = null) {
                    const n = t && t.replace(/^view:/, "");
                    if (!e) {
                        return n == "attributeElement" || super.is(t)
                    } else {
                        return n == "attributeElement" && e == this.name || super.is(t, e)
                    }
                }
                isSimilar(t) {
                    if (this.id !== null || t.id !== null) {
                        return this.id === t.id
                    }
                    return super.isSimilar(t) && this.priority == t.priority
                }
                _clone(t) {
                    const e = super._clone(t);
                    e._priority = this._priority;
                    e._id = this._id;
                    return e
                }
            }
            kl.DEFAULT_PRIORITY = wl;
            function _l() {
                if (vl(this)) {
                    return null
                }
                let t = this.parent;
                while (t && t.is("attributeElement")) {
                    if (vl(t) > 1) {
                        return null
                    }
                    t = t.parent
                }
                if (!t || vl(t) > 1) {
                    return null
                }
                return this.childCount
            }
            function vl(t) {
                return Array.from(t.getChildren()).filter(t => !t.is("uiElement")).length
            }
            class yl extends Fc {
                constructor(t, e, n) {
                    super(t, e, n);
                    this.getFillerOffset = xl
                }
                is(t, e = null) {
                    const n = t.replace(/^view:/, "");
                    if (!e) {
                        return n == "emptyElement" || super.is(t)
                    } else {
                        return n == "emptyElement" && e == this.name || super.is(t, e)
                    }
                }
                _insertChild(t, e) {
                    if (e && (e instanceof Fr || Array.from(e).length > 0)) {
                        throw new rr["b"]("view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.", [this, e])
                    }
                }
            }
            function xl() {
                return null
            }
            const Cl = navigator.userAgent.toLowerCase();
            const Al = {
                isMac: Tl(Cl),
                isEdge: Sl(Cl),
                isGecko: El(Cl),
                isSafari: Rl(Cl),
                isAndroid: Ol(Cl),
                features: {
                    isRegExpUnicodePropertySupported: Ml()
                }
            };
            var Pl = Al;
            function Tl(t) {
                return t.indexOf("macintosh") > -1
            }
            function Sl(t) {
                return !!t.match(/edge\/(\d+.?\d*)/)
            }
            function El(t) {
                return !!t.match(/gecko\/\d+/)
            }
            function Rl(t) {
                return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1
            }
            function Ol(t) {
                return t.indexOf("android") > -1
            }
            function Ml() {
                let t = false;
                try {
                    t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0
                } catch (t) { }
                return t
            }
            const Nl = {
                "⌘": "ctrl",
                "⇧": "shift",
                "⌥": "alt"
            };
            const Il = {
                ctrl: "⌘",
                shift: "⇧",
                alt: "⌥"
            };
            const Vl = zl();
            function Bl(t) {
                let e;
                if (typeof t == "string") {
                    e = Vl[t.toLowerCase()];
                    if (!e) {
                        throw new rr["b"]("keyboard-unknown-key: Unknown key name.", null, {
                            key: t
                        })
                    }
                } else {
                    e = t.keyCode + (t.altKey ? Vl.alt : 0) + (t.ctrlKey ? Vl.ctrl : 0) + (t.shiftKey ? Vl.shift : 0)
                }
                return e
            }
            function Fl(t) {
                if (typeof t == "string") {
                    t = Ll(t)
                }
                return t.map(t => typeof t == "string" ? Bl(t) : t).reduce((t, e) => e + t, 0)
            }
            function Dl(t) {
                if (!Pl.isMac) {
                    return t
                }
                return Ll(t).map(t => Il[t.toLowerCase()] || t).reduce((t, e) => {
                    if (t.slice(-1) in Nl) {
                        return t + e
                    } else {
                        return t + "+" + e
                    }
                }
                )
            }
            function zl() {
                const t = {
                    arrowleft: 37,
                    arrowup: 38,
                    arrowright: 39,
                    arrowdown: 40,
                    backspace: 8,
                    delete: 46,
                    enter: 13,
                    space: 32,
                    esc: 27,
                    tab: 9,
                    ctrl: 1114112,
                    cmd: 1114112,
                    shift: 2228224,
                    alt: 4456448
                };
                for (let e = 65; e <= 90; e++) {
                    const n = String.fromCharCode(e);
                    t[n.toLowerCase()] = e
                }
                for (let e = 48; e <= 57; e++) {
                    t[e - 48] = e
                }
                for (let e = 112; e <= 123; e++) {
                    t["f" + (e - 111)] = e
                }
                return t
            }
            function Ll(t) {
                return t.split(/\s*\+\s*/)
            }
            class jl extends Fc {
                constructor(t, e, n) {
                    super(t, e, n);
                    this.getFillerOffset = ql
                }
                is(t, e = null) {
                    const n = t.replace(/^view:/, "");
                    if (!e) {
                        return n == "uiElement" || super.is(t)
                    } else {
                        return n == "uiElement" && e == this.name || super.is(t, e)
                    }
                }
                _insertChild(t, e) {
                    if (e && (e instanceof Fr || Array.from(e).length > 0)) {
                        throw new rr["b"]("view-uielement-cannot-add: Cannot add child nodes to UIElement instance.", this)
                    }
                }
                render(t) {
                    return this.toDomElement(t)
                }
                toDomElement(t) {
                    const e = t.createElement(this.name);
                    for (const t of this.getAttributeKeys()) {
                        e.setAttribute(t, this.getAttribute(t))
                    }
                    return e
                }
            }
            function Hl(t) {
                t.document.on("keydown", (e, n) => Wl(e, n, t.domConverter))
            }
            function ql() {
                return null
            }
            function Wl(t, e, n) {
                if (e.keyCode == Vl.arrowright) {
                    const t = e.domTarget.ownerDocument.defaultView.getSelection();
                    const i = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
                    if (i || e.shiftKey) {
                        const e = t.focusNode;
                        const o = t.focusOffset;
                        const s = n.domPositionToView(e, o);
                        if (s === null) {
                            return
                        }
                        let r = false;
                        const a = s.getLastMatchingPosition(t => {
                            if (t.item.is("uiElement")) {
                                r = true
                            }
                            if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                                return true
                            }
                            return false
                        }
                        );
                        if (r) {
                            const e = n.viewPositionToDom(a);
                            if (i) {
                                t.collapse(e.parent, e.offset)
                            } else {
                                t.extend(e.parent, e.offset)
                            }
                        }
                    }
                }
            }
            class Ul {
                constructor(t) {
                    this._children = [];
                    if (t) {
                        this._insertChild(0, t)
                    }
                }
                [Symbol.iterator]() {
                    return this._children[Symbol.iterator]()
                }
                get childCount() {
                    return this._children.length
                }
                get isEmpty() {
                    return this.childCount === 0
                }
                get root() {
                    return this
                }
                get parent() {
                    return null
                }
                is(t) {
                    return t == "documentFragment" || t == "view:documentFragment"
                }
                _appendChild(t) {
                    return this._insertChild(this.childCount, t)
                }
                getChild(t) {
                    return this._children[t]
                }
                getChildIndex(t) {
                    return this._children.indexOf(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                _insertChild(t, e) {
                    this._fireChange("children", this);
                    let n = 0;
                    const i = $l(e);
                    for (const e of i) {
                        if (e.parent !== null) {
                            e._remove()
                        }
                        e.parent = this;
                        this._children.splice(t, 0, e);
                        t++;
                        n++
                    }
                    return n
                }
                _removeChildren(t, e = 1) {
                    this._fireChange("children", this);
                    for (let n = t; n < t + e; n++) {
                        this._children[n].parent = null
                    }
                    return this._children.splice(t, e)
                }
                _fireChange(t, e) {
                    this.fire("change:" + t, e)
                }
            }
            vr(Ul, dr);
            function $l(t) {
                if (typeof t == "string") {
                    return [new Dr(t)]
                }
                if (!jr(t)) {
                    t = [t]
                }
                return Array.from(t).map(t => {
                    if (typeof t == "string") {
                        return new Dr(t)
                    }
                    if (t instanceof zr) {
                        return new Dr(t.data)
                    }
                    return t
                }
                )
            }
            class Gl {
                constructor(t) {
                    this.document = t;
                    this._cloneGroups = new Map
                }
                setSelection(t, e, n) {
                    this.document.selection._setTo(t, e, n)
                }
                setSelectionFocus(t, e) {
                    this.document.selection._setFocus(t, e)
                }
                createText(t) {
                    return new Dr(t)
                }
                createAttributeElement(t, e, n = {}) {
                    const i = new kl(t, e);
                    if (n.priority) {
                        i._priority = n.priority
                    }
                    if (n.id) {
                        i._id = n.id
                    }
                    return i
                }
                createContainerElement(t, e) {
                    return new jc(t, e)
                }
                createEditableElement(t, e) {
                    const n = new al(t, e);
                    n._document = this.document;
                    return n
                }
                createEmptyElement(t, e) {
                    return new yl(t, e)
                }
                createUIElement(t, e, n) {
                    const i = new jl(t, e);
                    if (n) {
                        i.render = n
                    }
                    return i
                }
                setAttribute(t, e, n) {
                    n._setAttribute(t, e)
                }
                removeAttribute(t, e) {
                    e._removeAttribute(t)
                }
                addClass(t, e) {
                    e._addClass(t)
                }
                removeClass(t, e) {
                    e._removeClass(t)
                }
                setStyle(t, e, n) {
                    if (I(t) && n === undefined) {
                        n = e
                    }
                    n._setStyle(t, e)
                }
                removeStyle(t, e) {
                    e._removeStyle(t)
                }
                setCustomProperty(t, e, n) {
                    n._setCustomProperty(t, e)
                }
                removeCustomProperty(t, e) {
                    return e._removeCustomProperty(t)
                }
                breakAttributes(t) {
                    if (t instanceof ul) {
                        return this._breakAttributes(t)
                    } else {
                        return this._breakAttributesRange(t)
                    }
                }
                breakContainer(t) {
                    const e = t.parent;
                    if (!e.is("containerElement")) {
                        throw new rr["b"]("view-writer-break-non-container-element: Trying to break an element which is not a container element.", this.document)
                    }
                    if (!e.parent) {
                        throw new rr["b"]("view-writer-break-root: Trying to break root element.", this.document)
                    }
                    if (t.isAtStart) {
                        return ul._createBefore(e)
                    } else if (!t.isAtEnd) {
                        const n = e._clone(false);
                        this.insert(ul._createAfter(e), n);
                        const i = new hl(t, ul._createAt(e, "end"));
                        const o = new ul(n, 0);
                        this.move(i, o)
                    }
                    return ul._createAfter(e)
                }
                mergeAttributes(t) {
                    const e = t.offset;
                    const n = t.parent;
                    if (n.is("text")) {
                        return t
                    }
                    if (n.is("attributeElement") && n.childCount === 0) {
                        const t = n.parent;
                        const e = n.index;
                        n._remove();
                        this._removeFromClonedElementsGroup(n);
                        return this.mergeAttributes(new ul(t, e))
                    }
                    const i = n.getChild(e - 1);
                    const o = n.getChild(e);
                    if (!i || !o) {
                        return t
                    }
                    if (i.is("text") && o.is("text")) {
                        return Zl(i, o)
                    } else if (i.is("attributeElement") && o.is("attributeElement") && i.isSimilar(o)) {
                        const t = i.childCount;
                        i._appendChild(o.getChildren());
                        o._remove();
                        this._removeFromClonedElementsGroup(o);
                        return this.mergeAttributes(new ul(i, t))
                    }
                    return t
                }
                mergeContainers(t) {
                    const e = t.nodeBefore;
                    const n = t.nodeAfter;
                    if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) {
                        throw new rr["b"]("view-writer-merge-containers-invalid-position: " + "Element before and after given position cannot be merged.", this.document)
                    }
                    const i = e.getChild(e.childCount - 1);
                    const o = i instanceof Dr ? ul._createAt(i, "end") : ul._createAt(e, "end");
                    this.move(hl._createIn(n), ul._createAt(e, "end"));
                    this.remove(hl._createOn(n));
                    return o
                }
                insert(t, e) {
                    e = jr(e) ? [...e] : [e];
                    td(e, this.document);
                    const n = Jl(t);
                    if (!n) {
                        throw new rr["b"]("view-writer-invalid-position-container", this.document)
                    }
                    const i = this._breakAttributes(t, true);
                    const o = n._insertChild(i.offset, e);
                    for (const t of e) {
                        this._addToClonedElementsGroup(t)
                    }
                    const s = i.getShiftedBy(o);
                    const r = this.mergeAttributes(i);
                    if (o === 0) {
                        return new hl(r, r)
                    } else {
                        if (!r.isEqual(i)) {
                            s.offset--
                        }
                        const t = this.mergeAttributes(s);
                        return new hl(r, t)
                    }
                }
                remove(t) {
                    const e = t instanceof hl ? t : hl._createOn(t);
                    id(e, this.document);
                    if (e.isCollapsed) {
                        return new Ul
                    }
                    const { start: n, end: i } = this._breakAttributesRange(e, true);
                    const o = n.parent;
                    const s = i.offset - n.offset;
                    const r = o._removeChildren(n.offset, s);
                    for (const t of r) {
                        this._removeFromClonedElementsGroup(t)
                    }
                    const a = this.mergeAttributes(n);
                    e.start = a;
                    e.end = a.clone();
                    return new Ul(r)
                }
                clear(t, e) {
                    id(t, this.document);
                    const n = t.getWalker({
                        direction: "backward",
                        ignoreElementEnd: true
                    });
                    for (const i of n) {
                        const n = i.item;
                        let o;
                        if (n.is("element") && e.isSimilar(n)) {
                            o = hl._createOn(n)
                        } else if (!i.nextPosition.isAfter(t.start) && n.is("textProxy")) {
                            const t = n.getAncestors().find(t => t.is("element") && e.isSimilar(t));
                            if (t) {
                                o = hl._createIn(t)
                            }
                        }
                        if (o) {
                            if (o.end.isAfter(t.end)) {
                                o.end = t.end
                            }
                            if (o.start.isBefore(t.start)) {
                                o.start = t.start
                            }
                            this.remove(o)
                        }
                    }
                }
                move(t, e) {
                    let n;
                    if (e.isAfter(t.end)) {
                        e = this._breakAttributes(e, true);
                        const i = e.parent;
                        const o = i.childCount;
                        t = this._breakAttributesRange(t, true);
                        n = this.remove(t);
                        e.offset += i.childCount - o
                    } else {
                        n = this.remove(t)
                    }
                    return this.insert(e, n)
                }
                wrap(t, e) {
                    if (!(e instanceof kl)) {
                        throw new rr["b"]("view-writer-wrap-invalid-attribute", this.document)
                    }
                    id(t, this.document);
                    if (!t.isCollapsed) {
                        return this._wrapRange(t, e)
                    } else {
                        let n = t.start;
                        if (n.parent.is("element") && !Kl(n.parent)) {
                            n = n.getLastMatchingPosition(t => t.item.is("uiElement"))
                        }
                        n = this._wrapPosition(n, e);
                        const i = this.document.selection;
                        if (i.isCollapsed && i.getFirstPosition().isEqual(t.start)) {
                            this.setSelection(n)
                        }
                        return new hl(n)
                    }
                }
                unwrap(t, e) {
                    if (!(e instanceof kl)) {
                        throw new rr["b"]("view-writer-unwrap-invalid-attribute", this.document)
                    }
                    id(t, this.document);
                    if (t.isCollapsed) {
                        return t
                    }
                    const { start: n, end: i } = this._breakAttributesRange(t, true);
                    const o = n.parent;
                    const s = this._unwrapChildren(o, n.offset, i.offset, e);
                    const r = this.mergeAttributes(s.start);
                    if (!r.isEqual(s.start)) {
                        s.end.offset--
                    }
                    const a = this.mergeAttributes(s.end);
                    return new hl(r, a)
                }
                rename(t, e) {
                    const n = new jc(t, e.getAttributes());
                    this.insert(ul._createAfter(e), n);
                    this.move(hl._createIn(e), ul._createAt(n, 0));
                    this.remove(hl._createOn(e));
                    return n
                }
                clearClonedElementsGroup(t) {
                    this._cloneGroups.delete(t)
                }
                createPositionAt(t, e) {
                    return ul._createAt(t, e)
                }
                createPositionAfter(t) {
                    return ul._createAfter(t)
                }
                createPositionBefore(t) {
                    return ul._createBefore(t)
                }
                createRange(t, e) {
                    return new hl(t, e)
                }
                createRangeOn(t) {
                    return hl._createOn(t)
                }
                createRangeIn(t) {
                    return hl._createIn(t)
                }
                createSelection(t, e, n) {
                    return new gl(t, e, n)
                }
                _wrapChildren(t, e, n, i) {
                    let o = e;
                    const s = [];
                    while (o < n) {
                        const e = t.getChild(o);
                        const n = e.is("text");
                        const r = e.is("attributeElement");
                        const a = e.is("emptyElement");
                        const c = e.is("uiElement");
                        if (r && this._wrapAttributeElement(i, e)) {
                            s.push(new ul(t, o))
                        } else if (n || a || c || r && Ql(i, e)) {
                            const n = i._clone();
                            e._remove();
                            n._appendChild(e);
                            t._insertChild(o, n);
                            this._addToClonedElementsGroup(n);
                            s.push(new ul(t, o))
                        } else if (r) {
                            this._wrapChildren(e, 0, e.childCount, i)
                        }
                        o++
                    }
                    let r = 0;
                    for (const t of s) {
                        t.offset -= r;
                        if (t.offset == e) {
                            continue
                        }
                        const i = this.mergeAttributes(t);
                        if (!i.isEqual(t)) {
                            r++;
                            n--
                        }
                    }
                    return hl._createFromParentsAndOffsets(t, e, t, n)
                }
                _unwrapChildren(t, e, n, i) {
                    let o = e;
                    const s = [];
                    while (o < n) {
                        const e = t.getChild(o);
                        if (!e.is("attributeElement")) {
                            o++;
                            continue
                        }
                        if (e.isSimilar(i)) {
                            const i = e.getChildren();
                            const r = e.childCount;
                            e._remove();
                            t._insertChild(o, i);
                            this._removeFromClonedElementsGroup(e);
                            s.push(new ul(t, o), new ul(t, o + r));
                            o += r;
                            n += r - 1;
                            continue
                        }
                        if (this._unwrapAttributeElement(i, e)) {
                            s.push(new ul(t, o), new ul(t, o + 1));
                            o++;
                            continue
                        }
                        this._unwrapChildren(e, 0, e.childCount, i);
                        o++
                    }
                    let r = 0;
                    for (const t of s) {
                        t.offset -= r;
                        if (t.offset == e || t.offset == n) {
                            continue
                        }
                        const i = this.mergeAttributes(t);
                        if (!i.isEqual(t)) {
                            r++;
                            n--
                        }
                    }
                    return hl._createFromParentsAndOffsets(t, e, t, n)
                }
                _wrapRange(t, e) {
                    const { start: n, end: i } = this._breakAttributesRange(t, true);
                    const o = n.parent;
                    const s = this._wrapChildren(o, n.offset, i.offset, e);
                    const r = this.mergeAttributes(s.start);
                    if (!r.isEqual(s.start)) {
                        s.end.offset--
                    }
                    const a = this.mergeAttributes(s.end);
                    return new hl(r, a)
                }
                _wrapPosition(t, e) {
                    if (e.isSimilar(t.parent)) {
                        return Yl(t.clone())
                    }
                    if (t.parent.is("text")) {
                        t = Xl(t)
                    }
                    const n = this.createAttributeElement();
                    n._priority = Number.POSITIVE_INFINITY;
                    n.isSimilar = () => false;
                    t.parent._insertChild(t.offset, n);
                    const i = new hl(t, t.getShiftedBy(1));
                    this.wrap(i, e);
                    const o = new ul(n.parent, n.index);
                    n._remove();
                    const s = o.nodeBefore;
                    const r = o.nodeAfter;
                    if (s instanceof Dr && r instanceof Dr) {
                        return Zl(s, r)
                    }
                    return Yl(o)
                }
                _wrapAttributeElement(t, e) {
                    if (!od(t, e)) {
                        return false
                    }
                    if (t.name !== e.name || t.priority !== e.priority) {
                        return false
                    }
                    for (const n of t.getAttributeKeys()) {
                        if (n === "class" || n === "style") {
                            continue
                        }
                        if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
                            return false
                        }
                    }
                    for (const n of t.getStyleNames()) {
                        if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
                            return false
                        }
                    }
                    for (const n of t.getAttributeKeys()) {
                        if (n === "class" || n === "style") {
                            continue
                        }
                        if (!e.hasAttribute(n)) {
                            this.setAttribute(n, t.getAttribute(n), e)
                        }
                    }
                    for (const n of t.getStyleNames()) {
                        if (!e.hasStyle(n)) {
                            this.setStyle(n, t.getStyle(n), e)
                        }
                    }
                    for (const n of t.getClassNames()) {
                        if (!e.hasClass(n)) {
                            this.addClass(n, e)
                        }
                    }
                    return true
                }
                _unwrapAttributeElement(t, e) {
                    if (!od(t, e)) {
                        return false
                    }
                    if (t.name !== e.name || t.priority !== e.priority) {
                        return false
                    }
                    for (const n of t.getAttributeKeys()) {
                        if (n === "class" || n === "style") {
                            continue
                        }
                        if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
                            return false
                        }
                    }
                    if (!e.hasClass(...t.getClassNames())) {
                        return false
                    }
                    for (const n of t.getStyleNames()) {
                        if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
                            return false
                        }
                    }
                    for (const n of t.getAttributeKeys()) {
                        if (n === "class" || n === "style") {
                            continue
                        }
                        this.removeAttribute(n, e)
                    }
                    this.removeClass(Array.from(t.getClassNames()), e);
                    this.removeStyle(Array.from(t.getStyleNames()), e);
                    return true
                }
                _breakAttributesRange(t, e = false) {
                    const n = t.start;
                    const i = t.end;
                    id(t, this.document);
                    if (t.isCollapsed) {
                        const n = this._breakAttributes(t.start, e);
                        return new hl(n, n)
                    }
                    const o = this._breakAttributes(i, e);
                    const s = o.parent.childCount;
                    const r = this._breakAttributes(n, e);
                    o.offset += o.parent.childCount - s;
                    return new hl(r, o)
                }
                _breakAttributes(t, e = false) {
                    const n = t.offset;
                    const i = t.parent;
                    if (t.parent.is("emptyElement")) {
                        throw new rr["b"]("view-writer-cannot-break-empty-element", this.document)
                    }
                    if (t.parent.is("uiElement")) {
                        throw new rr["b"]("view-writer-cannot-break-ui-element", this.document)
                    }
                    if (!e && i.is("text") && nd(i.parent)) {
                        return t.clone()
                    }
                    if (nd(i)) {
                        return t.clone()
                    }
                    if (i.is("text")) {
                        return this._breakAttributes(Xl(t), e)
                    }
                    const o = i.childCount;
                    if (n == o) {
                        const t = new ul(i.parent, i.index + 1);
                        return this._breakAttributes(t, e)
                    } else {
                        if (n === 0) {
                            const t = new ul(i.parent, i.index);
                            return this._breakAttributes(t, e)
                        } else {
                            const t = i.index + 1;
                            const o = i._clone();
                            i.parent._insertChild(t, o);
                            this._addToClonedElementsGroup(o);
                            const s = i.childCount - n;
                            const r = i._removeChildren(n, s);
                            o._appendChild(r);
                            const a = new ul(i.parent, t);
                            return this._breakAttributes(a, e)
                        }
                    }
                }
                _addToClonedElementsGroup(t) {
                    if (!t.root.is("rootElement")) {
                        return
                    }
                    if (t.is("element")) {
                        for (const e of t.getChildren()) {
                            this._addToClonedElementsGroup(e)
                        }
                    }
                    const e = t.id;
                    if (!e) {
                        return
                    }
                    let n = this._cloneGroups.get(e);
                    if (!n) {
                        n = new Set;
                        this._cloneGroups.set(e, n)
                    }
                    n.add(t);
                    t._clonesGroup = n
                }
                _removeFromClonedElementsGroup(t) {
                    if (t.is("element")) {
                        for (const e of t.getChildren()) {
                            this._removeFromClonedElementsGroup(e)
                        }
                    }
                    const e = t.id;
                    if (!e) {
                        return
                    }
                    const n = this._cloneGroups.get(e);
                    if (!n) {
                        return
                    }
                    n.delete(t)
                }
            }
            function Kl(t) {
                return Array.from(t.getChildren()).some(t => !t.is("uiElement"))
            }
            function Jl(t) {
                let e = t.parent;
                while (!nd(e)) {
                    if (!e) {
                        return undefined
                    }
                    e = e.parent
                }
                return e
            }
            function Ql(t, e) {
                if (t.priority < e.priority) {
                    return true
                } else if (t.priority > e.priority) {
                    return false
                }
                return t.getIdentity() < e.getIdentity()
            }
            function Yl(t) {
                const e = t.nodeBefore;
                if (e && e.is("text")) {
                    return new ul(e, e.data.length)
                }
                const n = t.nodeAfter;
                if (n && n.is("text")) {
                    return new ul(n, 0)
                }
                return t
            }
            function Xl(t) {
                if (t.offset == t.parent.data.length) {
                    return new ul(t.parent.parent, t.parent.index + 1)
                }
                if (t.offset === 0) {
                    return new ul(t.parent.parent, t.parent.index)
                }
                const e = t.parent.data.slice(t.offset);
                t.parent._data = t.parent.data.slice(0, t.offset);
                t.parent.parent._insertChild(t.parent.index + 1, new Dr(e));
                return new ul(t.parent.parent, t.parent.index + 1)
            }
            function Zl(t, e) {
                const n = t.data.length;
                t._data += e.data;
                e._remove();
                return new ul(t, n)
            }
            function td(t, e) {
                for (const n of t) {
                    if (!ed.some(t => n instanceof t)) {
                        throw new rr["b"]("view-writer-insert-invalid-node", e)
                    }
                    if (!n.is("text")) {
                        td(n.getChildren(), e)
                    }
                }
            }
            const ed = [Dr, kl, jc, yl, jl];
            function nd(t) {
                return t && (t.is("containerElement") || t.is("documentFragment"))
            }
            function id(t, e) {
                const n = Jl(t.start);
                const i = Jl(t.end);
                if (!n || !i || n !== i) {
                    throw new rr["b"]("view-writer-invalid-range-container", e)
                }
            }
            function od(t, e) {
                return t.id === null && e.id === null
            }
            function sd(t) {
                return Object.prototype.toString.call(t) == "[object Text]"
            }
            const rd = t => t.createTextNode(" ");
            const ad = t => {
                const e = t.createElement("br");
                e.dataset.ckeFiller = true;
                return e
            }
                ;
            const cd = 7;
            const ld = (() => {
                let t = "";
                for (let e = 0; e < cd; e++) {
                    t += "​"
                }
                return t
            }
            )();
            function dd(t) {
                return sd(t) && t.data.substr(0, cd) === ld
            }
            function ud(t) {
                return t.data.length == cd && dd(t)
            }
            function hd(t) {
                if (dd(t)) {
                    return t.data.slice(cd)
                } else {
                    return t.data
                }
            }
            function fd(t) {
                t.document.on("keydown", pd)
            }
            function pd(t, e) {
                if (e.keyCode == Vl.arrowleft) {
                    const t = e.domTarget.ownerDocument.defaultView.getSelection();
                    if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
                        const e = t.getRangeAt(0).startContainer;
                        const n = t.getRangeAt(0).startOffset;
                        if (dd(e) && n <= cd) {
                            t.collapse(e, 0)
                        }
                    }
                }
            }
            function gd(t, e, n, i = false) {
                n = n || function (t, e) {
                    return t === e
                }
                    ;
                if (!Array.isArray(t)) {
                    t = Array.from(t)
                }
                if (!Array.isArray(e)) {
                    e = Array.from(e)
                }
                const o = md(t, e, n);
                return i ? _d(o, e.length) : kd(e, o)
            }
            function md(t, e, n) {
                const i = bd(t, e, n);
                if (i === -1) {
                    return {
                        firstIndex: -1,
                        lastIndexOld: -1,
                        lastIndexNew: -1
                    }
                }
                const o = wd(t, i);
                const s = wd(e, i);
                const r = bd(o, s, n);
                const a = t.length - r;
                const c = e.length - r;
                return {
                    firstIndex: i,
                    lastIndexOld: a,
                    lastIndexNew: c
                }
            }
            function bd(t, e, n) {
                for (let i = 0; i < Math.max(t.length, e.length); i++) {
                    if (t[i] === undefined || e[i] === undefined || !n(t[i], e[i])) {
                        return i
                    }
                }
                return -1
            }
            function wd(t, e) {
                return t.slice(e).reverse()
            }
            function kd(t, e) {
                const n = [];
                const { firstIndex: i, lastIndexOld: o, lastIndexNew: s } = e;
                if (s - i > 0) {
                    n.push({
                        index: i,
                        type: "insert",
                        values: t.slice(i, s)
                    })
                }
                if (o - i > 0) {
                    n.push({
                        index: i + (s - i),
                        type: "delete",
                        howMany: o - i
                    })
                }
                return n
            }
            function _d(t, e) {
                const { firstIndex: n, lastIndexOld: i, lastIndexNew: o } = t;
                if (n === -1) {
                    return Array(e).fill("equal")
                }
                let s = [];
                if (n > 0) {
                    s = s.concat(Array(n).fill("equal"))
                }
                if (o - n > 0) {
                    s = s.concat(Array(o - n).fill("insert"))
                }
                if (i - n > 0) {
                    s = s.concat(Array(i - n).fill("delete"))
                }
                if (o < e) {
                    s = s.concat(Array(e - o).fill("equal"))
                }
                return s
            }
            function vd(t, e, n) {
                n = n || function (t, e) {
                    return t === e
                }
                    ;
                const i = t.length;
                const o = e.length;
                if (i > 200 || o > 200 || i + o > 300) {
                    return vd.fastDiff(t, e, n, true)
                }
                let s, r;
                if (o < i) {
                    const n = t;
                    t = e;
                    e = n;
                    s = "delete";
                    r = "insert"
                } else {
                    s = "insert";
                    r = "delete"
                }
                const a = t.length;
                const c = e.length;
                const l = c - a;
                const d = {};
                const u = {};
                function h(i) {
                    const o = (u[i - 1] !== undefined ? u[i - 1] : -1) + 1;
                    const l = u[i + 1] !== undefined ? u[i + 1] : -1;
                    const h = o > l ? -1 : 1;
                    if (d[i + h]) {
                        d[i] = d[i + h].slice(0)
                    }
                    if (!d[i]) {
                        d[i] = []
                    }
                    d[i].push(o > l ? s : r);
                    let f = Math.max(o, l);
                    let p = f - i;
                    while (p < a && f < c && n(t[p], e[f])) {
                        p++;
                        f++;
                        d[i].push("equal")
                    }
                    return f
                }
                let f = 0;
                let p;
                do {
                    for (p = -f; p < l; p++) {
                        u[p] = h(p)
                    }
                    for (p = l + f; p > l; p--) {
                        u[p] = h(p)
                    }
                    u[l] = h(l);
                    f++
                } while (u[l] !== c); return d[l].slice(1)
            }
            vd.fastDiff = gd;
            function yd(t, e, n) {
                t.insertBefore(n, t.childNodes[e] || null)
            }
            function xd(t) {
                const e = t.parentNode;
                if (e) {
                    e.removeChild(t)
                }
            }
            function Cd(t) {
                if (t) {
                    if (t.defaultView) {
                        return t instanceof t.defaultView.Document
                    } else if (t.ownerDocument && t.ownerDocument.defaultView) {
                        return t instanceof t.ownerDocument.defaultView.Node
                    }
                }
                return false
            }
            class Ad {
                constructor(t, e) {
                    this.domDocuments = new Set;
                    this.domConverter = t;
                    this.markedAttributes = new Set;
                    this.markedChildren = new Set;
                    this.markedTexts = new Set;
                    this.selection = e;
                    this.isFocused = false;
                    this._inlineFiller = null;
                    this._fakeSelectionContainer = null
                }
                markToSync(t, e) {
                    if (t === "text") {
                        if (this.domConverter.mapViewToDom(e.parent)) {
                            this.markedTexts.add(e)
                        }
                    } else {
                        if (!this.domConverter.mapViewToDom(e)) {
                            return
                        }
                        if (t === "attributes") {
                            this.markedAttributes.add(e)
                        } else if (t === "children") {
                            this.markedChildren.add(e)
                        } else {
                            throw new rr["b"]("view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.", this)
                        }
                    }
                }
                render() {
                    let t;
                    for (const t of this.markedChildren) {
                        this._updateChildrenMappings(t)
                    }
                    if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
                        this._removeInlineFiller()
                    }
                    if (this._inlineFiller) {
                        t = this._getInlineFillerPosition()
                    } else if (this._needsInlineFillerAtSelection()) {
                        t = this.selection.getFirstPosition();
                        this.markedChildren.add(t.parent)
                    }
                    for (const t of this.markedAttributes) {
                        this._updateAttrs(t)
                    }
                    for (const e of this.markedChildren) {
                        this._updateChildren(e, {
                            inlineFillerPosition: t
                        })
                    }
                    for (const e of this.markedTexts) {
                        if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) {
                            this._updateText(e, {
                                inlineFillerPosition: t
                            })
                        }
                    }
                    if (t) {
                        const e = this.domConverter.viewPositionToDom(t);
                        const n = e.parent.ownerDocument;
                        if (!dd(e.parent)) {
                            this._inlineFiller = Td(n, e.parent, e.offset)
                        } else {
                            this._inlineFiller = e.parent
                        }
                    } else {
                        this._inlineFiller = null
                    }
                    this._updateSelection();
                    this._updateFocus();
                    this.markedTexts.clear();
                    this.markedAttributes.clear();
                    this.markedChildren.clear()
                }
                _updateChildrenMappings(t) {
                    const e = this.domConverter.mapViewToDom(t);
                    if (!e) {
                        return
                    }
                    const n = this.domConverter.mapViewToDom(t).childNodes;
                    const i = Array.from(this.domConverter.viewChildrenToDom(t, e.ownerDocument, {
                        withChildren: false
                    }));
                    const o = this._diffNodeLists(n, i);
                    const s = this._findReplaceActions(o, n, i);
                    if (s.indexOf("replace") !== -1) {
                        const e = {
                            equal: 0,
                            insert: 0,
                            delete: 0
                        };
                        for (const o of s) {
                            if (o === "replace") {
                                const o = e.equal + e.insert;
                                const s = e.equal + e.delete;
                                const r = t.getChild(o);
                                if (r && !r.is("uiElement")) {
                                    this._updateElementMappings(r, n[s])
                                }
                                xd(i[o]);
                                e.equal++
                            } else {
                                e[o]++
                            }
                        }
                    }
                }
                _updateElementMappings(t, e) {
                    this.domConverter.unbindDomElement(e);
                    this.domConverter.bindElements(e, t);
                    this.markedChildren.add(t);
                    this.markedAttributes.add(t)
                }
                _getInlineFillerPosition() {
                    const t = this.selection.getFirstPosition();
                    if (t.parent.is("text")) {
                        return ul._createBefore(this.selection.getFirstPosition().parent)
                    } else {
                        return t
                    }
                }
                _isSelectionInInlineFiller() {
                    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                        return false
                    }
                    const t = this.selection.getFirstPosition();
                    const e = this.domConverter.viewPositionToDom(t);
                    if (e && sd(e.parent) && dd(e.parent)) {
                        return true
                    }
                    return false
                }
                _removeInlineFiller() {
                    const t = this._inlineFiller;
                    if (!dd(t)) {
                        throw new rr["b"]("view-renderer-filler-was-lost: The inline filler node was lost.", this)
                    }
                    if (ud(t)) {
                        t.parentNode.removeChild(t)
                    } else {
                        t.data = t.data.substr(cd)
                    }
                    this._inlineFiller = null
                }
                _needsInlineFillerAtSelection() {
                    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                        return false
                    }
                    const t = this.selection.getFirstPosition();
                    const e = t.parent;
                    const n = t.offset;
                    if (!this.domConverter.mapViewToDom(e.root)) {
                        return false
                    }
                    if (!e.is("element")) {
                        return false
                    }
                    if (!Pd(e)) {
                        return false
                    }
                    if (n === e.getFillerOffset()) {
                        return false
                    }
                    const i = t.nodeBefore;
                    const o = t.nodeAfter;
                    if (i instanceof Dr || o instanceof Dr) {
                        return false
                    }
                    return true
                }
                _updateText(t, e) {
                    const n = this.domConverter.findCorrespondingDomText(t);
                    const i = this.domConverter.viewToDom(t, n.ownerDocument);
                    const o = n.data;
                    let s = i.data;
                    const r = e.inlineFillerPosition;
                    if (r && r.parent == t.parent && r.offset == t.index) {
                        s = ld + s
                    }
                    if (o != s) {
                        const t = gd(o, s);
                        for (const e of t) {
                            if (e.type === "insert") {
                                n.insertData(e.index, e.values.join(""))
                            } else {
                                n.deleteData(e.index, e.howMany)
                            }
                        }
                    }
                }
                _updateAttrs(t) {
                    const e = this.domConverter.mapViewToDom(t);
                    if (!e) {
                        return
                    }
                    const n = Array.from(e.attributes).map(t => t.name);
                    const i = t.getAttributeKeys();
                    for (const n of i) {
                        e.setAttribute(n, t.getAttribute(n))
                    }
                    for (const i of n) {
                        if (!t.hasAttribute(i)) {
                            e.removeAttribute(i)
                        }
                    }
                }
                _updateChildren(t, e) {
                    const n = this.domConverter.mapViewToDom(t);
                    if (!n) {
                        return
                    }
                    const i = e.inlineFillerPosition;
                    const o = this.domConverter.mapViewToDom(t).childNodes;
                    const s = Array.from(this.domConverter.viewChildrenToDom(t, n.ownerDocument, {
                        bind: true,
                        inlineFillerPosition: i
                    }));
                    if (i && i.parent === t) {
                        Td(n.ownerDocument, s, i.offset)
                    }
                    const r = this._diffNodeLists(o, s);
                    let a = 0;
                    const c = new Set;
                    for (const t of r) {
                        if (t === "insert") {
                            yd(n, a, s[a]);
                            a++
                        } else if (t === "delete") {
                            c.add(o[a]);
                            xd(o[a])
                        } else {
                            this._markDescendantTextToSync(this.domConverter.domToView(s[a]));
                            a++
                        }
                    }
                    for (const t of c) {
                        if (!t.parentNode) {
                            this.domConverter.unbindDomElement(t)
                        }
                    }
                }
                _diffNodeLists(t, e) {
                    t = Od(t, this._fakeSelectionContainer);
                    return vd(t, e, Ed.bind(null, this.domConverter))
                }
                _findReplaceActions(t, e, n) {
                    if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
                        return t
                    }
                    let i = [];
                    let o = [];
                    let s = [];
                    const r = {
                        equal: 0,
                        insert: 0,
                        delete: 0
                    };
                    for (const a of t) {
                        if (a === "insert") {
                            s.push(n[r.equal + r.insert])
                        } else if (a === "delete") {
                            o.push(e[r.equal + r.delete])
                        } else {
                            i = i.concat(vd(o, s, Sd).map(t => t === "equal" ? "replace" : t));
                            i.push("equal");
                            o = [];
                            s = []
                        }
                        r[a]++
                    }
                    return i.concat(vd(o, s, Sd).map(t => t === "equal" ? "replace" : t))
                }
                _markDescendantTextToSync(t) {
                    if (!t) {
                        return
                    }
                    if (t.is("text")) {
                        this.markedTexts.add(t)
                    } else if (t.is("element")) {
                        for (const e of t.getChildren()) {
                            this._markDescendantTextToSync(e)
                        }
                    }
                }
                _updateSelection() {
                    if (this.selection.rangeCount === 0) {
                        this._removeDomSelection();
                        this._removeFakeSelection();
                        return
                    }
                    const t = this.domConverter.mapViewToDom(this.selection.editableElement);
                    if (!this.isFocused || !t) {
                        return
                    }
                    if (this.selection.isFake) {
                        this._updateFakeSelection(t)
                    } else {
                        this._removeFakeSelection();
                        this._updateDomSelection(t)
                    }
                }
                _updateFakeSelection(t) {
                    const e = t.ownerDocument;
                    if (!this._fakeSelectionContainer) {
                        this._fakeSelectionContainer = Md(e)
                    }
                    const n = this._fakeSelectionContainer;
                    this.domConverter.bindFakeSelection(n, this.selection);
                    if (!this._fakeSelectionNeedsUpdate(t)) {
                        return
                    }
                    if (!n.parentElement || n.parentElement != t) {
                        t.appendChild(n)
                    }
                    n.textContent = this.selection.fakeSelectionLabel || " ";
                    const i = e.getSelection();
                    const o = e.createRange();
                    i.removeAllRanges();
                    o.selectNodeContents(n);
                    i.addRange(o)
                }
                _updateDomSelection(t) {
                    const e = t.ownerDocument.defaultView.getSelection();
                    if (!this._domSelectionNeedsUpdate(e)) {
                        return
                    }
                    const n = this.domConverter.viewPositionToDom(this.selection.anchor);
                    const i = this.domConverter.viewPositionToDom(this.selection.focus);
                    t.focus();
                    e.collapse(n.parent, n.offset);
                    e.extend(i.parent, i.offset);
                    if (Pl.isGecko) {
                        Rd(i, e)
                    }
                }
                _domSelectionNeedsUpdate(t) {
                    if (!this.domConverter.isDomSelectionCorrect(t)) {
                        return true
                    }
                    const e = t && this.domConverter.domSelectionToView(t);
                    if (e && this.selection.isEqual(e)) {
                        return false
                    }
                    if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
                        return false
                    }
                    return true
                }
                _fakeSelectionNeedsUpdate(t) {
                    const e = this._fakeSelectionContainer;
                    const n = t.ownerDocument.getSelection();
                    if (!e || e.parentElement !== t) {
                        return true
                    }
                    if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
                        return true
                    }
                    return e.textContent !== this.selection.fakeSelectionLabel
                }
                _removeDomSelection() {
                    for (const t of this.domDocuments) {
                        const e = t.getSelection();
                        if (e.rangeCount) {
                            const e = t.activeElement;
                            const n = this.domConverter.mapDomToView(e);
                            if (e && n) {
                                t.getSelection().removeAllRanges()
                            }
                        }
                    }
                }
                _removeFakeSelection() {
                    const t = this._fakeSelectionContainer;
                    if (t) {
                        t.remove()
                    }
                }
                _updateFocus() {
                    if (this.isFocused) {
                        const t = this.selection.editableElement;
                        if (t) {
                            this.domConverter.focus(t)
                        }
                    }
                }
            }
            vr(Ad, Jc);
            function Pd(t) {
                if (t.getAttribute("contenteditable") == "false") {
                    return false
                }
                const e = t.findAncestor(t => t.hasAttribute("contenteditable"));
                return !e || e.getAttribute("contenteditable") == "true"
            }
            function Td(t, e, n) {
                const i = e instanceof Array ? e : e.childNodes;
                const o = i[n];
                if (sd(o)) {
                    o.data = ld + o.data;
                    return o
                } else {
                    const o = t.createTextNode(ld);
                    if (Array.isArray(e)) {
                        i.splice(n, 0, o)
                    } else {
                        yd(e, n, o)
                    }
                    return o
                }
            }
            function Sd(t, e) {
                return Cd(t) && Cd(e) && !sd(t) && !sd(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase()
            }
            function Ed(t, e, n) {
                if (e === n) {
                    return true
                } else if (sd(e) && sd(n)) {
                    return e.data === n.data
                } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
                    return true
                }
                return false
            }
            function Rd(t, e) {
                const n = t.parent;
                if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) {
                    return
                }
                const i = n.childNodes[t.offset];
                if (i && i.tagName == "BR") {
                    e.addRange(e.getRangeAt(0))
                }
            }
            function Od(t, e) {
                const n = Array.from(t);
                if (n.length == 0 || !e) {
                    return n
                }
                const i = n[n.length - 1];
                if (i == e) {
                    n.pop()
                }
                return n
            }
            function Md(t) {
                const e = t.createElement("div");
                Object.assign(e.style, {
                    position: "fixed",
                    top: 0,
                    left: "-9999px",
                    width: "42px"
                });
                e.textContent = " ";
                return e
            }
            var Nd = {
                window: window,
                document: document
            };
            function Id(t) {
                let e = 0;
                while (t.previousSibling) {
                    t = t.previousSibling;
                    e++
                }
                return e
            }
            function Vd(t) {
                const e = [];
                while (t && t.nodeType != Node.DOCUMENT_NODE) {
                    e.unshift(t);
                    t = t.parentNode
                }
                return e
            }
            function Bd(t, e) {
                const n = Vd(t);
                const i = Vd(e);
                let o = 0;
                while (n[o] == i[o] && n[o]) {
                    o++
                }
                return o === 0 ? null : n[o - 1]
            }
            const Fd = ad(document);
            class Dd {
                constructor(t = {}) {
                    this.blockFillerMode = t.blockFillerMode || "br";
                    this.preElements = ["pre"];
                    this.blockElements = ["p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "li", "dd", "dt", "figcaption"];
                    this._blockFiller = this.blockFillerMode == "br" ? ad : rd;
                    this._domToViewMapping = new WeakMap;
                    this._viewToDomMapping = new WeakMap;
                    this._fakeSelectionMapping = new WeakMap
                }
                bindFakeSelection(t, e) {
                    this._fakeSelectionMapping.set(t, new gl(e))
                }
                fakeSelectionToView(t) {
                    return this._fakeSelectionMapping.get(t)
                }
                bindElements(t, e) {
                    this._domToViewMapping.set(t, e);
                    this._viewToDomMapping.set(e, t)
                }
                unbindDomElement(t) {
                    const e = this._domToViewMapping.get(t);
                    if (e) {
                        this._domToViewMapping.delete(t);
                        this._viewToDomMapping.delete(e);
                        for (const e of Array.from(t.childNodes)) {
                            this.unbindDomElement(e)
                        }
                    }
                }
                bindDocumentFragments(t, e) {
                    this._domToViewMapping.set(t, e);
                    this._viewToDomMapping.set(e, t)
                }
                viewToDom(t, e, n = {}) {
                    if (t.is("text")) {
                        const n = this._processDataFromViewText(t);
                        return e.createTextNode(n)
                    } else {
                        if (this.mapViewToDom(t)) {
                            return this.mapViewToDom(t)
                        }
                        let i;
                        if (t.is("documentFragment")) {
                            i = e.createDocumentFragment();
                            if (n.bind) {
                                this.bindDocumentFragments(i, t)
                            }
                        } else if (t.is("uiElement")) {
                            i = t.render(e);
                            if (n.bind) {
                                this.bindElements(i, t)
                            }
                            return i
                        } else {
                            if (t.hasAttribute("xmlns")) {
                                i = e.createElementNS(t.getAttribute("xmlns"), t.name)
                            } else {
                                i = e.createElement(t.name)
                            }
                            if (n.bind) {
                                this.bindElements(i, t)
                            }
                            for (const e of t.getAttributeKeys()) {
                                i.setAttribute(e, t.getAttribute(e))
                            }
                        }
                        if (n.withChildren || n.withChildren === undefined) {
                            for (const o of this.viewChildrenToDom(t, e, n)) {
                                i.appendChild(o)
                            }
                        }
                        return i
                    }
                }
                *viewChildrenToDom(t, e, n = {}) {
                    const i = t.getFillerOffset && t.getFillerOffset();
                    let o = 0;
                    for (const s of t.getChildren()) {
                        if (i === o) {
                            yield this._blockFiller(e)
                        }
                        yield this.viewToDom(s, e, n);
                        o++
                    }
                    if (i === o) {
                        yield this._blockFiller(e)
                    }
                }
                viewRangeToDom(t) {
                    const e = this.viewPositionToDom(t.start);
                    const n = this.viewPositionToDom(t.end);
                    const i = document.createRange();
                    i.setStart(e.parent, e.offset);
                    i.setEnd(n.parent, n.offset);
                    return i
                }
                viewPositionToDom(t) {
                    const e = t.parent;
                    if (e.is("text")) {
                        const n = this.findCorrespondingDomText(e);
                        if (!n) {
                            return null
                        }
                        let i = t.offset;
                        if (dd(n)) {
                            i += cd
                        }
                        return {
                            parent: n,
                            offset: i
                        }
                    } else {
                        let n, i, o;
                        if (t.offset === 0) {
                            n = this.mapViewToDom(e);
                            if (!n) {
                                return null
                            }
                            o = n.childNodes[0]
                        } else {
                            const e = t.nodeBefore;
                            i = e.is("text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(t.nodeBefore);
                            if (!i) {
                                return null
                            }
                            n = i.parentNode;
                            o = i.nextSibling
                        }
                        if (sd(o) && dd(o)) {
                            return {
                                parent: o,
                                offset: cd
                            }
                        }
                        const s = i ? Id(i) + 1 : 0;
                        return {
                            parent: n,
                            offset: s
                        }
                    }
                }
                domToView(t, e = {}) {
                    if (this.isBlockFiller(t, this.blockFillerMode)) {
                        return null
                    }
                    const n = this.getParentUIElement(t, this._domToViewMapping);
                    if (n) {
                        return n
                    }
                    if (sd(t)) {
                        if (ud(t)) {
                            return null
                        } else {
                            const e = this._processDataFromDomText(t);
                            return e === "" ? null : new Dr(e)
                        }
                    } else if (this.isComment(t)) {
                        return null
                    } else {
                        if (this.mapDomToView(t)) {
                            return this.mapDomToView(t)
                        }
                        let n;
                        if (this.isDocumentFragment(t)) {
                            n = new Ul;
                            if (e.bind) {
                                this.bindDocumentFragments(t, n)
                            }
                        } else {
                            const i = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                            n = new Fc(i);
                            if (e.bind) {
                                this.bindElements(t, n)
                            }
                            const o = t.attributes;
                            for (let t = o.length - 1; t >= 0; t--) {
                                n._setAttribute(o[t].name, o[t].value)
                            }
                        }
                        if (e.withChildren || e.withChildren === undefined) {
                            for (const i of this.domChildrenToView(t, e)) {
                                n._appendChild(i)
                            }
                        }
                        return n
                    }
                }
                *domChildrenToView(t, e = {}) {
                    for (let n = 0; n < t.childNodes.length; n++) {
                        const i = t.childNodes[n];
                        const o = this.domToView(i, e);
                        if (o !== null) {
                            yield o
                        }
                    }
                }
                domSelectionToView(t) {
                    if (t.rangeCount === 1) {
                        let e = t.getRangeAt(0).startContainer;
                        if (sd(e)) {
                            e = e.parentNode
                        }
                        const n = this.fakeSelectionToView(e);
                        if (n) {
                            return n
                        }
                    }
                    const e = this.isDomSelectionBackward(t);
                    const n = [];
                    for (let e = 0; e < t.rangeCount; e++) {
                        const i = t.getRangeAt(e);
                        const o = this.domRangeToView(i);
                        if (o) {
                            n.push(o)
                        }
                    }
                    return new gl(n, {
                        backward: e
                    })
                }
                domRangeToView(t) {
                    const e = this.domPositionToView(t.startContainer, t.startOffset);
                    const n = this.domPositionToView(t.endContainer, t.endOffset);
                    if (e && n) {
                        return new hl(e, n)
                    }
                    return null
                }
                domPositionToView(t, e) {
                    if (this.isBlockFiller(t, this.blockFillerMode)) {
                        return this.domPositionToView(t.parentNode, Id(t))
                    }
                    const n = this.mapDomToView(t);
                    if (n && n.is("uiElement")) {
                        return ul._createBefore(n)
                    }
                    if (sd(t)) {
                        if (ud(t)) {
                            return this.domPositionToView(t.parentNode, Id(t))
                        }
                        const n = this.findCorrespondingViewText(t);
                        let i = e;
                        if (!n) {
                            return null
                        }
                        if (dd(t)) {
                            i -= cd;
                            i = i < 0 ? 0 : i
                        }
                        return new ul(n, i)
                    } else {
                        if (e === 0) {
                            const e = this.mapDomToView(t);
                            if (e) {
                                return new ul(e, 0)
                            }
                        } else {
                            const n = t.childNodes[e - 1];
                            const i = sd(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
                            if (i && i.parent) {
                                return new ul(i.parent, i.index + 1)
                            }
                        }
                        return null
                    }
                }
                mapDomToView(t) {
                    return this.getParentUIElement(t) || this._domToViewMapping.get(t)
                }
                findCorrespondingViewText(t) {
                    if (ud(t)) {
                        return null
                    }
                    const e = this.getParentUIElement(t);
                    if (e) {
                        return e
                    }
                    const n = t.previousSibling;
                    if (n) {
                        if (!this.isElement(n)) {
                            return null
                        }
                        const t = this.mapDomToView(n);
                        if (t) {
                            const e = t.nextSibling;
                            if (e instanceof Dr) {
                                return t.nextSibling
                            } else {
                                return null
                            }
                        }
                    } else {
                        const e = this.mapDomToView(t.parentNode);
                        if (e) {
                            const t = e.getChild(0);
                            if (t instanceof Dr) {
                                return t
                            } else {
                                return null
                            }
                        }
                    }
                    return null
                }
                mapViewToDom(t) {
                    return this._viewToDomMapping.get(t)
                }
                findCorrespondingDomText(t) {
                    const e = t.previousSibling;
                    if (e && this.mapViewToDom(e)) {
                        return this.mapViewToDom(e).nextSibling
                    }
                    if (!e && t.parent && this.mapViewToDom(t.parent)) {
                        return this.mapViewToDom(t.parent).childNodes[0]
                    }
                    return null
                }
                focus(t) {
                    const e = this.mapViewToDom(t);
                    if (e && e.ownerDocument.activeElement !== e) {
                        const { scrollX: t, scrollY: n } = Nd.window;
                        const i = [];
                        Ld(e, t => {
                            const { scrollLeft: e, scrollTop: n } = t;
                            i.push([e, n])
                        }
                        );
                        e.focus();
                        Ld(e, t => {
                            const [e, n] = i.shift();
                            t.scrollLeft = e;
                            t.scrollTop = n
                        }
                        );
                        Nd.window.scrollTo(t, n)
                    }
                }
                isElement(t) {
                    return t && t.nodeType == Node.ELEMENT_NODE
                }
                isDocumentFragment(t) {
                    return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
                }
                isComment(t) {
                    return t && t.nodeType == Node.COMMENT_NODE
                }
                isBlockFiller(t) {
                    if (this.blockFillerMode == "br") {
                        return t.isEqualNode(Fd)
                    }
                    if (t.tagName === "BR" && Hd(t, this.blockElements) && t.parentNode.childNodes.length === 1) {
                        return true
                    }
                    return jd(t, this.blockElements)
                }
                isDomSelectionBackward(t) {
                    if (t.isCollapsed) {
                        return false
                    }
                    const e = document.createRange();
                    e.setStart(t.anchorNode, t.anchorOffset);
                    e.setEnd(t.focusNode, t.focusOffset);
                    const n = e.collapsed;
                    e.detach();
                    return n
                }
                getParentUIElement(t) {
                    const e = Vd(t);
                    e.pop();
                    while (e.length) {
                        const t = e.pop();
                        const n = this._domToViewMapping.get(t);
                        if (n && n.is("uiElement")) {
                            return n
                        }
                    }
                    return null
                }
                isDomSelectionCorrect(t) {
                    return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
                }
                _isDomSelectionPositionCorrect(t, e) {
                    if (sd(t) && dd(t) && e < cd) {
                        return false
                    }
                    if (this.isElement(t) && dd(t.childNodes[e])) {
                        return false
                    }
                    const n = this.mapDomToView(t);
                    if (n && n.is("uiElement")) {
                        return false
                    }
                    return true
                }
                _processDataFromViewText(t) {
                    let e = t.data;
                    if (t.getAncestors().some(t => this.preElements.includes(t.name))) {
                        return e
                    }
                    if (e.charAt(0) == " ") {
                        const n = this._getTouchingViewTextNode(t, false);
                        const i = n && this._nodeEndsWithSpace(n);
                        if (i || !n) {
                            e = " " + e.substr(1)
                        }
                    }
                    if (e.charAt(e.length - 1) == " ") {
                        const n = this._getTouchingViewTextNode(t, true);
                        if (e.charAt(e.length - 2) == " " || !n || n.data.charAt(0) == " ") {
                            e = e.substr(0, e.length - 1) + " "
                        }
                    }
                    return e.replace(/ {2}/g, "  ")
                }
                _nodeEndsWithSpace(t) {
                    if (t.getAncestors().some(t => this.preElements.includes(t.name))) {
                        return false
                    }
                    const e = this._processDataFromViewText(t);
                    return e.charAt(e.length - 1) == " "
                }
                _processDataFromDomText(t) {
                    let e = t.data;
                    if (zd(t, this.preElements)) {
                        return hd(t)
                    }
                    e = e.replace(/[ \n\t\r]{1,}/g, " ");
                    const n = this._getTouchingInlineDomNode(t, false);
                    const i = this._getTouchingInlineDomNode(t, true);
                    const o = this._checkShouldLeftTrimDomText(n);
                    const s = this._checkShouldRightTrimDomText(t, i);
                    if (o) {
                        e = e.replace(/^ /, "")
                    }
                    if (s) {
                        e = e.replace(/ $/, "")
                    }
                    e = hd(new Text(e));
                    e = e.replace(/ \u00A0/g, "  ");
                    if (/( |\u00A0)\u00A0$/.test(e) || !i || i.data && i.data.charAt(0) == " ") {
                        e = e.replace(/\u00A0$/, " ")
                    }
                    if (o) {
                        e = e.replace(/^\u00A0/, " ")
                    }
                    return e
                }
                _checkShouldLeftTrimDomText(t) {
                    if (!t) {
                        return true
                    }
                    if (Ks(t)) {
                        return true
                    }
                    return /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1))
                }
                _checkShouldRightTrimDomText(t, e) {
                    if (e) {
                        return false
                    }
                    return !dd(t)
                }
                _getTouchingViewTextNode(t, e) {
                    const n = new dl({
                        startPosition: e ? ul._createAfter(t) : ul._createBefore(t),
                        direction: e ? "forward" : "backward"
                    });
                    for (const t of n) {
                        if (t.item.is("containerElement")) {
                            return null
                        } else if (t.item.is("br")) {
                            return null
                        } else if (t.item.is("textProxy")) {
                            return t.item
                        }
                    }
                    return null
                }
                _getTouchingInlineDomNode(t, e) {
                    if (!t.parentNode) {
                        return null
                    }
                    const n = e ? "nextNode" : "previousNode";
                    const i = t.ownerDocument;
                    const o = Vd(t)[0];
                    const s = i.createTreeWalker(o, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {
                        acceptNode(t) {
                            if (sd(t)) {
                                return NodeFilter.FILTER_ACCEPT
                            }
                            if (t.tagName == "BR") {
                                return NodeFilter.FILTER_ACCEPT
                            }
                            return NodeFilter.FILTER_SKIP
                        }
                    });
                    s.currentNode = t;
                    const r = s[n]();
                    if (r !== null) {
                        const e = Bd(t, r);
                        if (e && !zd(t, this.blockElements, e) && !zd(r, this.blockElements, e)) {
                            return r
                        }
                    }
                    return null
                }
            }
            function zd(t, e, n) {
                let i = Vd(t);
                if (n) {
                    i = i.slice(i.indexOf(n) + 1)
                }
                return i.some(t => t.tagName && e.includes(t.tagName.toLowerCase()))
            }
            function Ld(t, e) {
                while (t && t != Nd.document) {
                    e(t);
                    t = t.parentNode
                }
            }
            function jd(t, e) {
                const n = sd(t) && t.data == " ";
                return n && Hd(t, e) && t.parentNode.childNodes.length === 1
            }
            function Hd(t, e) {
                const n = t.parentNode;
                return n && n.tagName && e.includes(n.tagName.toLowerCase())
            }
            function qd(t) {
                const e = Object.prototype.toString.apply(t);
                if (e == "[object Window]") {
                    return true
                }
                if (e == "[object global]") {
                    return true
                }
                return false
            }
            const Wd = Wc({}, dr, {
                listenTo(t, ...e) {
                    if (Cd(t) || qd(t)) {
                        const n = this._getProxyEmitter(t) || new $d(t);
                        n.attach(...e);
                        t = n
                    }
                    dr.listenTo.call(this, t, ...e)
                },
                stopListening(t, e, n) {
                    if (Cd(t) || qd(t)) {
                        const e = this._getProxyEmitter(t);
                        if (!e) {
                            return
                        }
                        t = e
                    }
                    dr.stopListening.call(this, t, e, n);
                    if (t instanceof $d) {
                        t.detach(e)
                    }
                },
                _getProxyEmitter(t) {
                    return ur(this, Gd(t))
                }
            });
            var Ud = Wd;
            class $d {
                constructor(t) {
                    hr(this, Gd(t));
                    this._domNode = t
                }
            }
            Wc($d.prototype, dr, {
                attach(t, e, n = {}) {
                    if (this._domListeners && this._domListeners[t]) {
                        return
                    }
                    const i = this._createDomListener(t, !!n.useCapture);
                    this._domNode.addEventListener(t, i, !!n.useCapture);
                    if (!this._domListeners) {
                        this._domListeners = {}
                    }
                    this._domListeners[t] = i
                },
                detach(t) {
                    let e;
                    if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) {
                        this._domListeners[t].removeListener()
                    }
                },
                _createDomListener(t, e) {
                    const n = e => {
                        this.fire(t, e)
                    }
                        ;
                    n.removeListener = () => {
                        this._domNode.removeEventListener(t, n, e);
                        delete this._domListeners[t]
                    }
                        ;
                    return n
                }
            });
            function Gd(t) {
                return t["data-ck-expando"] || (t["data-ck-expando"] = nr())
            }
            class Kd {
                constructor(t) {
                    this.view = t;
                    this.document = t.document;
                    this.isEnabled = false
                }
                enable() {
                    this.isEnabled = true
                }
                disable() {
                    this.isEnabled = false
                }
                destroy() {
                    this.disable();
                    this.stopListening()
                }
            }
            vr(Kd, Ud);
            var Jd = "__lodash_hash_undefined__";
            function Qd(t) {
                this.__data__.set(t, Jd);
                return this
            }
            var Yd = Qd;
            function Xd(t) {
                return this.__data__.has(t)
            }
            var Zd = Xd;
            function tu(t) {
                var e = -1
                    , n = t == null ? 0 : t.length;
                this.__data__ = new _e;
                while (++e < n) {
                    this.add(t[e])
                }
            }
            tu.prototype.add = tu.prototype.push = Yd;
            tu.prototype.has = Zd;
            var eu = tu;
            function nu(t, e) {
                var n = -1
                    , i = t == null ? 0 : t.length;
                while (++n < i) {
                    if (e(t[n], n, t)) {
                        return true
                    }
                }
                return false
            }
            var iu = nu;
            function ou(t, e) {
                return t.has(e)
            }
            var su = ou;
            var ru = 1
                , au = 2;
            function cu(t, e, n, i, o, s) {
                var r = n & ru
                    , a = t.length
                    , c = e.length;
                if (a != c && !(r && c > a)) {
                    return false
                }
                var l = s.get(t);
                if (l && s.get(e)) {
                    return l == e
                }
                var d = -1
                    , u = true
                    , h = n & au ? new eu : undefined;
                s.set(t, e);
                s.set(e, t);
                while (++d < a) {
                    var f = t[d]
                        , p = e[d];
                    if (i) {
                        var g = r ? i(p, f, d, e, t, s) : i(f, p, d, t, e, s)
                    }
                    if (g !== undefined) {
                        if (g) {
                            continue
                        }
                        u = false;
                        break
                    }
                    if (h) {
                        if (!iu(e, (function (t, e) {
                            if (!su(h, e) && (f === t || o(f, t, n, i, s))) {
                                return h.push(e)
                            }
                        }
                        ))) {
                            u = false;
                            break
                        }
                    } else if (!(f === p || o(f, p, n, i, s))) {
                        u = false;
                        break
                    }
                }
                s["delete"](t);
                s["delete"](e);
                return u
            }
            var lu = cu;
            function du(t) {
                var e = -1
                    , n = Array(t.size);
                t.forEach((function (t, i) {
                    n[++e] = [i, t]
                }
                ));
                return n
            }
            var uu = du;
            function hu(t) {
                var e = -1
                    , n = Array(t.size);
                t.forEach((function (t) {
                    n[++e] = t
                }
                ));
                return n
            }
            var fu = hu;
            var pu = 1
                , gu = 2;
            var mu = "[object Boolean]"
                , bu = "[object Date]"
                , wu = "[object Error]"
                , ku = "[object Map]"
                , _u = "[object Number]"
                , vu = "[object RegExp]"
                , yu = "[object Set]"
                , xu = "[object String]"
                , Cu = "[object Symbol]";
            var Au = "[object ArrayBuffer]"
                , Pu = "[object DataView]";
            var Tu = s ? s.prototype : undefined
                , Su = Tu ? Tu.valueOf : undefined;
            function Eu(t, e, n, i, o, s, r) {
                switch (n) {
                    case Pu:
                        if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
                            return false
                        }
                        t = t.buffer;
                        e = e.buffer;
                    case Au:
                        if (t.byteLength != e.byteLength || !s(new fo(t), new fo(e))) {
                            return false
                        }
                        return true;
                    case mu:
                    case bu:
                    case _u:
                        return D(+t, +e);
                    case wu:
                        return t.name == e.name && t.message == e.message;
                    case vu:
                    case xu:
                        return t == e + "";
                    case ku:
                        var a = uu;
                    case yu:
                        var c = i & pu;
                        a || (a = fu);
                        if (t.size != e.size && !c) {
                            return false
                        }
                        var l = r.get(t);
                        if (l) {
                            return l == e
                        }
                        i |= gu;
                        r.set(t, e);
                        var d = lu(a(t), a(e), i, o, s, r);
                        r["delete"](t);
                        return d;
                    case Cu:
                        if (Su) {
                            return Su.call(t) == Su.call(e)
                        }
                }
                return false
            }
            var Ru = Eu;
            var Ou = 1;
            var Mu = Object.prototype;
            var Nu = Mu.hasOwnProperty;
            function Iu(t, e, n, i, o, s) {
                var r = n & Ou
                    , a = Fi(t)
                    , c = a.length
                    , l = Fi(e)
                    , d = l.length;
                if (c != d && !r) {
                    return false
                }
                var u = c;
                while (u--) {
                    var h = a[u];
                    if (!(r ? h in e : Nu.call(e, h))) {
                        return false
                    }
                }
                var f = s.get(t);
                if (f && s.get(e)) {
                    return f == e
                }
                var p = true;
                s.set(t, e);
                s.set(e, t);
                var g = r;
                while (++u < c) {
                    h = a[u];
                    var m = t[h]
                        , b = e[h];
                    if (i) {
                        var w = r ? i(b, m, h, e, t, s) : i(m, b, h, t, e, s)
                    }
                    if (!(w === undefined ? m === b || o(m, b, n, i, s) : w)) {
                        p = false;
                        break
                    }
                    g || (g = h == "constructor")
                }
                if (p && !g) {
                    var k = t.constructor
                        , _ = e.constructor;
                    if (k != _ && ("constructor" in t && "constructor" in e) && !(typeof k == "function" && k instanceof k && typeof _ == "function" && _ instanceof _)) {
                        p = false
                    }
                }
                s["delete"](t);
                s["delete"](e);
                return p
            }
            var Vu = Iu;
            var Bu = 1;
            var Fu = "[object Arguments]"
                , Du = "[object Array]"
                , zu = "[object Object]";
            var Lu = Object.prototype;
            var ju = Lu.hasOwnProperty;
            function Hu(t, e, n, i, o, s) {
                var r = Je(t)
                    , a = Je(e)
                    , c = r ? Du : ro(t)
                    , l = a ? Du : ro(e);
                c = c == Fu ? zu : c;
                l = l == Fu ? zu : l;
                var d = c == zu
                    , u = l == zu
                    , h = c == l;
                if (h && Object(Qe["a"])(t)) {
                    if (!Object(Qe["a"])(e)) {
                        return false
                    }
                    r = true;
                    d = false
                }
                if (h && !d) {
                    s || (s = new Ae);
                    return r || Fn(t) ? lu(t, e, n, i, o, s) : Ru(t, e, c, n, i, o, s)
                }
                if (!(n & Bu)) {
                    var f = d && ju.call(t, "__wrapped__")
                        , p = u && ju.call(e, "__wrapped__");
                    if (f || p) {
                        var g = f ? t.value() : t
                            , m = p ? e.value() : e;
                        s || (s = new Ae);
                        return o(g, m, n, i, s)
                    }
                }
                if (!h) {
                    return false
                }
                s || (s = new Ae);
                return Vu(t, e, n, i, o, s)
            }
            var qu = Hu;
            function Wu(t, e, n, i, o) {
                if (t === e) {
                    return true
                }
                if (t == null || e == null || !P(t) && !P(e)) {
                    return t !== t && e !== e
                }
                return qu(t, e, n, i, Wu, o)
            }
            var Uu = Wu;
            function $u(t, e, n) {
                n = typeof n == "function" ? n : undefined;
                var i = n ? n(t, e) : undefined;
                return i === undefined ? Uu(t, e, undefined, n) : !!i
            }
            var Gu = $u;
            class Ku extends Kd {
                constructor(t) {
                    super(t);
                    this._config = {
                        childList: true,
                        characterData: true,
                        characterDataOldValue: true,
                        subtree: true
                    };
                    this.domConverter = t.domConverter;
                    this.renderer = t._renderer;
                    this._domElements = [];
                    this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
                }
                flush() {
                    this._onMutations(this._mutationObserver.takeRecords())
                }
                observe(t) {
                    this._domElements.push(t);
                    if (this.isEnabled) {
                        this._mutationObserver.observe(t, this._config)
                    }
                }
                enable() {
                    super.enable();
                    for (const t of this._domElements) {
                        this._mutationObserver.observe(t, this._config)
                    }
                }
                disable() {
                    super.disable();
                    this._mutationObserver.disconnect()
                }
                destroy() {
                    super.destroy();
                    this._mutationObserver.disconnect()
                }
                _onMutations(t) {
                    if (t.length === 0) {
                        return
                    }
                    const e = this.domConverter;
                    const n = new Map;
                    const i = new Set;
                    for (const n of t) {
                        if (n.type === "childList") {
                            const t = e.mapDomToView(n.target);
                            if (t && t.is("uiElement")) {
                                continue
                            }
                            if (t && !this._isBogusBrMutation(n)) {
                                i.add(t)
                            }
                        }
                    }
                    for (const o of t) {
                        const t = e.mapDomToView(o.target);
                        if (t && t.is("uiElement")) {
                            continue
                        }
                        if (o.type === "characterData") {
                            const t = e.findCorrespondingViewText(o.target);
                            if (t && !i.has(t.parent)) {
                                n.set(t, {
                                    type: "text",
                                    oldText: t.data,
                                    newText: hd(o.target),
                                    node: t
                                })
                            } else if (!t && dd(o.target)) {
                                i.add(e.mapDomToView(o.target.parentNode))
                            }
                        }
                    }
                    const o = [];
                    for (const t of n.values()) {
                        this.renderer.markToSync("text", t.node);
                        o.push(t)
                    }
                    for (const t of i) {
                        const n = e.mapViewToDom(t);
                        const i = Array.from(t.getChildren());
                        const s = Array.from(e.domChildrenToView(n, {
                            withChildren: false
                        }));
                        if (!Gu(i, s, a)) {
                            this.renderer.markToSync("children", t);
                            o.push({
                                type: "children",
                                oldChildren: i,
                                newChildren: s,
                                node: t
                            })
                        }
                    }
                    const s = t[0].target.ownerDocument.getSelection();
                    let r = null;
                    if (s && s.anchorNode) {
                        const t = e.domPositionToView(s.anchorNode, s.anchorOffset);
                        const n = e.domPositionToView(s.focusNode, s.focusOffset);
                        if (t && n) {
                            r = new gl(t);
                            r.setFocus(n)
                        }
                    }
                    if (o.length) {
                        this.document.fire("mutations", o, r);
                        this.view.forceRender()
                    }
                    function a(t, e) {
                        if (Array.isArray(t)) {
                            return
                        }
                        if (t === e) {
                            return true
                        } else if (t.is("text") && e.is("text")) {
                            return t.data === e.data
                        }
                        return false
                    }
                }
                _isBogusBrMutation(t) {
                    let e = null;
                    if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) {
                        e = this.domConverter.domToView(t.addedNodes[0], {
                            withChildren: false
                        })
                    }
                    return e && e.is("element", "br")
                }
            }
            class Ju {
                constructor(t, e, n) {
                    this.view = t;
                    this.document = t.document;
                    this.domEvent = e;
                    this.domTarget = e.target;
                    Wc(this, n)
                }
                get target() {
                    return this.view.domConverter.mapDomToView(this.domTarget)
                }
                preventDefault() {
                    this.domEvent.preventDefault()
                }
                stopPropagation() {
                    this.domEvent.stopPropagation()
                }
            }
            class Qu extends Kd {
                constructor(t) {
                    super(t);
                    this.useCapture = false
                }
                observe(t) {
                    const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
                    e.forEach(e => {
                        this.listenTo(t, e, (t, e) => {
                            if (this.isEnabled) {
                                this.onDomEvent(e)
                            }
                        }
                            , {
                                useCapture: this.useCapture
                            })
                    }
                    )
                }
                fire(t, e, n) {
                    if (this.isEnabled) {
                        this.document.fire(t, new Ju(this.view, e, n))
                    }
                }
            }
            class Yu extends Qu {
                constructor(t) {
                    super(t);
                    this.domEventType = ["keydown", "keyup"]
                }
                onDomEvent(t) {
                    this.fire(t.type, t, {
                        keyCode: t.keyCode,
                        altKey: t.altKey,
                        ctrlKey: t.ctrlKey || t.metaKey,
                        shiftKey: t.shiftKey,
                        get keystroke() {
                            return Bl(this)
                        }
                    })
                }
            }
            var Xu = function () {
                return i["a"].Date.now()
            };
            var Zu = Xu;
            var th = 0 / 0;
            var eh = /^\s+|\s+$/g;
            var nh = /^[-+]0x[0-9a-f]+$/i;
            var ih = /^0b[01]+$/i;
            var oh = /^0o[0-7]+$/i;
            var sh = parseInt;
            function rh(t) {
                if (typeof t == "number") {
                    return t
                }
                if (Yr(t)) {
                    return th
                }
                if (ct(t)) {
                    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
                    t = ct(e) ? e + "" : e
                }
                if (typeof t != "string") {
                    return t === 0 ? t : +t
                }
                t = t.replace(eh, "");
                var n = ih.test(t);
                return n || oh.test(t) ? sh(t.slice(2), n ? 2 : 8) : nh.test(t) ? th : +t
            }
            var ah = rh;
            var ch = "Expected a function";
            var lh = Math.max
                , dh = Math.min;
            function uh(t, e, n) {
                var i, o, s, r, a, c, l = 0, d = false, u = false, h = true;
                if (typeof t != "function") {
                    throw new TypeError(ch)
                }
                e = ah(e) || 0;
                if (ct(n)) {
                    d = !!n.leading;
                    u = "maxWait" in n;
                    s = u ? lh(ah(n.maxWait) || 0, e) : s;
                    h = "trailing" in n ? !!n.trailing : h
                }
                function f(e) {
                    var n = i
                        , s = o;
                    i = o = undefined;
                    l = e;
                    r = t.apply(s, n);
                    return r
                }
                function p(t) {
                    l = t;
                    a = setTimeout(b, e);
                    return d ? f(t) : r
                }
                function g(t) {
                    var n = t - c
                        , i = t - l
                        , o = e - n;
                    return u ? dh(o, s - i) : o
                }
                function m(t) {
                    var n = t - c
                        , i = t - l;
                    return c === undefined || n >= e || n < 0 || u && i >= s
                }
                function b() {
                    var t = Zu();
                    if (m(t)) {
                        return w(t)
                    }
                    a = setTimeout(b, g(t))
                }
                function w(t) {
                    a = undefined;
                    if (h && i) {
                        return f(t)
                    }
                    i = o = undefined;
                    return r
                }
                function k() {
                    if (a !== undefined) {
                        clearTimeout(a)
                    }
                    l = 0;
                    i = c = o = a = undefined
                }
                function _() {
                    return a === undefined ? r : w(Zu())
                }
                function v() {
                    var t = Zu()
                        , n = m(t);
                    i = arguments;
                    o = this;
                    c = t;
                    if (n) {
                        if (a === undefined) {
                            return p(c)
                        }
                        if (u) {
                            clearTimeout(a);
                            a = setTimeout(b, e);
                            return f(c)
                        }
                    }
                    if (a === undefined) {
                        a = setTimeout(b, e)
                    }
                    return r
                }
                v.cancel = k;
                v.flush = _;
                return v
            }
            var hh = uh;
            class fh extends Kd {
                constructor(t) {
                    super(t);
                    this._fireSelectionChangeDoneDebounced = hh(t => this.document.fire("selectionChangeDone", t), 200)
                }
                observe() {
                    const t = this.document;
                    t.on("keydown", (e, n) => {
                        const i = t.selection;
                        if (i.isFake && ph(n.keyCode) && this.isEnabled) {
                            n.preventDefault();
                            this._handleSelectionMove(n.keyCode)
                        }
                    }
                        , {
                            priority: "lowest"
                        })
                }
                destroy() {
                    super.destroy();
                    this._fireSelectionChangeDoneDebounced.cancel()
                }
                _handleSelectionMove(t) {
                    const e = this.document.selection;
                    const n = new gl(e.getRanges(), {
                        backward: e.isBackward,
                        fake: false
                    });
                    if (t == Vl.arrowleft || t == Vl.arrowup) {
                        n.setTo(n.getFirstPosition())
                    }
                    if (t == Vl.arrowright || t == Vl.arrowdown) {
                        n.setTo(n.getLastPosition())
                    }
                    const i = {
                        oldSelection: e,
                        newSelection: n,
                        domSelection: null
                    };
                    this.document.fire("selectionChange", i);
                    this._fireSelectionChangeDoneDebounced(i)
                }
            }
            function ph(t) {
                return t == Vl.arrowright || t == Vl.arrowleft || t == Vl.arrowup || t == Vl.arrowdown
            }
            class gh extends Kd {
                constructor(t) {
                    super(t);
                    this.mutationObserver = t.getObserver(Ku);
                    this.selection = this.document.selection;
                    this.domConverter = t.domConverter;
                    this._documents = new WeakSet;
                    this._fireSelectionChangeDoneDebounced = hh(t => this.document.fire("selectionChangeDone", t), 200);
                    this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
                    this._loopbackCounter = 0
                }
                observe(t) {
                    const e = t.ownerDocument;
                    if (this._documents.has(e)) {
                        return
                    }
                    this.listenTo(e, "selectionchange", () => {
                        this._handleSelectionChange(e)
                    }
                    );
                    this._documents.add(e)
                }
                destroy() {
                    super.destroy();
                    clearInterval(this._clearInfiniteLoopInterval);
                    this._fireSelectionChangeDoneDebounced.cancel()
                }
                _handleSelectionChange(t) {
                    if (!this.isEnabled) {
                        return
                    }
                    this.mutationObserver.flush();
                    const e = t.defaultView.getSelection();
                    const n = this.domConverter.domSelectionToView(e);
                    if (n.rangeCount == 0) {
                        return
                    }
                    if (this.selection.isEqual(n) && this.domConverter.isDomSelectionCorrect(e)) {
                        return
                    }
                    if (++this._loopbackCounter > 60) {
                        return
                    }
                    if (this.selection.isSimilar(n)) {
                        this.view.forceRender()
                    } else {
                        const t = {
                            oldSelection: this.selection,
                            newSelection: n,
                            domSelection: e
                        };
                        this.document.fire("selectionChange", t);
                        this._fireSelectionChangeDoneDebounced(t)
                    }
                }
                _clearInfiniteLoop() {
                    this._loopbackCounter = 0
                }
            }
            class mh extends Qu {
                constructor(t) {
                    super(t);
                    this.domEventType = ["focus", "blur"];
                    this.useCapture = true;
                    const e = this.document;
                    e.on("focus", () => {
                        e.isFocused = true;
                        this._renderTimeoutId = setTimeout(() => t.forceRender(), 50)
                    }
                    );
                    e.on("blur", (n, i) => {
                        const o = e.selection.editableElement;
                        if (o === null || o === i.target) {
                            e.isFocused = false;
                            t.forceRender()
                        }
                    }
                    )
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
                destroy() {
                    if (this._renderTimeoutId) {
                        clearTimeout(this._renderTimeoutId)
                    }
                    super.destroy()
                }
            }
            class bh extends Qu {
                constructor(t) {
                    super(t);
                    this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
                    const e = this.document;
                    e.on("compositionstart", () => {
                        e.isComposing = true
                    }
                    );
                    e.on("compositionend", () => {
                        e.isComposing = false
                    }
                    )
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
            }
            class wh extends Qu {
                constructor(t) {
                    super(t);
                    this.domEventType = ["beforeinput"]
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
            }
            function kh(t) {
                return Object.prototype.toString.apply(t) == "[object Range]"
            }
            function _h(t) {
                const e = t.ownerDocument.defaultView.getComputedStyle(t);
                return {
                    top: parseInt(e.borderTopWidth, 10),
                    right: parseInt(e.borderRightWidth, 10),
                    bottom: parseInt(e.borderBottomWidth, 10),
                    left: parseInt(e.borderLeftWidth, 10)
                }
            }
            const vh = ["top", "right", "bottom", "left", "width", "height"];
            class yh {
                constructor(t) {
                    const e = kh(t);
                    Object.defineProperty(this, "_source", {
                        value: t._source || t,
                        writable: true,
                        enumerable: false
                    });
                    if (Ks(t) || e) {
                        if (e) {
                            xh(this, yh.getDomRangeRects(t)[0])
                        } else {
                            xh(this, t.getBoundingClientRect())
                        }
                    } else if (qd(t)) {
                        const { innerWidth: e, innerHeight: n } = t;
                        xh(this, {
                            top: 0,
                            right: e,
                            bottom: n,
                            left: 0,
                            width: e,
                            height: n
                        })
                    } else {
                        xh(this, t)
                    }
                }
                clone() {
                    return new yh(this)
                }
                moveTo(t, e) {
                    this.top = e;
                    this.right = t + this.width;
                    this.bottom = e + this.height;
                    this.left = t;
                    return this
                }
                moveBy(t, e) {
                    this.top += e;
                    this.right += t;
                    this.left += t;
                    this.bottom += e;
                    return this
                }
                getIntersection(t) {
                    const e = {
                        top: Math.max(this.top, t.top),
                        right: Math.min(this.right, t.right),
                        bottom: Math.min(this.bottom, t.bottom),
                        left: Math.max(this.left, t.left)
                    };
                    e.width = e.right - e.left;
                    e.height = e.bottom - e.top;
                    if (e.width < 0 || e.height < 0) {
                        return null
                    } else {
                        return new yh(e)
                    }
                }
                getIntersectionArea(t) {
                    const e = this.getIntersection(t);
                    if (e) {
                        return e.getArea()
                    } else {
                        return 0
                    }
                }
                getArea() {
                    return this.width * this.height
                }
                getVisible() {
                    const t = this._source;
                    let e = this.clone();
                    if (!Ch(t)) {
                        let n = t.parentNode || t.commonAncestorContainer;
                        while (n && !Ch(n)) {
                            const t = new yh(n);
                            const i = e.getIntersection(t);
                            if (i) {
                                if (i.getArea() < e.getArea()) {
                                    e = i
                                }
                            } else {
                                return null
                            }
                            n = n.parentNode
                        }
                    }
                    return e
                }
                isEqual(t) {
                    for (const e of vh) {
                        if (this[e] !== t[e]) {
                            return false
                        }
                    }
                    return true
                }
                contains(t) {
                    const e = this.getIntersection(t);
                    return !!(e && e.isEqual(t))
                }
                excludeScrollbarsAndBorders() {
                    const t = this._source;
                    let e, n, i;
                    if (qd(t)) {
                        e = t.innerWidth - t.document.documentElement.clientWidth;
                        n = t.innerHeight - t.document.documentElement.clientHeight;
                        i = t.getComputedStyle(t.document.documentElement).direction
                    } else {
                        const o = _h(this._source);
                        e = t.offsetWidth - t.clientWidth - o.left - o.right;
                        n = t.offsetHeight - t.clientHeight - o.top - o.bottom;
                        i = t.ownerDocument.defaultView.getComputedStyle(t).direction;
                        this.left += o.left;
                        this.top += o.top;
                        this.right -= o.right;
                        this.bottom -= o.bottom;
                        this.width = this.right - this.left;
                        this.height = this.bottom - this.top
                    }
                    this.width -= e;
                    if (i === "ltr") {
                        this.right -= e
                    } else {
                        this.left += e
                    }
                    this.height -= n;
                    this.bottom -= n;
                    return this
                }
                static getDomRangeRects(t) {
                    const e = [];
                    const n = Array.from(t.getClientRects());
                    if (n.length) {
                        for (const t of n) {
                            e.push(new yh(t))
                        }
                    } else {
                        let n = t.startContainer;
                        if (sd(n)) {
                            n = n.parentNode
                        }
                        const i = new yh(n.getBoundingClientRect());
                        i.right = i.left;
                        i.width = 0;
                        e.push(i)
                    }
                    return e
                }
            }
            function xh(t, e) {
                for (const n of vh) {
                    t[n] = e[n]
                }
            }
            function Ch(t) {
                if (!Ks(t)) {
                    return false
                }
                return t === t.ownerDocument.body
            }
            const Ah = {};
            function Ph({ target: t, viewportOffset: e = 0 }) {
                const n = Ih(t);
                let i = n;
                let o = null;
                while (i) {
                    let s;
                    if (i == n) {
                        s = Vh(t)
                    } else {
                        s = Vh(o)
                    }
                    Eh(s, () => Bh(t, i));
                    const r = Bh(t, i);
                    Sh(i, r, e);
                    if (i.parent != i) {
                        o = i.frameElement;
                        i = i.parent;
                        if (!o) {
                            return
                        }
                    } else {
                        i = null
                    }
                }
            }
            function Th(t) {
                const e = Vh(t);
                Eh(e, () => new yh(t))
            }
            Object.assign(Ah, {
                scrollViewportToShowTarget: Ph,
                scrollAncestorsToShowTarget: Th
            });
            function Sh(t, e, n) {
                const i = e.clone().moveBy(0, n);
                const o = e.clone().moveBy(0, -n);
                const s = new yh(t).excludeScrollbarsAndBorders();
                const r = [o, i];
                if (!r.every(t => s.contains(t))) {
                    let { scrollX: r, scrollY: a } = t;
                    if (Oh(o, s)) {
                        a -= s.top - e.top + n
                    } else if (Rh(i, s)) {
                        a += e.bottom - s.bottom + n
                    }
                    if (Mh(e, s)) {
                        r -= s.left - e.left + n
                    } else if (Nh(e, s)) {
                        r += e.right - s.right + n
                    }
                    t.scrollTo(r, a)
                }
            }
            function Eh(t, e) {
                const n = Ih(t);
                let i, o;
                while (t != n.document.body) {
                    o = e();
                    i = new yh(t).excludeScrollbarsAndBorders();
                    if (!i.contains(o)) {
                        if (Oh(o, i)) {
                            t.scrollTop -= i.top - o.top
                        } else if (Rh(o, i)) {
                            t.scrollTop += o.bottom - i.bottom
                        }
                        if (Mh(o, i)) {
                            t.scrollLeft -= i.left - o.left
                        } else if (Nh(o, i)) {
                            t.scrollLeft += o.right - i.right
                        }
                    }
                    t = t.parentNode
                }
            }
            function Rh(t, e) {
                return t.bottom > e.bottom
            }
            function Oh(t, e) {
                return t.top < e.top
            }
            function Mh(t, e) {
                return t.left < e.left
            }
            function Nh(t, e) {
                return t.right > e.right
            }
            function Ih(t) {
                if (kh(t)) {
                    return t.startContainer.ownerDocument.defaultView
                } else {
                    return t.ownerDocument.defaultView
                }
            }
            function Vh(t) {
                if (kh(t)) {
                    let e = t.commonAncestorContainer;
                    if (sd(e)) {
                        e = e.parentNode
                    }
                    return e
                } else {
                    return t.parentNode
                }
            }
            function Bh(t, e) {
                const n = Ih(t);
                const i = new yh(t);
                if (n === e) {
                    return i
                } else {
                    let t = n;
                    while (t != e) {
                        const e = t.frameElement;
                        const n = new yh(e).excludeScrollbarsAndBorders();
                        i.moveBy(n.left, n.top);
                        t = t.parent
                    }
                }
                return i
            }
            class Fh {
                constructor() {
                    this.document = new bl;
                    this.domConverter = new Dd;
                    this.domRoots = new Map;
                    this.set("isRenderingInProgress", false);
                    this._renderer = new Ad(this.domConverter, this.document.selection);
                    this._renderer.bind("isFocused").to(this.document);
                    this._initialDomRootAttributes = new WeakMap;
                    this._observers = new Map;
                    this._ongoingChange = false;
                    this._postFixersInProgress = false;
                    this._renderingDisabled = false;
                    this._hasChangedSinceTheLastRendering = false;
                    this._writer = new Gl(this.document);
                    this.addObserver(Ku);
                    this.addObserver(gh);
                    this.addObserver(mh);
                    this.addObserver(Yu);
                    this.addObserver(fh);
                    this.addObserver(bh);
                    if (Pl.isAndroid) {
                        this.addObserver(wh)
                    }
                    fd(this);
                    Hl(this);
                    this.on("render", () => {
                        this._render();
                        this.document.fire("layoutChanged");
                        this._hasChangedSinceTheLastRendering = false
                    }
                    );
                    this.listenTo(this.document.selection, "change", () => {
                        this._hasChangedSinceTheLastRendering = true
                    }
                    )
                }
                attachDomRoot(t, e = "main") {
                    const n = this.document.getRoot(e);
                    n._name = t.tagName.toLowerCase();
                    const i = {};
                    for (const { name: e, value: o } of Array.from(t.attributes)) {
                        i[e] = o;
                        if (e === "class") {
                            this._writer.addClass(o.split(" "), n)
                        } else {
                            this._writer.setAttribute(e, o, n)
                        }
                    }
                    this._initialDomRootAttributes.set(t, i);
                    const o = () => {
                        this._writer.setAttribute("contenteditable", !n.isReadOnly, n);
                        if (n.isReadOnly) {
                            this._writer.addClass("ck-read-only", n)
                        } else {
                            this._writer.removeClass("ck-read-only", n)
                        }
                    }
                        ;
                    o();
                    this.domRoots.set(e, t);
                    this.domConverter.bindElements(t, n);
                    this._renderer.markToSync("children", n);
                    this._renderer.markToSync("attributes", n);
                    this._renderer.domDocuments.add(t.ownerDocument);
                    n.on("change:children", (t, e) => this._renderer.markToSync("children", e));
                    n.on("change:attributes", (t, e) => this._renderer.markToSync("attributes", e));
                    n.on("change:text", (t, e) => this._renderer.markToSync("text", e));
                    n.on("change:isReadOnly", () => this.change(o));
                    n.on("change", () => {
                        this._hasChangedSinceTheLastRendering = true
                    }
                    );
                    for (const n of this._observers.values()) {
                        n.observe(t, e)
                    }
                }
                detachDomRoot(t) {
                    const e = this.domRoots.get(t);
                    Array.from(e.attributes).forEach(({ name: t }) => e.removeAttribute(t));
                    const n = this._initialDomRootAttributes.get(e);
                    for (const t in n) {
                        e.setAttribute(t, n[t])
                    }
                    this.domRoots.delete(t);
                    this.domConverter.unbindDomElement(e)
                }
                getDomRoot(t = "main") {
                    return this.domRoots.get(t)
                }
                addObserver(t) {
                    let e = this._observers.get(t);
                    if (e) {
                        return e
                    }
                    e = new t(this);
                    this._observers.set(t, e);
                    for (const [t, n] of this.domRoots) {
                        e.observe(n, t)
                    }
                    e.enable();
                    return e
                }
                getObserver(t) {
                    return this._observers.get(t)
                }
                disableObservers() {
                    for (const t of this._observers.values()) {
                        t.disable()
                    }
                }
                enableObservers() {
                    for (const t of this._observers.values()) {
                        t.enable()
                    }
                }
                scrollToTheSelection() {
                    const t = this.document.selection.getFirstRange();
                    if (t) {
                        Ph({
                            target: this.domConverter.viewRangeToDom(t),
                            viewportOffset: 20
                        })
                    }
                }
                focus() {
                    if (!this.document.isFocused) {
                        const t = this.document.selection.editableElement;
                        if (t) {
                            this.domConverter.focus(t);
                            this.forceRender()
                        } else { }
                    }
                }
                change(t) {
                    if (this.isRenderingInProgress || this._postFixersInProgress) {
                        throw new rr["b"]("cannot-change-view-tree: " + "Attempting to make changes to the view when it is in an incorrect state: rendering or post-fixers are in progress. " + "This may cause some unexpected behavior and inconsistency between the DOM and the view.", this)
                    }
                    try {
                        if (this._ongoingChange) {
                            return t(this._writer)
                        }
                        this._ongoingChange = true;
                        const e = t(this._writer);
                        this._ongoingChange = false;
                        if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
                            this._postFixersInProgress = true;
                            this.document._callPostFixers(this._writer);
                            this._postFixersInProgress = false;
                            this.fire("render")
                        }
                        return e
                    } catch (t) {
                        rr["b"].rethrowUnexpectedError(t, this)
                    }
                }
                forceRender() {
                    this._hasChangedSinceTheLastRendering = true;
                    this.change(() => { }
                    )
                }
                destroy() {
                    for (const t of this._observers.values()) {
                        t.destroy()
                    }
                    this.document.destroy();
                    this.stopListening()
                }
                createPositionAt(t, e) {
                    return ul._createAt(t, e)
                }
                createPositionAfter(t) {
                    return ul._createAfter(t)
                }
                createPositionBefore(t) {
                    return ul._createBefore(t)
                }
                createRange(t, e) {
                    return new hl(t, e)
                }
                createRangeOn(t) {
                    return hl._createOn(t)
                }
                createRangeIn(t) {
                    return hl._createIn(t)
                }
                createSelection(t, e, n) {
                    return new gl(t, e, n)
                }
                _disableRendering(t) {
                    this._renderingDisabled = t;
                    if (t == false) {
                        this.change(() => { }
                        )
                    }
                }
                _render() {
                    this.isRenderingInProgress = true;
                    this.disableObservers();
                    this._renderer.render();
                    this.enableObservers();
                    this.isRenderingInProgress = false
                }
            }
            vr(Fh, Jc);
            class Dh {
                constructor(t) {
                    this.parent = null;
                    this._attrs = Hr(t)
                }
                get index() {
                    let t;
                    if (!this.parent) {
                        return null
                    }
                    if ((t = this.parent.getChildIndex(this)) === null) {
                        throw new rr["b"]("model-node-not-found-in-parent: The node's parent does not contain this node.", this)
                    }
                    return t
                }
                get startOffset() {
                    let t;
                    if (!this.parent) {
                        return null
                    }
                    if ((t = this.parent.getChildStartOffset(this)) === null) {
                        throw new rr["b"]("model-node-not-found-in-parent: The node's parent does not contain this node.", this)
                    }
                    return t
                }
                get offsetSize() {
                    return 1
                }
                get endOffset() {
                    if (!this.parent) {
                        return null
                    }
                    return this.startOffset + this.offsetSize
                }
                get nextSibling() {
                    const t = this.index;
                    return t !== null && this.parent.getChild(t + 1) || null
                }
                get previousSibling() {
                    const t = this.index;
                    return t !== null && this.parent.getChild(t - 1) || null
                }
                get root() {
                    let t = this;
                    while (t.parent) {
                        t = t.parent
                    }
                    return t
                }
                get document() {
                    if (this.root == this) {
                        return null
                    }
                    return this.root.document || null
                }
                getPath() {
                    const t = [];
                    let e = this;
                    while (e.parent) {
                        t.unshift(e.startOffset);
                        e = e.parent
                    }
                    return t
                }
                getAncestors(t = {
                    includeSelf: false,
                    parentFirst: false
                }) {
                    const e = [];
                    let n = t.includeSelf ? this : this.parent;
                    while (n) {
                        e[t.parentFirst ? "push" : "unshift"](n);
                        n = n.parent
                    }
                    return e
                }
                getCommonAncestor(t, e = {}) {
                    const n = this.getAncestors(e);
                    const i = t.getAncestors(e);
                    let o = 0;
                    while (n[o] == i[o] && n[o]) {
                        o++
                    }
                    return o === 0 ? null : n[o - 1]
                }
                isBefore(t) {
                    if (this == t) {
                        return false
                    }
                    if (this.root !== t.root) {
                        return false
                    }
                    const e = this.getPath();
                    const n = t.getPath();
                    const i = Nr(e, n);
                    switch (i) {
                        case "prefix":
                            return true;
                        case "extension":
                            return false;
                        default:
                            return e[i] < n[i]
                    }
                }
                isAfter(t) {
                    if (this == t) {
                        return false
                    }
                    if (this.root !== t.root) {
                        return false
                    }
                    return !this.isBefore(t)
                }
                hasAttribute(t) {
                    return this._attrs.has(t)
                }
                getAttribute(t) {
                    return this._attrs.get(t)
                }
                getAttributes() {
                    return this._attrs.entries()
                }
                getAttributeKeys() {
                    return this._attrs.keys()
                }
                toJSON() {
                    const t = {};
                    if (this._attrs.size) {
                        t.attributes = Array.from(this._attrs).reduce((t, e) => {
                            t[e[0]] = e[1];
                            return t
                        }
                            , {})
                    }
                    return t
                }
                is(t) {
                    return t == "node" || t == "model:node"
                }
                _clone() {
                    return new Dh(this._attrs)
                }
                _remove() {
                    this.parent._removeChildren(this.index)
                }
                _setAttribute(t, e) {
                    this._attrs.set(t, e)
                }
                _setAttributesTo(t) {
                    this._attrs = Hr(t)
                }
                _removeAttribute(t) {
                    return this._attrs.delete(t)
                }
                _clearAttributes() {
                    this._attrs.clear()
                }
            }
            class zh extends Dh {
                constructor(t, e) {
                    super(e);
                    this._data = t || ""
                }
                get offsetSize() {
                    return this.data.length
                }
                get data() {
                    return this._data
                }
                is(t) {
                    return t == "text" || t == "model:text" || super.is(t)
                }
                toJSON() {
                    const t = super.toJSON();
                    t.data = this.data;
                    return t
                }
                _clone() {
                    return new zh(this.data, this.getAttributes())
                }
                static fromJSON(t) {
                    return new zh(t.data, t.attributes)
                }
            }
            class Lh {
                constructor(t, e, n) {
                    this.textNode = t;
                    if (e < 0 || e > t.offsetSize) {
                        throw new rr["b"]("model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.", this)
                    }
                    if (n < 0 || e + n > t.offsetSize) {
                        throw new rr["b"]("model-textproxy-wrong-length: Given length value is incorrect.", this)
                    }
                    this.data = t.data.substring(e, e + n);
                    this.offsetInText = e
                }
                get startOffset() {
                    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
                }
                get offsetSize() {
                    return this.data.length
                }
                get endOffset() {
                    return this.startOffset !== null ? this.startOffset + this.offsetSize : null
                }
                get isPartial() {
                    return this.offsetSize !== this.textNode.offsetSize
                }
                get parent() {
                    return this.textNode.parent
                }
                get root() {
                    return this.textNode.root
                }
                get document() {
                    return this.textNode.document
                }
                is(t) {
                    return t == "textProxy" || t == "model:textProxy"
                }
                getPath() {
                    const t = this.textNode.getPath();
                    if (t.length > 0) {
                        t[t.length - 1] += this.offsetInText
                    }
                    return t
                }
                getAncestors(t = {
                    includeSelf: false,
                    parentFirst: false
                }) {
                    const e = [];
                    let n = t.includeSelf ? this : this.parent;
                    while (n) {
                        e[t.parentFirst ? "push" : "unshift"](n);
                        n = n.parent
                    }
                    return e
                }
                hasAttribute(t) {
                    return this.textNode.hasAttribute(t)
                }
                getAttribute(t) {
                    return this.textNode.getAttribute(t)
                }
                getAttributes() {
                    return this.textNode.getAttributes()
                }
                getAttributeKeys() {
                    return this.textNode.getAttributeKeys()
                }
            }
            class jh {
                constructor(t) {
                    this._nodes = [];
                    if (t) {
                        this._insertNodes(0, t)
                    }
                }
                [Symbol.iterator]() {
                    return this._nodes[Symbol.iterator]()
                }
                get length() {
                    return this._nodes.length
                }
                get maxOffset() {
                    return this._nodes.reduce((t, e) => t + e.offsetSize, 0)
                }
                getNode(t) {
                    return this._nodes[t] || null
                }
                getNodeIndex(t) {
                    const e = this._nodes.indexOf(t);
                    return e == -1 ? null : e
                }
                getNodeStartOffset(t) {
                    const e = this.getNodeIndex(t);
                    return e === null ? null : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0)
                }
                indexToOffset(t) {
                    if (t == this._nodes.length) {
                        return this.maxOffset
                    }
                    const e = this._nodes[t];
                    if (!e) {
                        throw new rr["b"]("model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.", this)
                    }
                    return this.getNodeStartOffset(e)
                }
                offsetToIndex(t) {
                    let e = 0;
                    for (const n of this._nodes) {
                        if (t >= e && t < e + n.offsetSize) {
                            return this.getNodeIndex(n)
                        }
                        e += n.offsetSize
                    }
                    if (e != t) {
                        throw new rr["b"]("model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.", this, {
                            offset: t,
                            nodeList: this
                        })
                    }
                    return this.length
                }
                _insertNodes(t, e) {
                    for (const t of e) {
                        if (!(t instanceof Dh)) {
                            throw new rr["b"]("model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.", this)
                        }
                    }
                    this._nodes.splice(t, 0, ...e)
                }
                _removeNodes(t, e = 1) {
                    return this._nodes.splice(t, e)
                }
                toJSON() {
                    return this._nodes.map(t => t.toJSON())
                }
            }
            class Hh extends Dh {
                constructor(t, e, n) {
                    super(e);
                    this.name = t;
                    this._children = new jh;
                    if (n) {
                        this._insertChild(0, n)
                    }
                }
                get childCount() {
                    return this._children.length
                }
                get maxOffset() {
                    return this._children.maxOffset
                }
                get isEmpty() {
                    return this.childCount === 0
                }
                is(t, e = null) {
                    const n = t.replace(/^model:/, "");
                    if (!e) {
                        return n == "element" || n == this.name || super.is(t)
                    } else {
                        return n == "element" && e == this.name
                    }
                }
                getChild(t) {
                    return this._children.getNode(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                getChildIndex(t) {
                    return this._children.getNodeIndex(t)
                }
                getChildStartOffset(t) {
                    return this._children.getNodeStartOffset(t)
                }
                offsetToIndex(t) {
                    return this._children.offsetToIndex(t)
                }
                getNodeByPath(t) {
                    let e = this;
                    for (const n of t) {
                        e = e.getChild(e.offsetToIndex(n))
                    }
                    return e
                }
                toJSON() {
                    const t = super.toJSON();
                    t.name = this.name;
                    if (this._children.length > 0) {
                        t.children = [];
                        for (const e of this._children) {
                            t.children.push(e.toJSON())
                        }
                    }
                    return t
                }
                _clone(t = false) {
                    const e = t ? Array.from(this._children).map(t => t._clone(true)) : null;
                    return new Hh(this.name, this.getAttributes(), e)
                }
                _appendChild(t) {
                    this._insertChild(this.childCount, t)
                }
                _insertChild(t, e) {
                    const n = qh(e);
                    for (const t of n) {
                        if (t.parent !== null) {
                            t._remove()
                        }
                        t.parent = this
                    }
                    this._children._insertNodes(t, n)
                }
                _removeChildren(t, e = 1) {
                    const n = this._children._removeNodes(t, e);
                    for (const t of n) {
                        t.parent = null
                    }
                    return n
                }
                static fromJSON(t) {
                    let e = null;
                    if (t.children) {
                        e = [];
                        for (const n of t.children) {
                            if (n.name) {
                                e.push(Hh.fromJSON(n))
                            } else {
                                e.push(zh.fromJSON(n))
                            }
                        }
                    }
                    return new Hh(t.name, t.attributes, e)
                }
            }
            function qh(t) {
                if (typeof t == "string") {
                    return [new zh(t)]
                }
                if (!jr(t)) {
                    t = [t]
                }
                return Array.from(t).map(t => {
                    if (typeof t == "string") {
                        return new zh(t)
                    }
                    if (t instanceof Lh) {
                        return new zh(t.data, t.getAttributes())
                    }
                    return t
                }
                )
            }
            class Wh {
                constructor(t = {}) {
                    if (!t.boundaries && !t.startPosition) {
                        throw new rr["b"]("model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.", null)
                    }
                    const e = t.direction || "forward";
                    if (e != "forward" && e != "backward") {
                        throw new rr["b"]("model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.", t, {
                            direction: e
                        })
                    }
                    this.direction = e;
                    this.boundaries = t.boundaries || null;
                    if (t.startPosition) {
                        this.position = t.startPosition.clone()
                    } else {
                        this.position = $h._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"])
                    }
                    this.position.stickiness = "toNone";
                    this.singleCharacters = !!t.singleCharacters;
                    this.shallow = !!t.shallow;
                    this.ignoreElementEnd = !!t.ignoreElementEnd;
                    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
                    this._visitedParent = this.position.parent
                }
                [Symbol.iterator]() {
                    return this
                }
                skip(t) {
                    let e, n, i, o;
                    do {
                        i = this.position;
                        o = this._visitedParent;
                        ({ done: e, value: n } = this.next())
                    } while (!e && t(n)); if (!e) {
                        this.position = i;
                        this._visitedParent = o
                    }
                }
                next() {
                    if (this.direction == "forward") {
                        return this._next()
                    } else {
                        return this._previous()
                    }
                }
                _next() {
                    const t = this.position;
                    const e = this.position.clone();
                    const n = this._visitedParent;
                    if (n.parent === null && e.offset === n.maxOffset) {
                        return {
                            done: true
                        }
                    }
                    if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) {
                        return {
                            done: true
                        }
                    }
                    const i = e.textNode ? e.textNode : e.nodeAfter;
                    if (i instanceof Hh) {
                        if (!this.shallow) {
                            e.path.push(0);
                            this._visitedParent = i
                        } else {
                            e.offset++
                        }
                        this.position = e;
                        return Uh("elementStart", i, t, e, 1)
                    } else if (i instanceof zh) {
                        let o;
                        if (this.singleCharacters) {
                            o = 1
                        } else {
                            let t = i.endOffset;
                            if (this._boundaryEndParent == n && this.boundaries.end.offset < t) {
                                t = this.boundaries.end.offset
                            }
                            o = t - e.offset
                        }
                        const s = e.offset - i.startOffset;
                        const r = new Lh(i, s, o);
                        e.offset += o;
                        this.position = e;
                        return Uh("text", r, t, e, o)
                    } else {
                        e.path.pop();
                        e.offset++;
                        this.position = e;
                        this._visitedParent = n.parent;
                        if (this.ignoreElementEnd) {
                            return this._next()
                        } else {
                            return Uh("elementEnd", n, t, e)
                        }
                    }
                }
                _previous() {
                    const t = this.position;
                    const e = this.position.clone();
                    const n = this._visitedParent;
                    if (n.parent === null && e.offset === 0) {
                        return {
                            done: true
                        }
                    }
                    if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) {
                        return {
                            done: true
                        }
                    }
                    const i = e.textNode ? e.textNode : e.nodeBefore;
                    if (i instanceof Hh) {
                        e.offset--;
                        if (!this.shallow) {
                            e.path.push(i.maxOffset);
                            this.position = e;
                            this._visitedParent = i;
                            if (this.ignoreElementEnd) {
                                return this._previous()
                            } else {
                                return Uh("elementEnd", i, t, e)
                            }
                        } else {
                            this.position = e;
                            return Uh("elementStart", i, t, e, 1)
                        }
                    } else if (i instanceof zh) {
                        let o;
                        if (this.singleCharacters) {
                            o = 1
                        } else {
                            let t = i.startOffset;
                            if (this._boundaryStartParent == n && this.boundaries.start.offset > t) {
                                t = this.boundaries.start.offset
                            }
                            o = e.offset - t
                        }
                        const s = e.offset - i.startOffset;
                        const r = new Lh(i, s - o, o);
                        e.offset -= o;
                        this.position = e;
                        return Uh("text", r, t, e, o)
                    } else {
                        e.path.pop();
                        this.position = e;
                        this._visitedParent = n.parent;
                        return Uh("elementStart", n, t, e, 1)
                    }
                }
            }
            function Uh(t, e, n, i, o) {
                return {
                    done: false,
                    value: {
                        type: t,
                        item: e,
                        previousPosition: n,
                        nextPosition: i,
                        length: o
                    }
                }
            }
            class $h {
                constructor(t, e, n = "toNone") {
                    if (!t.is("element") && !t.is("documentFragment")) {
                        throw new rr["b"]("model-position-root-invalid: Position root invalid.", t)
                    }
                    if (!(e instanceof Array) || e.length === 0) {
                        throw new rr["b"]("model-position-path-incorrect-format: Position path must be an array with at least one item.", t, {
                            path: e
                        })
                    }
                    e = t.getPath().concat(e);
                    t = t.root;
                    this.root = t;
                    this.path = e;
                    this.stickiness = n
                }
                get offset() {
                    return Ca(this.path)
                }
                set offset(t) {
                    this.path[this.path.length - 1] = t
                }
                get parent() {
                    let t = this.root;
                    for (let e = 0; e < this.path.length - 1; e++) {
                        t = t.getChild(t.offsetToIndex(this.path[e]));
                        if (!t) {
                            throw new rr["b"]("model-position-path-incorrect: The position's path is incorrect.", this, {
                                position: this
                            })
                        }
                    }
                    if (t.is("text")) {
                        throw new rr["b"]("model-position-path-incorrect: The position's path is incorrect.", this, {
                            position: this
                        })
                    }
                    return t
                }
                get index() {
                    return this.parent.offsetToIndex(this.offset)
                }
                get textNode() {
                    const t = this.parent.getChild(this.index);
                    return t instanceof zh && t.startOffset < this.offset ? t : null
                }
                get nodeAfter() {
                    return this.textNode === null ? this.parent.getChild(this.index) : null
                }
                get nodeBefore() {
                    return this.textNode === null ? this.parent.getChild(this.index - 1) : null
                }
                get isAtStart() {
                    return this.offset === 0
                }
                get isAtEnd() {
                    return this.offset == this.parent.maxOffset
                }
                compareWith(t) {
                    if (this.root != t.root) {
                        return "different"
                    }
                    const e = Nr(this.path, t.path);
                    switch (e) {
                        case "same":
                            return "same";
                        case "prefix":
                            return "before";
                        case "extension":
                            return "after";
                        default:
                            return this.path[e] < t.path[e] ? "before" : "after"
                    }
                }
                getLastMatchingPosition(t, e = {}) {
                    e.startPosition = this;
                    const n = new Wh(e);
                    n.skip(t);
                    return n.position
                }
                getParentPath() {
                    return this.path.slice(0, -1)
                }
                getAncestors() {
                    if (this.parent.is("documentFragment")) {
                        return [this.parent]
                    } else {
                        return this.parent.getAncestors({
                            includeSelf: true
                        })
                    }
                }
                getCommonPath(t) {
                    if (this.root != t.root) {
                        return []
                    }
                    const e = Nr(this.path, t.path);
                    const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e;
                    return this.path.slice(0, n)
                }
                getCommonAncestor(t) {
                    const e = this.getAncestors();
                    const n = t.getAncestors();
                    let i = 0;
                    while (e[i] == n[i] && e[i]) {
                        i++
                    }
                    return i === 0 ? null : e[i - 1]
                }
                getShiftedBy(t) {
                    const e = this.clone();
                    const n = e.offset + t;
                    e.offset = n < 0 ? 0 : n;
                    return e
                }
                isAfter(t) {
                    return this.compareWith(t) == "after"
                }
                isBefore(t) {
                    return this.compareWith(t) == "before"
                }
                isEqual(t) {
                    return this.compareWith(t) == "same"
                }
                isTouching(t) {
                    let e = null;
                    let n = null;
                    const i = this.compareWith(t);
                    switch (i) {
                        case "same":
                            return true;
                        case "before":
                            e = $h._createAt(this);
                            n = $h._createAt(t);
                            break;
                        case "after":
                            e = $h._createAt(t);
                            n = $h._createAt(this);
                            break;
                        default:
                            return false
                    }
                    let o = e.parent;
                    while (e.path.length + n.path.length) {
                        if (e.isEqual(n)) {
                            return true
                        }
                        if (e.path.length > n.path.length) {
                            if (e.offset !== o.maxOffset) {
                                return false
                            }
                            e.path = e.path.slice(0, -1);
                            o = o.parent;
                            e.offset++
                        } else {
                            if (n.offset !== 0) {
                                return false
                            }
                            n.path = n.path.slice(0, -1)
                        }
                    }
                }
                is(t) {
                    return t == "position" || t == "model:position"
                }
                hasSameParentAs(t) {
                    if (this.root !== t.root) {
                        return false
                    }
                    const e = this.getParentPath();
                    const n = t.getParentPath();
                    return Nr(e, n) == "same"
                }
                getTransformedByOperation(t) {
                    let e;
                    switch (t.type) {
                        case "insert":
                            e = this._getTransformedByInsertOperation(t);
                            break;
                        case "move":
                        case "remove":
                        case "reinsert":
                            e = this._getTransformedByMoveOperation(t);
                            break;
                        case "split":
                            e = this._getTransformedBySplitOperation(t);
                            break;
                        case "merge":
                            e = this._getTransformedByMergeOperation(t);
                            break;
                        default:
                            e = $h._createAt(this);
                            break
                    }
                    return e
                }
                _getTransformedByInsertOperation(t) {
                    return this._getTransformedByInsertion(t.position, t.howMany)
                }
                _getTransformedByMoveOperation(t) {
                    return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
                }
                _getTransformedBySplitOperation(t) {
                    const e = t.movedRange;
                    const n = e.containsPosition(this) || e.start.isEqual(this) && this.stickiness == "toNext";
                    if (n) {
                        return this._getCombined(t.splitPosition, t.moveTargetPosition)
                    } else {
                        if (t.graveyardPosition) {
                            return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
                        } else {
                            return this._getTransformedByInsertion(t.insertionPosition, 1)
                        }
                    }
                }
                _getTransformedByMergeOperation(t) {
                    const e = t.movedRange;
                    const n = e.containsPosition(this) || e.start.isEqual(this);
                    let i;
                    if (n) {
                        i = this._getCombined(t.sourcePosition, t.targetPosition);
                        if (t.sourcePosition.isBefore(t.targetPosition)) {
                            i = i._getTransformedByDeletion(t.deletionPosition, 1)
                        }
                    } else if (this.isEqual(t.deletionPosition)) {
                        i = $h._createAt(t.deletionPosition)
                    } else {
                        i = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)
                    }
                    return i
                }
                _getTransformedByDeletion(t, e) {
                    const n = $h._createAt(this);
                    if (this.root != t.root) {
                        return n
                    }
                    if (Nr(t.getParentPath(), this.getParentPath()) == "same") {
                        if (t.offset < this.offset) {
                            if (t.offset + e > this.offset) {
                                return null
                            } else {
                                n.offset -= e
                            }
                        }
                    } else if (Nr(t.getParentPath(), this.getParentPath()) == "prefix") {
                        const i = t.path.length - 1;
                        if (t.offset <= this.path[i]) {
                            if (t.offset + e > this.path[i]) {
                                return null
                            } else {
                                n.path[i] -= e
                            }
                        }
                    }
                    return n
                }
                _getTransformedByInsertion(t, e) {
                    const n = $h._createAt(this);
                    if (this.root != t.root) {
                        return n
                    }
                    if (Nr(t.getParentPath(), this.getParentPath()) == "same") {
                        if (t.offset < this.offset || t.offset == this.offset && this.stickiness != "toPrevious") {
                            n.offset += e
                        }
                    } else if (Nr(t.getParentPath(), this.getParentPath()) == "prefix") {
                        const i = t.path.length - 1;
                        if (t.offset <= this.path[i]) {
                            n.path[i] += e
                        }
                    }
                    return n
                }
                _getTransformedByMove(t, e, n) {
                    e = e._getTransformedByDeletion(t, n);
                    if (t.isEqual(e)) {
                        return $h._createAt(this)
                    }
                    const i = this._getTransformedByDeletion(t, n);
                    const o = i === null || t.isEqual(this) && this.stickiness == "toNext" || t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious";
                    if (o) {
                        return this._getCombined(t, e)
                    } else {
                        return i._getTransformedByInsertion(e, n)
                    }
                }
                _getCombined(t, e) {
                    const n = t.path.length - 1;
                    const i = $h._createAt(e);
                    i.stickiness = this.stickiness;
                    i.offset = i.offset + this.path[n] - t.offset;
                    i.path = i.path.concat(this.path.slice(n + 1));
                    return i
                }
                toJSON() {
                    return {
                        root: this.root.toJSON(),
                        path: Array.from(this.path),
                        stickiness: this.stickiness
                    }
                }
                clone() {
                    return new this.constructor(this.root, this.path, this.stickiness)
                }
                static _createAt(t, e, n = "toNone") {
                    if (t instanceof $h) {
                        return new $h(t.root, t.path, t.stickiness)
                    } else {
                        const i = t;
                        if (e == "end") {
                            e = i.maxOffset
                        } else if (e == "before") {
                            return this._createBefore(i, n)
                        } else if (e == "after") {
                            return this._createAfter(i, n)
                        } else if (e !== 0 && !e) {
                            throw new rr["b"]("model-createPositionAt-offset-required: " + "Model#createPositionAt() requires the offset when the first parameter is a model item.", [this, t])
                        }
                        if (!i.is("element") && !i.is("documentFragment")) {
                            throw new rr["b"]("model-position-parent-incorrect: Position parent have to be a element or document fragment.", [this, t])
                        }
                        const o = i.getPath();
                        o.push(e);
                        return new this(i.root, o, n)
                    }
                }
                static _createAfter(t, e) {
                    if (!t.parent) {
                        throw new rr["b"]("model-position-after-root: You cannot make a position after root.", [this, t], {
                            root: t
                        })
                    }
                    return this._createAt(t.parent, t.endOffset, e)
                }
                static _createBefore(t, e) {
                    if (!t.parent) {
                        throw new rr["b"]("model-position-before-root: You cannot make a position before root.", t, {
                            root: t
                        })
                    }
                    return this._createAt(t.parent, t.startOffset, e)
                }
                static fromJSON(t, e) {
                    if (t.root === "$graveyard") {
                        const n = new $h(e.graveyard, t.path);
                        n.stickiness = t.stickiness;
                        return n
                    }
                    if (!e.getRoot(t.root)) {
                        throw new rr["b"]("model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.", e, {
                            rootName: t.root
                        })
                    }
                    return new $h(e.getRoot(t.root), t.path, t.stickiness)
                }
            }
            class Gh {
                constructor(t, e = null) {
                    this.start = $h._createAt(t);
                    this.end = e ? $h._createAt(e) : $h._createAt(t);
                    this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
                    this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
                }
                *[Symbol.iterator]() {
                    yield* new Wh({
                        boundaries: this,
                        ignoreElementEnd: true
                    })
                }
                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }
                get isFlat() {
                    const t = this.start.getParentPath();
                    const e = this.end.getParentPath();
                    return Nr(t, e) == "same"
                }
                get root() {
                    return this.start.root
                }
                containsPosition(t) {
                    return t.isAfter(this.start) && t.isBefore(this.end)
                }
                containsRange(t, e = false) {
                    if (t.isCollapsed) {
                        e = false
                    }
                    const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                    const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                    return n && i
                }
                containsItem(t) {
                    const e = $h._createBefore(t);
                    return this.containsPosition(e) || this.start.isEqual(e)
                }
                is(t) {
                    return t == "range" || t == "model:range"
                }
                isEqual(t) {
                    return this.start.isEqual(t.start) && this.end.isEqual(t.end)
                }
                isIntersecting(t) {
                    return this.start.isBefore(t.end) && this.end.isAfter(t.start)
                }
                getDifference(t) {
                    const e = [];
                    if (this.isIntersecting(t)) {
                        if (this.containsPosition(t.start)) {
                            e.push(new Gh(this.start, t.start))
                        }
                        if (this.containsPosition(t.end)) {
                            e.push(new Gh(t.end, this.end))
                        }
                    } else {
                        e.push(new Gh(this.start, this.end))
                    }
                    return e
                }
                getIntersection(t) {
                    if (this.isIntersecting(t)) {
                        let e = this.start;
                        let n = this.end;
                        if (this.containsPosition(t.start)) {
                            e = t.start
                        }
                        if (this.containsPosition(t.end)) {
                            n = t.end
                        }
                        return new Gh(e, n)
                    }
                    return null
                }
                getMinimalFlatRanges() {
                    const t = [];
                    const e = this.start.getCommonPath(this.end).length;
                    const n = $h._createAt(this.start);
                    let i = n.parent;
                    while (n.path.length > e + 1) {
                        const e = i.maxOffset - n.offset;
                        if (e !== 0) {
                            t.push(new Gh(n, n.getShiftedBy(e)))
                        }
                        n.path = n.path.slice(0, -1);
                        n.offset++;
                        i = i.parent
                    }
                    while (n.path.length <= this.end.path.length) {
                        const e = this.end.path[n.path.length - 1];
                        const i = e - n.offset;
                        if (i !== 0) {
                            t.push(new Gh(n, n.getShiftedBy(i)))
                        }
                        n.offset = e;
                        n.path.push(0)
                    }
                    return t
                }
                getWalker(t = {}) {
                    t.boundaries = this;
                    return new Wh(t)
                }
                *getItems(t = {}) {
                    t.boundaries = this;
                    t.ignoreElementEnd = true;
                    const e = new Wh(t);
                    for (const t of e) {
                        yield t.item
                    }
                }
                *getPositions(t = {}) {
                    t.boundaries = this;
                    const e = new Wh(t);
                    yield e.position;
                    for (const t of e) {
                        yield t.nextPosition
                    }
                }
                getTransformedByOperation(t) {
                    switch (t.type) {
                        case "insert":
                            return this._getTransformedByInsertOperation(t);
                        case "move":
                        case "remove":
                        case "reinsert":
                            return this._getTransformedByMoveOperation(t);
                        case "split":
                            return [this._getTransformedBySplitOperation(t)];
                        case "merge":
                            return [this._getTransformedByMergeOperation(t)]
                    }
                    return [new Gh(this.start, this.end)]
                }
                getTransformedByOperations(t) {
                    const e = [new Gh(this.start, this.end)];
                    for (const n of t) {
                        for (let t = 0; t < e.length; t++) {
                            const i = e[t].getTransformedByOperation(n);
                            e.splice(t, 1, ...i);
                            t += i.length - 1
                        }
                    }
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        for (let i = t + 1; i < e.length; i++) {
                            const t = e[i];
                            if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                                e.splice(i, 1)
                            }
                        }
                    }
                    return e
                }
                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }
                toJSON() {
                    return {
                        start: this.start.toJSON(),
                        end: this.end.toJSON()
                    }
                }
                clone() {
                    return new this.constructor(this.start, this.end)
                }
                _getTransformedByInsertOperation(t, e = false) {
                    return this._getTransformedByInsertion(t.position, t.howMany, e)
                }
                _getTransformedByMoveOperation(t, e = false) {
                    const n = t.sourcePosition;
                    const i = t.howMany;
                    const o = t.targetPosition;
                    return this._getTransformedByMove(n, o, i, e)
                }
                _getTransformedBySplitOperation(t) {
                    const e = this.start._getTransformedBySplitOperation(t);
                    let n = this.end._getTransformedBySplitOperation(t);
                    if (this.end.isEqual(t.insertionPosition)) {
                        n = this.end.getShiftedBy(1)
                    }
                    if (e.root != n.root) {
                        n = this.end.getShiftedBy(-1)
                    }
                    return new Gh(e, n)
                }
                _getTransformedByMergeOperation(t) {
                    if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) {
                        return new Gh(this.start)
                    }
                    let e = this.start._getTransformedByMergeOperation(t);
                    let n = this.end._getTransformedByMergeOperation(t);
                    if (e.root != n.root) {
                        n = this.end.getShiftedBy(-1)
                    }
                    if (e.isAfter(n)) {
                        if (t.sourcePosition.isBefore(t.targetPosition)) {
                            e = $h._createAt(n);
                            e.offset = 0
                        } else {
                            if (!t.deletionPosition.isEqual(e)) {
                                n = t.deletionPosition
                            }
                            e = t.targetPosition
                        }
                        return new Gh(e, n)
                    }
                    return new Gh(e, n)
                }
                _getTransformedByInsertion(t, e, n = false) {
                    if (n && this.containsPosition(t)) {
                        return [new Gh(this.start, t), new Gh(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))]
                    } else {
                        const n = new Gh(this.start, this.end);
                        n.start = n.start._getTransformedByInsertion(t, e);
                        n.end = n.end._getTransformedByInsertion(t, e);
                        return [n]
                    }
                }
                _getTransformedByMove(t, e, n, i = false) {
                    if (this.isCollapsed) {
                        const i = this.start._getTransformedByMove(t, e, n);
                        return [new Gh(i)]
                    }
                    const o = Gh._createFromPositionAndShift(t, n);
                    const s = e._getTransformedByDeletion(t, n);
                    if (this.containsPosition(e) && !i) {
                        if (o.containsPosition(this.start) || o.containsPosition(this.end)) {
                            const i = this.start._getTransformedByMove(t, e, n);
                            const o = this.end._getTransformedByMove(t, e, n);
                            return [new Gh(i, o)]
                        }
                    }
                    let r;
                    const a = this.getDifference(o);
                    let c = null;
                    const l = this.getIntersection(o);
                    if (a.length == 1) {
                        c = new Gh(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n))
                    } else if (a.length == 2) {
                        c = new Gh(this.start, this.end._getTransformedByDeletion(t, n))
                    }
                    if (c) {
                        r = c._getTransformedByInsertion(s, n, l !== null || i)
                    } else {
                        r = []
                    }
                    if (l) {
                        const t = new Gh(l.start._getCombined(o.start, s), l.end._getCombined(o.start, s));
                        if (r.length == 2) {
                            r.splice(1, 0, t)
                        } else {
                            r.push(t)
                        }
                    }
                    return r
                }
                _getTransformedByDeletion(t, e) {
                    let n = this.start._getTransformedByDeletion(t, e);
                    let i = this.end._getTransformedByDeletion(t, e);
                    if (n == null && i == null) {
                        return null
                    }
                    if (n == null) {
                        n = t
                    }
                    if (i == null) {
                        i = t
                    }
                    return new Gh(n, i)
                }
                static _createFromPositionAndShift(t, e) {
                    const n = t;
                    const i = t.getShiftedBy(e);
                    return e > 0 ? new this(n, i) : new this(i, n)
                }
                static _createIn(t) {
                    return new this($h._createAt(t, 0), $h._createAt(t, t.maxOffset))
                }
                static _createOn(t) {
                    return this._createFromPositionAndShift($h._createBefore(t), t.offsetSize)
                }
                static _createFromRanges(t) {
                    if (t.length === 0) {
                        throw new rr["b"]("range-create-from-ranges-empty-array: At least one range has to be passed.", null)
                    } else if (t.length == 1) {
                        return t[0].clone()
                    }
                    const e = t[0];
                    t.sort((t, e) => t.start.isAfter(e.start) ? 1 : -1);
                    const n = t.indexOf(e);
                    const i = new this(e.start, e.end);
                    if (n > 0) {
                        for (let e = n - 1; true; e++) {
                            if (t[e].end.isEqual(i.start)) {
                                i.start = $h._createAt(t[e].start)
                            } else {
                                break
                            }
                        }
                    }
                    for (let e = n + 1; e < t.length; e++) {
                        if (t[e].start.isEqual(i.end)) {
                            i.end = $h._createAt(t[e].end)
                        } else {
                            break
                        }
                    }
                    return i
                }
                static fromJSON(t, e) {
                    return new this($h.fromJSON(t.start, e), $h.fromJSON(t.end, e))
                }
            }
            class Kh {
                constructor() {
                    this._modelToViewMapping = new WeakMap;
                    this._viewToModelMapping = new WeakMap;
                    this._viewToModelLengthCallbacks = new Map;
                    this._markerNameToElements = new Map;
                    this._elementToMarkerNames = new Map;
                    this._unboundMarkerNames = new Set;
                    this.on("modelToViewPosition", (t, e) => {
                        if (e.viewPosition) {
                            return
                        }
                        const n = this._modelToViewMapping.get(e.modelPosition.parent);
                        e.viewPosition = this._findPositionIn(n, e.modelPosition.offset)
                    }
                        , {
                            priority: "low"
                        });
                    this.on("viewToModelPosition", (t, e) => {
                        if (e.modelPosition) {
                            return
                        }
                        const n = this.findMappedViewAncestor(e.viewPosition);
                        const i = this._viewToModelMapping.get(n);
                        const o = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
                        e.modelPosition = $h._createAt(i, o)
                    }
                        , {
                            priority: "low"
                        })
                }
                bindElements(t, e) {
                    this._modelToViewMapping.set(t, e);
                    this._viewToModelMapping.set(e, t)
                }
                unbindViewElement(t) {
                    const e = this.toModelElement(t);
                    this._viewToModelMapping.delete(t);
                    if (this._elementToMarkerNames.has(t)) {
                        for (const e of this._elementToMarkerNames.get(t)) {
                            this._unboundMarkerNames.add(e)
                        }
                    }
                    if (this._modelToViewMapping.get(e) == t) {
                        this._modelToViewMapping.delete(e)
                    }
                }
                unbindModelElement(t) {
                    const e = this.toViewElement(t);
                    this._modelToViewMapping.delete(t);
                    if (this._viewToModelMapping.get(e) == t) {
                        this._viewToModelMapping.delete(e)
                    }
                }
                bindElementToMarker(t, e) {
                    const n = this._markerNameToElements.get(e) || new Set;
                    n.add(t);
                    const i = this._elementToMarkerNames.get(t) || new Set;
                    i.add(e);
                    this._markerNameToElements.set(e, n);
                    this._elementToMarkerNames.set(t, i)
                }
                unbindElementFromMarkerName(t, e) {
                    const n = this._markerNameToElements.get(e);
                    if (n) {
                        n.delete(t);
                        if (n.size == 0) {
                            this._markerNameToElements.delete(e)
                        }
                    }
                    const i = this._elementToMarkerNames.get(t);
                    if (i) {
                        i.delete(e);
                        if (i.size == 0) {
                            this._elementToMarkerNames.delete(t)
                        }
                    }
                }
                flushUnboundMarkerNames() {
                    const t = Array.from(this._unboundMarkerNames);
                    this._unboundMarkerNames.clear();
                    return t
                }
                clearBindings() {
                    this._modelToViewMapping = new WeakMap;
                    this._viewToModelMapping = new WeakMap;
                    this._markerNameToElements = new Map;
                    this._elementToMarkerNames = new Map;
                    this._unboundMarkerNames = new Set
                }
                toModelElement(t) {
                    return this._viewToModelMapping.get(t)
                }
                toViewElement(t) {
                    return this._modelToViewMapping.get(t)
                }
                toModelRange(t) {
                    return new Gh(this.toModelPosition(t.start), this.toModelPosition(t.end))
                }
                toViewRange(t) {
                    return new hl(this.toViewPosition(t.start), this.toViewPosition(t.end))
                }
                toModelPosition(t) {
                    const e = {
                        viewPosition: t,
                        mapper: this
                    };
                    this.fire("viewToModelPosition", e);
                    return e.modelPosition
                }
                toViewPosition(t, e = {
                    isPhantom: false
                }) {
                    const n = {
                        modelPosition: t,
                        mapper: this,
                        isPhantom: e.isPhantom
                    };
                    this.fire("modelToViewPosition", n);
                    return n.viewPosition
                }
                markerNameToElements(t) {
                    const e = this._markerNameToElements.get(t);
                    if (!e) {
                        return null
                    }
                    const n = new Set;
                    for (const t of e) {
                        if (t.is("attributeElement")) {
                            for (const e of t.getElementsWithSameId()) {
                                n.add(e)
                            }
                        } else {
                            n.add(t)
                        }
                    }
                    return n
                }
                registerViewToModelLength(t, e) {
                    this._viewToModelLengthCallbacks.set(t, e)
                }
                findMappedViewAncestor(t) {
                    let e = t.parent;
                    while (!this._viewToModelMapping.has(e)) {
                        e = e.parent
                    }
                    return e
                }
                _toModelOffset(t, e, n) {
                    if (n != t) {
                        const i = this._toModelOffset(t.parent, t.index, n);
                        const o = this._toModelOffset(t, e, t);
                        return i + o
                    }
                    if (t.is("text")) {
                        return e
                    }
                    let i = 0;
                    for (let n = 0; n < e; n++) {
                        i += this.getModelLength(t.getChild(n))
                    }
                    return i
                }
                getModelLength(t) {
                    if (this._viewToModelLengthCallbacks.get(t.name)) {
                        const e = this._viewToModelLengthCallbacks.get(t.name);
                        return e(t)
                    } else if (this._viewToModelMapping.has(t)) {
                        return 1
                    } else if (t.is("text")) {
                        return t.data.length
                    } else if (t.is("uiElement")) {
                        return 0
                    } else {
                        let e = 0;
                        for (const n of t.getChildren()) {
                            e += this.getModelLength(n)
                        }
                        return e
                    }
                }
                _findPositionIn(t, e) {
                    let n;
                    let i = 0;
                    let o = 0;
                    let s = 0;
                    if (t.is("text")) {
                        return new ul(t, e)
                    }
                    while (o < e) {
                        n = t.getChild(s);
                        i = this.getModelLength(n);
                        o += i;
                        s++
                    }
                    if (o == e) {
                        return this._moveViewPositionToTextNode(new ul(t, s))
                    } else {
                        return this._findPositionIn(n, e - (o - i))
                    }
                }
                _moveViewPositionToTextNode(t) {
                    const e = t.nodeBefore;
                    const n = t.nodeAfter;
                    if (e instanceof Dr) {
                        return new ul(e, e.data.length)
                    } else if (n instanceof Dr) {
                        return new ul(n, 0)
                    }
                    return t
                }
            }
            vr(Kh, dr);
            class Jh {
                constructor() {
                    this._consumable = new Map;
                    this._textProxyRegistry = new Map
                }
                add(t, e) {
                    e = Qh(e);
                    if (t instanceof Lh) {
                        t = this._getSymbolForTextProxy(t)
                    }
                    if (!this._consumable.has(t)) {
                        this._consumable.set(t, new Map)
                    }
                    this._consumable.get(t).set(e, true)
                }
                consume(t, e) {
                    e = Qh(e);
                    if (t instanceof Lh) {
                        t = this._getSymbolForTextProxy(t)
                    }
                    if (this.test(t, e)) {
                        this._consumable.get(t).set(e, false);
                        return true
                    } else {
                        return false
                    }
                }
                test(t, e) {
                    e = Qh(e);
                    if (t instanceof Lh) {
                        t = this._getSymbolForTextProxy(t)
                    }
                    const n = this._consumable.get(t);
                    if (n === undefined) {
                        return null
                    }
                    const i = n.get(e);
                    if (i === undefined) {
                        return null
                    }
                    return i
                }
                revert(t, e) {
                    e = Qh(e);
                    if (t instanceof Lh) {
                        t = this._getSymbolForTextProxy(t)
                    }
                    const n = this.test(t, e);
                    if (n === false) {
                        this._consumable.get(t).set(e, true);
                        return true
                    } else if (n === true) {
                        return false
                    }
                    return null
                }
                _getSymbolForTextProxy(t) {
                    let e = null;
                    const n = this._textProxyRegistry.get(t.startOffset);
                    if (n) {
                        const i = n.get(t.endOffset);
                        if (i) {
                            e = i.get(t.parent)
                        }
                    }
                    if (!e) {
                        e = this._addSymbolForTextProxy(t.startOffset, t.endOffset, t.parent)
                    }
                    return e
                }
                _addSymbolForTextProxy(t, e, n) {
                    const i = Symbol("textProxySymbol");
                    let o, s;
                    o = this._textProxyRegistry.get(t);
                    if (!o) {
                        o = new Map;
                        this._textProxyRegistry.set(t, o)
                    }
                    s = o.get(e);
                    if (!s) {
                        s = new Map;
                        o.set(e, s)
                    }
                    s.set(n, i);
                    return i
                }
            }
            function Qh(t) {
                const e = t.split(":");
                return e.length > 1 ? e[0] + ":" + e[1] : e[0]
            }
            class Yh {
                constructor(t) {
                    this.conversionApi = Wc({
                        dispatcher: this
                    }, t)
                }
                convertChanges(t, e, n) {
                    for (const e of t.getMarkersToRemove()) {
                        this.convertMarkerRemove(e.name, e.range, n)
                    }
                    for (const e of t.getChanges()) {
                        if (e.type == "insert") {
                            this.convertInsert(Gh._createFromPositionAndShift(e.position, e.length), n)
                        } else if (e.type == "remove") {
                            this.convertRemove(e.position, e.length, e.name, n)
                        } else {
                            this.convertAttribute(e.range, e.attributeKey, e.attributeOldValue, e.attributeNewValue, n)
                        }
                    }
                    for (const t of this.conversionApi.mapper.flushUnboundMarkerNames()) {
                        const i = e.get(t).getRange();
                        this.convertMarkerRemove(t, i, n);
                        this.convertMarkerAdd(t, i, n)
                    }
                    for (const e of t.getMarkersToAdd()) {
                        this.convertMarkerAdd(e.name, e.range, n)
                    }
                }
                convertInsert(t, e) {
                    this.conversionApi.writer = e;
                    this.conversionApi.consumable = this._createInsertConsumable(t);
                    for (const e of t) {
                        const t = e.item;
                        const n = Gh._createFromPositionAndShift(e.previousPosition, e.length);
                        const i = {
                            item: t,
                            range: n
                        };
                        this._testAndFire("insert", i);
                        for (const e of t.getAttributeKeys()) {
                            i.attributeKey = e;
                            i.attributeOldValue = null;
                            i.attributeNewValue = t.getAttribute(e);
                            this._testAndFire(`attribute:${e}`, i)
                        }
                    }
                    this._clearConversionApi()
                }
                convertRemove(t, e, n, i) {
                    this.conversionApi.writer = i;
                    this.fire("remove:" + n, {
                        position: t,
                        length: e
                    }, this.conversionApi);
                    this._clearConversionApi()
                }
                convertAttribute(t, e, n, i, o) {
                    this.conversionApi.writer = o;
                    this.conversionApi.consumable = this._createConsumableForRange(t, `attribute:${e}`);
                    for (const o of t) {
                        const t = o.item;
                        const s = Gh._createFromPositionAndShift(o.previousPosition, o.length);
                        const r = {
                            item: t,
                            range: s,
                            attributeKey: e,
                            attributeOldValue: n,
                            attributeNewValue: i
                        };
                        this._testAndFire(`attribute:${e}`, r)
                    }
                    this._clearConversionApi()
                }
                convertSelection(t, e, n) {
                    const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
                    this.conversionApi.writer = n;
                    this.conversionApi.consumable = this._createSelectionConsumable(t, i);
                    this.fire("selection", {
                        selection: t
                    }, this.conversionApi);
                    if (!t.isCollapsed) {
                        return
                    }
                    for (const e of i) {
                        const n = e.getRange();
                        if (!Xh(t.getFirstPosition(), e, this.conversionApi.mapper)) {
                            continue
                        }
                        const i = {
                            item: t,
                            markerName: e.name,
                            markerRange: n
                        };
                        if (this.conversionApi.consumable.test(t, "addMarker:" + e.name)) {
                            this.fire("addMarker:" + e.name, i, this.conversionApi)
                        }
                    }
                    for (const e of t.getAttributeKeys()) {
                        const n = {
                            item: t,
                            range: t.getFirstRange(),
                            attributeKey: e,
                            attributeOldValue: null,
                            attributeNewValue: t.getAttribute(e)
                        };
                        if (this.conversionApi.consumable.test(t, "attribute:" + n.attributeKey)) {
                            this.fire("attribute:" + n.attributeKey + ":$text", n, this.conversionApi)
                        }
                    }
                    this._clearConversionApi()
                }
                convertMarkerAdd(t, e, n) {
                    if (!e.root.document || e.root.rootName == "$graveyard") {
                        return
                    }
                    this.conversionApi.writer = n;
                    const i = "addMarker:" + t;
                    const o = new Jh;
                    o.add(e, i);
                    this.conversionApi.consumable = o;
                    this.fire(i, {
                        markerName: t,
                        markerRange: e
                    }, this.conversionApi);
                    if (!o.test(e, i)) {
                        return
                    }
                    this.conversionApi.consumable = this._createConsumableForRange(e, i);
                    for (const n of e.getItems()) {
                        if (!this.conversionApi.consumable.test(n, i)) {
                            continue
                        }
                        const o = {
                            item: n,
                            range: Gh._createOn(n),
                            markerName: t,
                            markerRange: e
                        };
                        this.fire(i, o, this.conversionApi)
                    }
                    this._clearConversionApi()
                }
                convertMarkerRemove(t, e, n) {
                    if (!e.root.document || e.root.rootName == "$graveyard") {
                        return
                    }
                    this.conversionApi.writer = n;
                    this.fire("removeMarker:" + t, {
                        markerName: t,
                        markerRange: e
                    }, this.conversionApi);
                    this._clearConversionApi()
                }
                _createInsertConsumable(t) {
                    const e = new Jh;
                    for (const n of t) {
                        const t = n.item;
                        e.add(t, "insert");
                        for (const n of t.getAttributeKeys()) {
                            e.add(t, "attribute:" + n)
                        }
                    }
                    return e
                }
                _createConsumableForRange(t, e) {
                    const n = new Jh;
                    for (const i of t.getItems()) {
                        n.add(i, e)
                    }
                    return n
                }
                _createSelectionConsumable(t, e) {
                    const n = new Jh;
                    n.add(t, "selection");
                    for (const i of e) {
                        n.add(t, "addMarker:" + i.name)
                    }
                    for (const e of t.getAttributeKeys()) {
                        n.add(t, "attribute:" + e)
                    }
                    return n
                }
                _testAndFire(t, e) {
                    if (!this.conversionApi.consumable.test(e.item, t)) {
                        return
                    }
                    const n = e.item.name || "$text";
                    this.fire(t + ":" + n, e, this.conversionApi)
                }
                _clearConversionApi() {
                    delete this.conversionApi.writer;
                    delete this.conversionApi.consumable
                }
            }
            vr(Yh, dr);
            function Xh(t, e, n) {
                const i = e.getRange();
                const o = Array.from(t.getAncestors());
                o.shift();
                o.reverse();
                const s = o.some(t => {
                    if (i.containsItem(t)) {
                        const e = n.toViewElement(t);
                        return !!e.getCustomProperty("addHighlight")
                    }
                }
                );
                return !s
            }
            class Zh {
                constructor(t, e, n) {
                    this._lastRangeBackward = false;
                    this._ranges = [];
                    this._attrs = new Map;
                    if (t) {
                        this.setTo(t, e, n)
                    }
                }
                get anchor() {
                    if (this._ranges.length > 0) {
                        const t = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? t.end : t.start
                    }
                    return null
                }
                get focus() {
                    if (this._ranges.length > 0) {
                        const t = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? t.start : t.end
                    }
                    return null
                }
                get isCollapsed() {
                    const t = this._ranges.length;
                    if (t === 1) {
                        return this._ranges[0].isCollapsed
                    } else {
                        return false
                    }
                }
                get rangeCount() {
                    return this._ranges.length
                }
                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }
                isEqual(t) {
                    if (this.rangeCount != t.rangeCount) {
                        return false
                    } else if (this.rangeCount === 0) {
                        return true
                    }
                    if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                        return false
                    }
                    for (const e of this._ranges) {
                        let n = false;
                        for (const i of t._ranges) {
                            if (e.isEqual(i)) {
                                n = true;
                                break
                            }
                        }
                        if (!n) {
                            return false
                        }
                    }
                    return true
                }
                *getRanges() {
                    for (const t of this._ranges) {
                        yield new Gh(t.start, t.end)
                    }
                }
                getFirstRange() {
                    let t = null;
                    for (const e of this._ranges) {
                        if (!t || e.start.isBefore(t.start)) {
                            t = e
                        }
                    }
                    return t ? new Gh(t.start, t.end) : null
                }
                getLastRange() {
                    let t = null;
                    for (const e of this._ranges) {
                        if (!t || e.end.isAfter(t.end)) {
                            t = e
                        }
                    }
                    return t ? new Gh(t.start, t.end) : null
                }
                getFirstPosition() {
                    const t = this.getFirstRange();
                    return t ? t.start.clone() : null
                }
                getLastPosition() {
                    const t = this.getLastRange();
                    return t ? t.end.clone() : null
                }
                setTo(t, e, n) {
                    if (t === null) {
                        this._setRanges([])
                    } else if (t instanceof Zh) {
                        this._setRanges(t.getRanges(), t.isBackward)
                    } else if (t && typeof t.getRanges == "function") {
                        this._setRanges(t.getRanges(), t.isBackward)
                    } else if (t instanceof Gh) {
                        this._setRanges([t], !!e && !!e.backward)
                    } else if (t instanceof $h) {
                        this._setRanges([new Gh(t)])
                    } else if (t instanceof Dh) {
                        const i = !!n && !!n.backward;
                        let o;
                        if (e == "in") {
                            o = Gh._createIn(t)
                        } else if (e == "on") {
                            o = Gh._createOn(t)
                        } else if (e !== undefined) {
                            o = new Gh($h._createAt(t, e))
                        } else {
                            throw new rr["b"]("model-selection-setTo-required-second-parameter: " + "selection.setTo requires the second parameter when the first parameter is a node.", [this, t])
                        }
                        this._setRanges([o], i)
                    } else if (jr(t)) {
                        this._setRanges(t, e && !!e.backward)
                    } else {
                        throw new rr["b"]("model-selection-setTo-not-selectable: Cannot set the selection to the given place.", [this, t])
                    }
                }
                _setRanges(t, e = false) {
                    t = Array.from(t);
                    const n = t.some(e => {
                        if (!(e instanceof Gh)) {
                            throw new rr["b"]("model-selection-set-ranges-not-range: " + "Selection range set to an object that is not an instance of model.Range.", [this, t])
                        }
                        return this._ranges.every(t => !t.isEqual(e))
                    }
                    );
                    if (t.length === this._ranges.length && !n) {
                        return
                    }
                    this._removeAllRanges();
                    for (const e of t) {
                        this._pushRange(e)
                    }
                    this._lastRangeBackward = !!e;
                    this.fire("change:range", {
                        directChange: true
                    })
                }
                setFocus(t, e) {
                    if (this.anchor === null) {
                        throw new rr["b"]("model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.", [this, t])
                    }
                    const n = $h._createAt(t, e);
                    if (n.compareWith(this.focus) == "same") {
                        return
                    }
                    const i = this.anchor;
                    if (this._ranges.length) {
                        this._popRange()
                    }
                    if (n.compareWith(i) == "before") {
                        this._pushRange(new Gh(n, i));
                        this._lastRangeBackward = true
                    } else {
                        this._pushRange(new Gh(i, n));
                        this._lastRangeBackward = false
                    }
                    this.fire("change:range", {
                        directChange: true
                    })
                }
                getAttribute(t) {
                    return this._attrs.get(t)
                }
                getAttributes() {
                    return this._attrs.entries()
                }
                getAttributeKeys() {
                    return this._attrs.keys()
                }
                hasAttribute(t) {
                    return this._attrs.has(t)
                }
                removeAttribute(t) {
                    if (this.hasAttribute(t)) {
                        this._attrs.delete(t);
                        this.fire("change:attribute", {
                            attributeKeys: [t],
                            directChange: true
                        })
                    }
                }
                setAttribute(t, e) {
                    if (this.getAttribute(t) !== e) {
                        this._attrs.set(t, e);
                        this.fire("change:attribute", {
                            attributeKeys: [t],
                            directChange: true
                        })
                    }
                }
                getSelectedElement() {
                    if (this.rangeCount !== 1) {
                        return null
                    }
                    const t = this.getFirstRange();
                    const e = t.start.nodeAfter;
                    const n = t.end.nodeBefore;
                    return e instanceof Hh && e == n ? e : null
                }
                is(t) {
                    return t == "selection" || t == "model:selection"
                }
                *getSelectedBlocks() {
                    const t = new WeakSet;
                    for (const e of this.getRanges()) {
                        const n = nf(e.start, t);
                        if (n && of(n, e)) {
                            yield n
                        }
                        for (const n of e.getWalker()) {
                            const i = n.item;
                            if (n.type == "elementEnd" && ef(i, t, e)) {
                                yield i
                            }
                        }
                        const i = nf(e.end, t);
                        if (i && !e.end.isTouching($h._createAt(i, 0)) && of(i, e)) {
                            yield i
                        }
                    }
                }
                containsEntireContent(t = this.anchor.root) {
                    const e = $h._createAt(t, 0);
                    const n = $h._createAt(t, "end");
                    return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
                }
                _pushRange(t) {
                    this._checkRange(t);
                    this._ranges.push(new Gh(t.start, t.end))
                }
                _checkRange(t) {
                    for (let e = 0; e < this._ranges.length; e++) {
                        if (t.isIntersecting(this._ranges[e])) {
                            throw new rr["b"]("model-selection-range-intersects: Trying to add a range that intersects with another range in the selection.", [this, t], {
                                addedRange: t,
                                intersectingRange: this._ranges[e]
                            })
                        }
                    }
                }
                _removeAllRanges() {
                    while (this._ranges.length > 0) {
                        this._popRange()
                    }
                }
                _popRange() {
                    this._ranges.pop()
                }
            }
            vr(Zh, dr);
            function tf(t, e) {
                if (e.has(t)) {
                    return false
                }
                e.add(t);
                return t.document.model.schema.isBlock(t) && t.parent
            }
            function ef(t, e, n) {
                return tf(t, e) && of(t, n)
            }
            function nf(t, e) {
                const n = t.parent.document.model.schema;
                const i = t.parent.getAncestors({
                    parentFirst: true,
                    includeSelf: true
                });
                let o = false;
                const s = i.find(t => {
                    if (o) {
                        return false
                    }
                    o = n.isLimit(t);
                    return !o && tf(t, e)
                }
                );
                i.forEach(t => e.add(t));
                return s
            }
            function of(t, e) {
                const n = sf(t);
                if (!n) {
                    return true
                }
                const i = e.containsRange(Gh._createOn(n), true);
                return !i
            }
            function sf(t) {
                const e = t.document.model.schema;
                let n = t.parent;
                while (n) {
                    if (e.isBlock(n)) {
                        return n
                    }
                    n = n.parent
                }
            }
            class rf extends Gh {
                constructor(t, e) {
                    super(t, e);
                    af.call(this)
                }
                detach() {
                    this.stopListening()
                }
                is(t) {
                    return t == "liveRange" || t == "model:liveRange" || super.is(t)
                }
                toRange() {
                    return new Gh(this.start, this.end)
                }
                static fromRange(t) {
                    return new rf(t.start, t.end)
                }
            }
            function af() {
                this.listenTo(this.root.document.model, "applyOperation", (t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation) {
                        return
                    }
                    cf.call(this, n)
                }
                    , {
                        priority: "low"
                    })
            }
            function cf(t) {
                const e = this.getTransformedByOperation(t);
                const n = Gh._createFromRanges(e);
                const i = !n.isEqual(this);
                const o = lf(this, t);
                let s = null;
                if (i) {
                    if (n.root.rootName == "$graveyard") {
                        if (t.type == "remove") {
                            s = t.sourcePosition
                        } else {
                            s = t.deletionPosition
                        }
                    }
                    const e = this.toRange();
                    this.start = n.start;
                    this.end = n.end;
                    this.fire("change:range", e, {
                        deletionPosition: s
                    })
                } else if (o) {
                    this.fire("change:content", this.toRange(), {
                        deletionPosition: s
                    })
                }
            }
            function lf(t, e) {
                switch (e.type) {
                    case "insert":
                        return t.containsPosition(e.position);
                    case "move":
                    case "remove":
                    case "reinsert":
                    case "merge":
                        return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition);
                    case "split":
                        return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
                }
                return false
            }
            vr(rf, dr);
            const df = "selection:";
            class uf {
                constructor(t) {
                    this._selection = new hf(t);
                    this._selection.delegate("change:range").to(this);
                    this._selection.delegate("change:attribute").to(this);
                    this._selection.delegate("change:marker").to(this)
                }
                get isCollapsed() {
                    return this._selection.isCollapsed
                }
                get anchor() {
                    return this._selection.anchor
                }
                get focus() {
                    return this._selection.focus
                }
                get rangeCount() {
                    return this._selection.rangeCount
                }
                get hasOwnRange() {
                    return this._selection.hasOwnRange
                }
                get isBackward() {
                    return this._selection.isBackward
                }
                get isGravityOverridden() {
                    return this._selection.isGravityOverridden
                }
                get markers() {
                    return this._selection.markers
                }
                get _ranges() {
                    return this._selection._ranges
                }
                getRanges() {
                    return this._selection.getRanges()
                }
                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }
                getLastPosition() {
                    return this._selection.getLastPosition()
                }
                getFirstRange() {
                    return this._selection.getFirstRange()
                }
                getLastRange() {
                    return this._selection.getLastRange()
                }
                getSelectedBlocks() {
                    return this._selection.getSelectedBlocks()
                }
                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }
                containsEntireContent(t) {
                    return this._selection.containsEntireContent(t)
                }
                destroy() {
                    this._selection.destroy()
                }
                getAttributeKeys() {
                    return this._selection.getAttributeKeys()
                }
                getAttributes() {
                    return this._selection.getAttributes()
                }
                getAttribute(t) {
                    return this._selection.getAttribute(t)
                }
                hasAttribute(t) {
                    return this._selection.hasAttribute(t)
                }
                refresh() {
                    this._selection._updateMarkers();
                    this._selection._updateAttributes(false)
                }
                is(t) {
                    return t == "selection" || t == "model:selection" || t == "documentSelection" || t == "model:documentSelection"
                }
                _setFocus(t, e) {
                    this._selection.setFocus(t, e)
                }
                _setTo(t, e, n) {
                    this._selection.setTo(t, e, n)
                }
                _setAttribute(t, e) {
                    this._selection.setAttribute(t, e)
                }
                _removeAttribute(t) {
                    this._selection.removeAttribute(t)
                }
                _getStoredAttributes() {
                    return this._selection._getStoredAttributes()
                }
                _overrideGravity() {
                    return this._selection.overrideGravity()
                }
                _restoreGravity(t) {
                    this._selection.restoreGravity(t)
                }
                static _getStoreAttributeKey(t) {
                    return df + t
                }
                static _isStoreAttributeKey(t) {
                    return t.startsWith(df)
                }
            }
            vr(uf, dr);
            class hf extends Zh {
                constructor(t) {
                    super();
                    this.markers = new yr({
                        idProperty: "name"
                    });
                    this._model = t.model;
                    this._document = t;
                    this._attributePriority = new Map;
                    this._fixGraveyardRangesData = [];
                    this._hasChangedRange = false;
                    this._overriddenGravityRegister = new Set;
                    this.listenTo(this._model, "applyOperation", (t, e) => {
                        const n = e[0];
                        if (!n.isDocumentOperation || n.type == "marker" || n.type == "rename" || n.type == "noop") {
                            return
                        }
                        while (this._fixGraveyardRangesData.length) {
                            const { liveRange: t, sourcePosition: e } = this._fixGraveyardRangesData.shift();
                            this._fixGraveyardSelection(t, e)
                        }
                        if (this._hasChangedRange) {
                            this._hasChangedRange = false;
                            this.fire("change:range", {
                                directChange: false
                            })
                        }
                    }
                        , {
                            priority: "lowest"
                        });
                    this.on("change:range", () => {
                        for (const t of this.getRanges()) {
                            if (!this._document._validateSelectionRange(t)) {
                                throw new rr["b"]("document-selection-wrong-position: Range from document selection starts or ends at incorrect position.", this, {
                                    range: t
                                })
                            }
                        }
                    }
                    );
                    this.listenTo(this._model.markers, "update", () => this._updateMarkers());
                    this.listenTo(this._document, "change", (t, e) => {
                        pf(this._model, e)
                    }
                    )
                }
                get isCollapsed() {
                    const t = this._ranges.length;
                    return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
                }
                get anchor() {
                    return super.anchor || this._document._getDefaultRange().start
                }
                get focus() {
                    return super.focus || this._document._getDefaultRange().end
                }
                get rangeCount() {
                    return this._ranges.length ? this._ranges.length : 1
                }
                get hasOwnRange() {
                    return this._ranges.length > 0
                }
                get isGravityOverridden() {
                    return !!this._overriddenGravityRegister.size
                }
                destroy() {
                    for (let t = 0; t < this._ranges.length; t++) {
                        this._ranges[t].detach()
                    }
                    this.stopListening()
                }
                *getRanges() {
                    if (this._ranges.length) {
                        yield* super.getRanges()
                    } else {
                        yield this._document._getDefaultRange()
                    }
                }
                getFirstRange() {
                    return super.getFirstRange() || this._document._getDefaultRange()
                }
                getLastRange() {
                    return super.getLastRange() || this._document._getDefaultRange()
                }
                setTo(t, e, n) {
                    super.setTo(t, e, n);
                    this._updateAttributes(true);
                    this._updateMarkers()
                }
                setFocus(t, e) {
                    super.setFocus(t, e);
                    this._updateAttributes(true);
                    this._updateMarkers()
                }
                setAttribute(t, e) {
                    if (this._setAttribute(t, e)) {
                        const e = [t];
                        this.fire("change:attribute", {
                            attributeKeys: e,
                            directChange: true
                        })
                    }
                }
                removeAttribute(t) {
                    if (this._removeAttribute(t)) {
                        const e = [t];
                        this.fire("change:attribute", {
                            attributeKeys: e,
                            directChange: true
                        })
                    }
                }
                overrideGravity() {
                    const t = nr();
                    this._overriddenGravityRegister.add(t);
                    if (this._overriddenGravityRegister.size === 1) {
                        this._updateAttributes(true)
                    }
                    return t
                }
                restoreGravity(t) {
                    if (!this._overriddenGravityRegister.has(t)) {
                        throw new rr["b"]("document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.", this, {
                            uid: t
                        })
                    }
                    this._overriddenGravityRegister.delete(t);
                    if (!this.isGravityOverridden) {
                        this._updateAttributes(true)
                    }
                }
                _popRange() {
                    this._ranges.pop().detach()
                }
                _pushRange(t) {
                    const e = this._prepareRange(t);
                    if (e) {
                        this._ranges.push(e)
                    }
                }
                _prepareRange(t) {
                    this._checkRange(t);
                    if (t.root == this._document.graveyard) {
                        return
                    }
                    const e = rf.fromRange(t);
                    e.on("change:range", (t, n, i) => {
                        this._hasChangedRange = true;
                        if (e.root == this._document.graveyard) {
                            this._fixGraveyardRangesData.push({
                                liveRange: e,
                                sourcePosition: i.deletionPosition
                            })
                        }
                    }
                    );
                    return e
                }
                _updateMarkers() {
                    const t = [];
                    let e = false;
                    for (const e of this._model.markers) {
                        const n = e.getRange();
                        for (const i of this.getRanges()) {
                            if (n.containsRange(i, !i.isCollapsed)) {
                                t.push(e)
                            }
                        }
                    }
                    const n = Array.from(this.markers);
                    for (const n of t) {
                        if (!this.markers.has(n)) {
                            this.markers.add(n);
                            e = true
                        }
                    }
                    for (const n of Array.from(this.markers)) {
                        if (!t.includes(n)) {
                            this.markers.remove(n);
                            e = true
                        }
                    }
                    if (e) {
                        this.fire("change:marker", {
                            oldMarkers: n,
                            directChange: false
                        })
                    }
                }
                _updateAttributes(t) {
                    const e = Hr(this._getSurroundingAttributes());
                    const n = Hr(this.getAttributes());
                    if (t) {
                        this._attributePriority = new Map;
                        this._attrs = new Map
                    } else {
                        for (const [t, e] of this._attributePriority) {
                            if (e == "low") {
                                this._attrs.delete(t);
                                this._attributePriority.delete(t)
                            }
                        }
                    }
                    this._setAttributesTo(e);
                    const i = [];
                    for (const [t, e] of this.getAttributes()) {
                        if (!n.has(t) || n.get(t) !== e) {
                            i.push(t)
                        }
                    }
                    for (const [t] of n) {
                        if (!this.hasAttribute(t)) {
                            i.push(t)
                        }
                    }
                    if (i.length > 0) {
                        this.fire("change:attribute", {
                            attributeKeys: i,
                            directChange: false
                        })
                    }
                }
                _setAttribute(t, e, n = true) {
                    const i = n ? "normal" : "low";
                    if (i == "low" && this._attributePriority.get(t) == "normal") {
                        return false
                    }
                    const o = super.getAttribute(t);
                    if (o === e) {
                        return false
                    }
                    this._attrs.set(t, e);
                    this._attributePriority.set(t, i);
                    return true
                }
                _removeAttribute(t, e = true) {
                    const n = e ? "normal" : "low";
                    if (n == "low" && this._attributePriority.get(t) == "normal") {
                        return false
                    }
                    this._attributePriority.set(t, n);
                    if (!super.hasAttribute(t)) {
                        return false
                    }
                    this._attrs.delete(t);
                    return true
                }
                _setAttributesTo(t) {
                    const e = new Set;
                    for (const [e, n] of this.getAttributes()) {
                        if (t.get(e) === n) {
                            continue
                        }
                        this._removeAttribute(e, false)
                    }
                    for (const [n, i] of t) {
                        const t = this._setAttribute(n, i, false);
                        if (t) {
                            e.add(n)
                        }
                    }
                    return e
                }
                *_getStoredAttributes() {
                    const t = this.getFirstPosition().parent;
                    if (this.isCollapsed && t.isEmpty) {
                        for (const e of t.getAttributeKeys()) {
                            if (e.startsWith(df)) {
                                const n = e.substr(df.length);
                                yield [n, t.getAttribute(e)]
                            }
                        }
                    }
                }
                _getSurroundingAttributes() {
                    const t = this.getFirstPosition();
                    const e = this._model.schema;
                    let n = null;
                    if (!this.isCollapsed) {
                        const t = this.getFirstRange();
                        for (const i of t) {
                            if (i.item.is("element") && e.isObject(i.item)) {
                                break
                            }
                            if (i.type == "text") {
                                n = i.item.getAttributes();
                                break
                            }
                        }
                    } else {
                        const e = t.textNode ? t.textNode : t.nodeBefore;
                        const i = t.textNode ? t.textNode : t.nodeAfter;
                        if (!this.isGravityOverridden) {
                            n = ff(e)
                        }
                        if (!n) {
                            n = ff(i)
                        }
                        if (!this.isGravityOverridden && !n) {
                            let t = e;
                            while (t && !n) {
                                t = t.previousSibling;
                                n = ff(t)
                            }
                        }
                        if (!n) {
                            let t = i;
                            while (t && !n) {
                                t = t.nextSibling;
                                n = ff(t)
                            }
                        }
                        if (!n) {
                            n = this._getStoredAttributes()
                        }
                    }
                    return n
                }
                _fixGraveyardSelection(t, e) {
                    const n = e.clone();
                    const i = this._model.schema.getNearestSelectionRange(n);
                    const o = this._ranges.indexOf(t);
                    this._ranges.splice(o, 1);
                    t.detach();
                    if (i) {
                        const t = this._prepareRange(i);
                        this._ranges.splice(o, 0, t)
                    }
                }
            }
            function ff(t) {
                if (t instanceof Lh || t instanceof zh) {
                    return t.getAttributes()
                }
                return null
            }
            function pf(t, e) {
                const n = t.document.differ;
                for (const i of n.getChanges()) {
                    if (i.type != "insert") {
                        continue
                    }
                    const n = i.position.parent;
                    const o = i.length === n.maxOffset;
                    if (o) {
                        t.enqueueChange(e, t => {
                            const e = Array.from(n.getAttributeKeys()).filter(t => t.startsWith(df));
                            for (const i of e) {
                                t.removeAttribute(i, n)
                            }
                        }
                        )
                    }
                }
            }
            class gf {
                constructor(t) {
                    this._dispatchers = t
                }
                add(t) {
                    for (const e of this._dispatchers) {
                        t(e)
                    }
                    return this
                }
            }
            var mf = 1
                , bf = 4;
            function wf(t) {
                return Hs(t, mf | bf)
            }
            var kf = wf;
            class _f extends gf {
                elementToElement(t) {
                    return this.add(Vf(t))
                }
                attributeToElement(t) {
                    return this.add(Bf(t))
                }
                attributeToAttribute(t) {
                    return this.add(Ff(t))
                }
                markerToElement(t) {
                    return this.add(Df(t))
                }
                markerToHighlight(t) {
                    return this.add(zf(t))
                }
            }
            function vf() {
                return (t, e, n) => {
                    if (!n.consumable.consume(e.item, "insert")) {
                        return
                    }
                    const i = n.writer;
                    const o = n.mapper.toViewPosition(e.range.start);
                    const s = i.createText(e.item.data);
                    i.insert(o, s)
                }
            }
            function yf() {
                return (t, e, n) => {
                    const i = n.mapper.toViewPosition(e.position);
                    const o = e.position.getShiftedBy(e.length);
                    const s = n.mapper.toViewPosition(o, {
                        isPhantom: true
                    });
                    const r = n.writer.createRange(i, s);
                    const a = n.writer.remove(r.getTrimmed());
                    for (const t of n.writer.createRangeIn(a).getItems()) {
                        n.mapper.unbindViewElement(t)
                    }
                }
            }
            function xf(t) {
                const e = new kl("span", t.attributes);
                if (t.classes) {
                    e._addClass(t.classes)
                }
                if (t.priority) {
                    e._priority = t.priority
                }
                e._id = t.id;
                return e
            }
            function Cf() {
                return (t, e, n) => {
                    const i = e.selection;
                    if (i.isCollapsed) {
                        return
                    }
                    if (!n.consumable.consume(i, "selection")) {
                        return
                    }
                    const o = [];
                    for (const t of i.getRanges()) {
                        const e = n.mapper.toViewRange(t);
                        o.push(e)
                    }
                    n.writer.setSelection(o, {
                        backward: i.isBackward
                    })
                }
            }
            function Af() {
                return (t, e, n) => {
                    const i = e.selection;
                    if (!i.isCollapsed) {
                        return
                    }
                    if (!n.consumable.consume(i, "selection")) {
                        return
                    }
                    const o = n.writer;
                    const s = i.getFirstPosition();
                    const r = n.mapper.toViewPosition(s);
                    const a = o.breakAttributes(r);
                    o.setSelection(a)
                }
            }
            function Pf() {
                return (t, e, n) => {
                    const i = n.writer;
                    const o = i.document.selection;
                    for (const t of o.getRanges()) {
                        if (t.isCollapsed) {
                            if (t.end.parent.document) {
                                n.writer.mergeAttributes(t.start)
                            }
                        }
                    }
                    i.setSelection(null)
                }
            }
            function Tf(t) {
                return (e, n, i) => {
                    const o = t(n.attributeOldValue, i.writer);
                    const s = t(n.attributeNewValue, i.writer);
                    if (!o && !s) {
                        return
                    }
                    if (!i.consumable.consume(n.item, e.name)) {
                        return
                    }
                    const r = i.writer;
                    const a = r.document.selection;
                    if (n.item instanceof Zh || n.item instanceof uf) {
                        r.wrap(a.getFirstRange(), s)
                    } else {
                        let t = i.mapper.toViewRange(n.range);
                        if (n.attributeOldValue !== null && o) {
                            t = r.unwrap(t, o)
                        }
                        if (n.attributeNewValue !== null && s) {
                            r.wrap(t, s)
                        }
                    }
                }
            }
            function Sf(t) {
                return (e, n, i) => {
                    const o = t(n.item, i.writer);
                    if (!o) {
                        return
                    }
                    if (!i.consumable.consume(n.item, "insert")) {
                        return
                    }
                    const s = i.mapper.toViewPosition(n.range.start);
                    i.mapper.bindElements(n.item, o);
                    i.writer.insert(s, o)
                }
            }
            function Ef(t) {
                return (e, n, i) => {
                    n.isOpening = true;
                    const o = t(n, i.writer);
                    n.isOpening = false;
                    const s = t(n, i.writer);
                    if (!o || !s) {
                        return
                    }
                    const r = n.markerRange;
                    if (r.isCollapsed && !i.consumable.consume(r, e.name)) {
                        return
                    }
                    for (const t of r) {
                        if (!i.consumable.consume(t.item, e.name)) {
                            return
                        }
                    }
                    const a = i.mapper;
                    const c = i.writer;
                    c.insert(a.toViewPosition(r.start), o);
                    i.mapper.bindElementToMarker(o, n.markerName);
                    if (!r.isCollapsed) {
                        c.insert(a.toViewPosition(r.end), s);
                        i.mapper.bindElementToMarker(s, n.markerName)
                    }
                    e.stop()
                }
            }
            function Rf() {
                return (t, e, n) => {
                    const i = n.mapper.markerNameToElements(e.markerName);
                    if (!i) {
                        return
                    }
                    for (const t of i) {
                        n.mapper.unbindElementFromMarkerName(t, e.markerName);
                        n.writer.clear(n.writer.createRangeOn(t), t)
                    }
                    n.writer.clearClonedElementsGroup(e.markerName);
                    t.stop()
                }
            }
            function Of(t) {
                return (e, n, i) => {
                    const o = t(n.attributeOldValue, n);
                    const s = t(n.attributeNewValue, n);
                    if (!o && !s) {
                        return
                    }
                    if (!i.consumable.consume(n.item, e.name)) {
                        return
                    }
                    const r = i.mapper.toViewElement(n.item);
                    const a = i.writer;
                    if (!r) {
                        throw new rr["b"]("conversion-attribute-to-attribute-on-text: " + "Trying to convert text node's attribute with attribute-to-attribute converter.", [n, i])
                    }
                    if (n.attributeOldValue !== null && o) {
                        if (o.key == "class") {
                            const t = Array.isArray(o.value) ? o.value : [o.value];
                            for (const e of t) {
                                a.removeClass(e, r)
                            }
                        } else if (o.key == "style") {
                            const t = Object.keys(o.value);
                            for (const e of t) {
                                a.removeStyle(e, r)
                            }
                        } else {
                            a.removeAttribute(o.key, r)
                        }
                    }
                    if (n.attributeNewValue !== null && s) {
                        if (s.key == "class") {
                            const t = Array.isArray(s.value) ? s.value : [s.value];
                            for (const e of t) {
                                a.addClass(e, r)
                            }
                        } else if (s.key == "style") {
                            const t = Object.keys(s.value);
                            for (const e of t) {
                                a.setStyle(e, s.value[e], r)
                            }
                        } else {
                            a.setAttribute(s.key, s.value, r)
                        }
                    }
                }
            }
            function Mf(t) {
                return (e, n, i) => {
                    if (!n.item) {
                        return
                    }
                    if (!(n.item instanceof Zh || n.item instanceof uf) && !n.item.is("textProxy")) {
                        return
                    }
                    const o = Wf(t, n, i);
                    if (!o) {
                        return
                    }
                    if (!i.consumable.consume(n.item, e.name)) {
                        return
                    }
                    const s = xf(o);
                    const r = i.writer;
                    const a = r.document.selection;
                    if (n.item instanceof Zh || n.item instanceof uf) {
                        r.wrap(a.getFirstRange(), s, a)
                    } else {
                        const t = i.mapper.toViewRange(n.range);
                        const e = r.wrap(t, s);
                        for (const t of e.getItems()) {
                            if (t.is("attributeElement") && t.isSimilar(s)) {
                                i.mapper.bindElementToMarker(t, n.markerName);
                                break
                            }
                        }
                    }
                }
            }
            function Nf(t) {
                return (e, n, i) => {
                    if (!n.item) {
                        return
                    }
                    if (!(n.item instanceof Hh)) {
                        return
                    }
                    const o = Wf(t, n, i);
                    if (!o) {
                        return
                    }
                    if (!i.consumable.test(n.item, e.name)) {
                        return
                    }
                    const s = i.mapper.toViewElement(n.item);
                    if (s && s.getCustomProperty("addHighlight")) {
                        i.consumable.consume(n.item, e.name);
                        for (const t of Gh._createIn(n.item)) {
                            i.consumable.consume(t.item, e.name)
                        }
                        s.getCustomProperty("addHighlight")(s, o, i.writer);
                        i.mapper.bindElementToMarker(s, n.markerName)
                    }
                }
            }
            function If(t) {
                return (e, n, i) => {
                    if (n.markerRange.isCollapsed) {
                        return
                    }
                    const o = Wf(t, n, i);
                    if (!o) {
                        return
                    }
                    const s = xf(o);
                    const r = i.mapper.markerNameToElements(n.markerName);
                    if (!r) {
                        return
                    }
                    for (const t of r) {
                        i.mapper.unbindElementFromMarkerName(t, n.markerName);
                        if (t.is("attributeElement")) {
                            i.writer.unwrap(i.writer.createRangeOn(t), s)
                        } else {
                            t.getCustomProperty("removeHighlight")(t, o.id, i.writer)
                        }
                    }
                    i.writer.clearClonedElementsGroup(n.markerName);
                    e.stop()
                }
            }
            function Vf(t) {
                t = kf(t);
                t.view = Lf(t.view, "container");
                return e => {
                    e.on("insert:" + t.model, Sf(t.view), {
                        priority: t.converterPriority || "normal"
                    })
                }
            }
            function Bf(t) {
                t = kf(t);
                const e = t.model.key ? t.model.key : t.model;
                let n = "attribute:" + e;
                if (t.model.name) {
                    n += ":" + t.model.name
                }
                if (t.model.values) {
                    for (const e of t.model.values) {
                        t.view[e] = Lf(t.view[e], "attribute")
                    }
                } else {
                    t.view = Lf(t.view, "attribute")
                }
                const i = Hf(t);
                return e => {
                    e.on(n, Tf(i), {
                        priority: t.converterPriority || "normal"
                    })
                }
            }
            function Ff(t) {
                t = kf(t);
                const e = t.model.key ? t.model.key : t.model;
                let n = "attribute:" + e;
                if (t.model.name) {
                    n += ":" + t.model.name
                }
                if (t.model.values) {
                    for (const e of t.model.values) {
                        t.view[e] = qf(t.view[e])
                    }
                } else {
                    t.view = qf(t.view)
                }
                const i = Hf(t);
                return e => {
                    e.on(n, Of(i), {
                        priority: t.converterPriority || "normal"
                    })
                }
            }
            function Df(t) {
                t = kf(t);
                t.view = Lf(t.view, "ui");
                return e => {
                    e.on("addMarker:" + t.model, Ef(t.view), {
                        priority: t.converterPriority || "normal"
                    });
                    e.on("removeMarker:" + t.model, Rf(t.view), {
                        priority: t.converterPriority || "normal"
                    })
                }
            }
            function zf(t) {
                return e => {
                    e.on("addMarker:" + t.model, Mf(t.view), {
                        priority: t.converterPriority || "normal"
                    });
                    e.on("addMarker:" + t.model, Nf(t.view), {
                        priority: t.converterPriority || "normal"
                    });
                    e.on("removeMarker:" + t.model, If(t.view), {
                        priority: t.converterPriority || "normal"
                    })
                }
            }
            function Lf(t, e) {
                if (typeof t == "function") {
                    return t
                }
                return (n, i) => jf(t, i, e)
            }
            function jf(t, e, n) {
                if (typeof t == "string") {
                    t = {
                        name: t
                    }
                }
                let i;
                const o = Object.assign({}, t.attributes);
                if (n == "container") {
                    i = e.createContainerElement(t.name, o)
                } else if (n == "attribute") {
                    const n = {
                        priority: t.priority || kl.DEFAULT_PRIORITY
                    };
                    i = e.createAttributeElement(t.name, o, n)
                } else {
                    i = e.createUIElement(t.name, o)
                }
                if (t.styles) {
                    const n = Object.keys(t.styles);
                    for (const o of n) {
                        e.setStyle(o, t.styles[o], i)
                    }
                }
                if (t.classes) {
                    const n = t.classes;
                    if (typeof n == "string") {
                        e.addClass(n, i)
                    } else {
                        for (const t of n) {
                            e.addClass(t, i)
                        }
                    }
                }
                return i
            }
            function Hf(t) {
                if (t.model.values) {
                    return (e, n) => {
                        const i = t.view[e];
                        if (i) {
                            return i(e, n)
                        }
                        return null
                    }
                } else {
                    return t.view
                }
            }
            function qf(t) {
                if (typeof t == "string") {
                    return e => ({
                        key: t,
                        value: e
                    })
                } else if (typeof t == "object") {
                    if (t.value) {
                        return () => t
                    } else {
                        return e => ({
                            key: t.key,
                            value: e
                        })
                    }
                } else {
                    return t
                }
            }
            function Wf(t, e, n) {
                const i = typeof t == "function" ? t(e, n) : t;
                if (!i) {
                    return null
                }
                if (!i.priority) {
                    i.priority = 10
                }
                if (!i.id) {
                    i.id = e.markerName
                }
                return i
            }
            class Uf extends gf {
                elementToElement(t) {
                    return this.add(Jf(t))
                }
                elementToAttribute(t) {
                    return this.add(Qf(t))
                }
                attributeToAttribute(t) {
                    return this.add(Yf(t))
                }
                elementToMarker(t) {
                    return this.add(Xf(t))
                }
            }
            function $f() {
                return (t, e, n) => {
                    if (!e.modelRange && n.consumable.consume(e.viewItem, {
                        name: true
                    })) {
                        const { modelRange: t, modelCursor: i } = n.convertChildren(e.viewItem, e.modelCursor);
                        e.modelRange = t;
                        e.modelCursor = i
                    }
                }
            }
            function Gf() {
                return (t, e, n) => {
                    if (n.schema.checkChild(e.modelCursor, "$text")) {
                        if (n.consumable.consume(e.viewItem)) {
                            const t = n.writer.createText(e.viewItem.data);
                            n.writer.insert(t, e.modelCursor);
                            e.modelRange = Gh._createFromPositionAndShift(e.modelCursor, t.offsetSize);
                            e.modelCursor = e.modelRange.end
                        }
                    }
                }
            }
            function Kf(t, e) {
                return (n, i) => {
                    const o = i.newSelection;
                    const s = new Zh;
                    const r = [];
                    for (const t of o.getRanges()) {
                        r.push(e.toModelRange(t))
                    }
                    s.setTo(r, {
                        backward: o.isBackward
                    });
                    if (!s.isEqual(t.document.selection)) {
                        t.change(t => {
                            t.setSelection(s)
                        }
                        )
                    }
                }
            }
            function Jf(t) {
                t = kf(t);
                const e = tp(t);
                const n = Zf(t.view);
                const i = n ? "element:" + n : "element";
                return n => {
                    n.on(i, e, {
                        priority: t.converterPriority || "normal"
                    })
                }
            }
            function Qf(t) {
                t = kf(t);
                ip(t);
                const e = op(t, false);
                const n = Zf(t.view);
                const i = n ? "element:" + n : "element";
                return n => {
                    n.on(i, e, {
                        priority: t.converterPriority || "low"
                    })
                }
            }
            function Yf(t) {
                t = kf(t);
                let e = null;
                if (typeof t.view == "string" || t.view.key) {
                    e = np(t)
                }
                ip(t, e);
                const n = op(t, true);
                return e => {
                    e.on("element", n, {
                        priority: t.converterPriority || "low"
                    })
                }
            }
            function Xf(t) {
                t = kf(t);
                ap(t);
                return Jf(t)
            }
            function Zf(t) {
                if (typeof t == "string") {
                    return t
                }
                if (typeof t == "object" && typeof t.name == "string") {
                    return t.name
                }
                return null
            }
            function tp(t) {
                const e = t.view ? new qr(t.view) : null;
                return (n, i, o) => {
                    let s = {};
                    if (e) {
                        const t = e.match(i.viewItem);
                        if (!t) {
                            return
                        }
                        s = t.match
                    }
                    s.name = true;
                    const r = ep(t.model, i.viewItem, o.writer);
                    if (!r) {
                        return
                    }
                    if (!o.consumable.test(i.viewItem, s)) {
                        return
                    }
                    const a = o.splitToAllowedParent(r, i.modelCursor);
                    if (!a) {
                        return
                    }
                    o.writer.insert(r, a.position);
                    o.convertChildren(i.viewItem, o.writer.createPositionAt(r, 0));
                    o.consumable.consume(i.viewItem, s);
                    const c = o.getSplitParts(r);
                    i.modelRange = new Gh(o.writer.createPositionBefore(r), o.writer.createPositionAfter(c[c.length - 1]));
                    if (a.cursorParent) {
                        i.modelCursor = o.writer.createPositionAt(a.cursorParent, 0)
                    } else {
                        i.modelCursor = i.modelRange.end
                    }
                }
            }
            function ep(t, e, n) {
                if (t instanceof Function) {
                    return t(e, n)
                } else {
                    return n.createElement(t)
                }
            }
            function np(t) {
                if (typeof t.view == "string") {
                    t.view = {
                        key: t.view
                    }
                }
                const e = t.view.key;
                let n;
                if (e == "class" || e == "style") {
                    const i = e == "class" ? "classes" : "styles";
                    n = {
                        [i]: t.view.value
                    }
                } else {
                    const i = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value;
                    n = {
                        attributes: {
                            [e]: i
                        }
                    }
                }
                if (t.view.name) {
                    n.name = t.view.name
                }
                t.view = n;
                return e
            }
            function ip(t, e = null) {
                const n = e === null ? true : t => t.getAttribute(e);
                const i = typeof t.model != "object" ? t.model : t.model.key;
                const o = typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value;
                t.model = {
                    key: i,
                    value: o
                }
            }
            function op(t, e) {
                const n = new qr(t.view);
                return (i, o, s) => {
                    const r = n.match(o.viewItem);
                    if (!r) {
                        return
                    }
                    const a = t.model.key;
                    const c = typeof t.model.value == "function" ? t.model.value(o.viewItem) : t.model.value;
                    if (c === null) {
                        return
                    }
                    if (sp(t.view, o.viewItem)) {
                        r.match.name = true
                    } else {
                        delete r.match.name
                    }
                    if (!s.consumable.test(o.viewItem, r.match)) {
                        return
                    }
                    if (!o.modelRange) {
                        o = Object.assign(o, s.convertChildren(o.viewItem, o.modelCursor))
                    }
                    const l = rp(o.modelRange, {
                        key: a,
                        value: c
                    }, e, s);
                    if (l) {
                        s.consumable.consume(o.viewItem, r.match)
                    }
                }
            }
            function sp(t, e) {
                const n = typeof t == "function" ? t(e) : t;
                if (typeof n == "object" && !Zf(n)) {
                    return false
                }
                return !n.classes && !n.attributes && !n.styles
            }
            function rp(t, e, n, i) {
                let o = false;
                for (const s of Array.from(t.getItems({
                    shallow: n
                }))) {
                    if (i.schema.checkAttribute(s, e.key)) {
                        i.writer.setAttribute(e.key, e.value, s);
                        o = true
                    }
                }
                return o
            }
            function ap(t) {
                const e = t.model;
                t.model = (t, n) => {
                    const i = typeof e == "string" ? e : e(t);
                    return n.createElement("$marker", {
                        "data-name": i
                    })
                }
            }
            class cp {
                constructor(t) {
                    this.model = t;
                    this.view = new Fh;
                    this.mapper = new Kh;
                    this.downcastDispatcher = new Yh({
                        mapper: this.mapper
                    });
                    const e = this.model.document;
                    const n = e.selection;
                    const i = this.model.markers;
                    this.listenTo(this.model, "_beforeChanges", () => {
                        this.view._disableRendering(true)
                    }
                        , {
                            priority: "highest"
                        });
                    this.listenTo(this.model, "_afterChanges", () => {
                        this.view._disableRendering(false)
                    }
                        , {
                            priority: "lowest"
                        });
                    this.listenTo(e, "change", () => {
                        this.view.change(t => {
                            this.downcastDispatcher.convertChanges(e.differ, i, t);
                            this.downcastDispatcher.convertSelection(n, i, t)
                        }
                        )
                    }
                        , {
                            priority: "low"
                        });
                    this.listenTo(this.view.document, "selectionChange", Kf(this.model, this.mapper));
                    this.downcastDispatcher.on("insert:$text", vf(), {
                        priority: "lowest"
                    });
                    this.downcastDispatcher.on("remove", yf(), {
                        priority: "low"
                    });
                    this.downcastDispatcher.on("selection", Pf(), {
                        priority: "low"
                    });
                    this.downcastDispatcher.on("selection", Cf(), {
                        priority: "low"
                    });
                    this.downcastDispatcher.on("selection", Af(), {
                        priority: "low"
                    });
                    this.view.document.roots.bindTo(this.model.document.roots).using(t => {
                        if (t.rootName == "$graveyard") {
                            return null
                        }
                        const e = new ll(t.name);
                        e.rootName = t.rootName;
                        e._document = this.view.document;
                        this.mapper.bindElements(t, e);
                        return e
                    }
                    )
                }
                destroy() {
                    this.view.destroy();
                    this.stopListening()
                }
            }
            vr(cp, Jc);
            class lp {
                constructor() {
                    this._commands = new Map
                }
                add(t, e) {
                    this._commands.set(t, e)
                }
                get(t) {
                    return this._commands.get(t)
                }
                execute(t, ...e) {
                    const n = this.get(t);
                    if (!n) {
                        throw new rr["b"]("commandcollection-command-not-found: Command does not exist.", this, {
                            commandName: t
                        })
                    }
                    n.execute(...e)
                }
                *names() {
                    yield* this._commands.keys()
                }
                *commands() {
                    yield* this._commands.values()
                }
                [Symbol.iterator]() {
                    return this._commands[Symbol.iterator]()
                }
                destroy() {
                    for (const t of this.commands()) {
                        t.destroy()
                    }
                }
            }
            class dp {
                constructor() {
                    this._consumables = new Map
                }
                add(t, e) {
                    let n;
                    if (t.is("text") || t.is("documentFragment")) {
                        this._consumables.set(t, true);
                        return
                    }
                    if (!this._consumables.has(t)) {
                        n = new up;
                        this._consumables.set(t, n)
                    } else {
                        n = this._consumables.get(t)
                    }
                    n.add(e)
                }
                test(t, e) {
                    const n = this._consumables.get(t);
                    if (n === undefined) {
                        return null
                    }
                    if (t.is("text") || t.is("documentFragment")) {
                        return n
                    }
                    return n.test(e)
                }
                consume(t, e) {
                    if (this.test(t, e)) {
                        if (t.is("text") || t.is("documentFragment")) {
                            this._consumables.set(t, false)
                        } else {
                            this._consumables.get(t).consume(e)
                        }
                        return true
                    }
                    return false
                }
                revert(t, e) {
                    const n = this._consumables.get(t);
                    if (n !== undefined) {
                        if (t.is("text") || t.is("documentFragment")) {
                            this._consumables.set(t, true)
                        } else {
                            n.revert(e)
                        }
                    }
                }
                static consumablesFromElement(t) {
                    const e = {
                        name: true,
                        attributes: [],
                        classes: [],
                        styles: []
                    };
                    const n = t.getAttributeKeys();
                    for (const t of n) {
                        if (t == "style" || t == "class") {
                            continue
                        }
                        e.attributes.push(t)
                    }
                    const i = t.getClassNames();
                    for (const t of i) {
                        e.classes.push(t)
                    }
                    const o = t.getStyleNames();
                    for (const t of o) {
                        e.styles.push(t)
                    }
                    return e
                }
                static createFrom(t, e) {
                    if (!e) {
                        e = new dp
                    }
                    if (t.is("text")) {
                        e.add(t);
                        return e
                    }
                    if (t.is("element")) {
                        e.add(t, dp.consumablesFromElement(t))
                    }
                    if (t.is("documentFragment")) {
                        e.add(t)
                    }
                    for (const n of t.getChildren()) {
                        e = dp.createFrom(n, e)
                    }
                    return e
                }
            }
            class up {
                constructor() {
                    this._canConsumeName = null;
                    this._consumables = {
                        attributes: new Map,
                        styles: new Map,
                        classes: new Map
                    }
                }
                add(t) {
                    if (t.name) {
                        this._canConsumeName = true
                    }
                    for (const e in this._consumables) {
                        if (e in t) {
                            this._add(e, t[e])
                        }
                    }
                }
                test(t) {
                    if (t.name && !this._canConsumeName) {
                        return this._canConsumeName
                    }
                    for (const e in this._consumables) {
                        if (e in t) {
                            const n = this._test(e, t[e]);
                            if (n !== true) {
                                return n
                            }
                        }
                    }
                    return true
                }
                consume(t) {
                    if (t.name) {
                        this._canConsumeName = false
                    }
                    for (const e in this._consumables) {
                        if (e in t) {
                            this._consume(e, t[e])
                        }
                    }
                }
                revert(t) {
                    if (t.name) {
                        this._canConsumeName = true
                    }
                    for (const e in this._consumables) {
                        if (e in t) {
                            this._revert(e, t[e])
                        }
                    }
                }
                _add(t, e) {
                    const n = Je(e) ? e : [e];
                    const i = this._consumables[t];
                    for (const e of n) {
                        if (t === "attributes" && (e === "class" || e === "style")) {
                            throw new rr["b"]("viewconsumable-invalid-attribute: Classes and styles should be handled separately.", this)
                        }
                        i.set(e, true);
                        if (t === "styles") {
                            for (const t of Mc.getRelatedStyles(e)) {
                                i.set(t, true)
                            }
                        }
                    }
                }
                _test(t, e) {
                    const n = Je(e) ? e : [e];
                    const i = this._consumables[t];
                    for (const e of n) {
                        if (t === "attributes" && (e === "class" || e === "style")) {
                            const t = e == "class" ? "classes" : "styles";
                            const n = this._test(t, [...this._consumables[t].keys()]);
                            if (n !== true) {
                                return n
                            }
                        } else {
                            const t = i.get(e);
                            if (t === undefined) {
                                return null
                            }
                            if (!t) {
                                return false
                            }
                        }
                    }
                    return true
                }
                _consume(t, e) {
                    const n = Je(e) ? e : [e];
                    const i = this._consumables[t];
                    for (const e of n) {
                        if (t === "attributes" && (e === "class" || e === "style")) {
                            const t = e == "class" ? "classes" : "styles";
                            this._consume(t, [...this._consumables[t].keys()])
                        } else {
                            i.set(e, false);
                            if (t == "styles") {
                                for (const t of Mc.getRelatedStyles(e)) {
                                    i.set(t, false)
                                }
                            }
                        }
                    }
                }
                _revert(t, e) {
                    const n = Je(e) ? e : [e];
                    const i = this._consumables[t];
                    for (const e of n) {
                        if (t === "attributes" && (e === "class" || e === "style")) {
                            const t = e == "class" ? "classes" : "styles";
                            this._revert(t, [...this._consumables[t].keys()])
                        } else {
                            const t = i.get(e);
                            if (t === false) {
                                i.set(e, true)
                            }
                        }
                    }
                }
            }
            class hp {
                constructor() {
                    this._sourceDefinitions = {};
                    this._attributeProperties = {};
                    this.decorate("checkChild");
                    this.decorate("checkAttribute");
                    this.on("checkAttribute", (t, e) => {
                        e[0] = new fp(e[0])
                    }
                        , {
                            priority: "highest"
                        });
                    this.on("checkChild", (t, e) => {
                        e[0] = new fp(e[0]);
                        e[1] = this.getDefinition(e[1])
                    }
                        , {
                            priority: "highest"
                        })
                }
                register(t, e) {
                    if (this._sourceDefinitions[t]) {
                        throw new rr["b"]("schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.", this, {
                            itemName: t
                        })
                    }
                    this._sourceDefinitions[t] = [Object.assign({}, e)];
                    this._clearCache()
                }
                extend(t, e) {
                    if (!this._sourceDefinitions[t]) {
                        throw new rr["b"]("schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.", this, {
                            itemName: t
                        })
                    }
                    this._sourceDefinitions[t].push(Object.assign({}, e));
                    this._clearCache()
                }
                getDefinitions() {
                    if (!this._compiledDefinitions) {
                        this._compile()
                    }
                    return this._compiledDefinitions
                }
                getDefinition(t) {
                    let e;
                    if (typeof t == "string") {
                        e = t
                    } else if (t.is && (t.is("text") || t.is("textProxy"))) {
                        e = "$text"
                    } else {
                        e = t.name
                    }
                    return this.getDefinitions()[e]
                }
                isRegistered(t) {
                    return !!this.getDefinition(t)
                }
                isBlock(t) {
                    const e = this.getDefinition(t);
                    return !!(e && e.isBlock)
                }
                isLimit(t) {
                    const e = this.getDefinition(t);
                    if (!e) {
                        return false
                    }
                    return !!(e.isLimit || e.isObject)
                }
                isObject(t) {
                    const e = this.getDefinition(t);
                    return !!(e && e.isObject)
                }
                isInline(t) {
                    const e = this.getDefinition(t);
                    return !!(e && e.isInline)
                }
                checkChild(t, e) {
                    if (!e) {
                        return false
                    }
                    return this._checkContextMatch(e, t)
                }
                checkAttribute(t, e) {
                    const n = this.getDefinition(t.last);
                    if (!n) {
                        return false
                    }
                    return n.allowAttributes.includes(e)
                }
                checkMerge(t, e = null) {
                    if (t instanceof $h) {
                        const e = t.nodeBefore;
                        const n = t.nodeAfter;
                        if (!(e instanceof Hh)) {
                            throw new rr["b"]("schema-check-merge-no-element-before: The node before the merge position must be an element.", this)
                        }
                        if (!(n instanceof Hh)) {
                            throw new rr["b"]("schema-check-merge-no-element-after: The node after the merge position must be an element.", this)
                        }
                        return this.checkMerge(e, n)
                    }
                    for (const n of e.getChildren()) {
                        if (!this.checkChild(t, n)) {
                            return false
                        }
                    }
                    return true
                }
                addChildCheck(t) {
                    this.on("checkChild", (e, [n, i]) => {
                        if (!i) {
                            return
                        }
                        const o = t(n, i);
                        if (typeof o == "boolean") {
                            e.stop();
                            e.return = o
                        }
                    }
                        , {
                            priority: "high"
                        })
                }
                addAttributeCheck(t) {
                    this.on("checkAttribute", (e, [n, i]) => {
                        const o = t(n, i);
                        if (typeof o == "boolean") {
                            e.stop();
                            e.return = o
                        }
                    }
                        , {
                            priority: "high"
                        })
                }
                setAttributeProperties(t, e) {
                    this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
                }
                getAttributeProperties(t) {
                    return this._attributeProperties[t] || {}
                }
                getLimitElement(t) {
                    let e;
                    if (t instanceof $h) {
                        e = t.parent
                    } else {
                        const n = t instanceof Gh ? [t] : Array.from(t.getRanges());
                        e = n.reduce((t, e) => {
                            const n = e.getCommonAncestor();
                            if (!t) {
                                return n
                            }
                            return t.getCommonAncestor(n, {
                                includeSelf: true
                            })
                        }
                            , null)
                    }
                    while (!this.isLimit(e)) {
                        if (e.parent) {
                            e = e.parent
                        } else {
                            break
                        }
                    }
                    return e
                }
                checkAttributeInSelection(t, e) {
                    if (t.isCollapsed) {
                        const n = t.getFirstPosition();
                        const i = [...n.getAncestors(), new zh("", t.getAttributes())];
                        return this.checkAttribute(i, e)
                    } else {
                        const n = t.getRanges();
                        for (const t of n) {
                            for (const n of t) {
                                if (this.checkAttribute(n.item, e)) {
                                    return true
                                }
                            }
                        }
                    }
                    return false
                }
                *getValidRanges(t, e) {
                    t = Sp(t);
                    for (const n of t) {
                        yield* this._getValidRangesForRange(n, e)
                    }
                }
                getNearestSelectionRange(t, e = "both") {
                    if (this.checkChild(t, "$text")) {
                        return new Gh(t)
                    }
                    let n, i;
                    if (e == "both" || e == "backward") {
                        n = new Wh({
                            startPosition: t,
                            direction: "backward"
                        })
                    }
                    if (e == "both" || e == "forward") {
                        i = new Wh({
                            startPosition: t
                        })
                    }
                    for (const t of Tp(n, i)) {
                        const e = t.walker == n ? "elementEnd" : "elementStart";
                        const i = t.value;
                        if (i.type == e && this.isObject(i.item)) {
                            return Gh._createOn(i.item)
                        }
                        if (this.checkChild(i.nextPosition, "$text")) {
                            return new Gh(i.nextPosition)
                        }
                    }
                    return null
                }
                findAllowedParent(t, e) {
                    let n = t.parent;
                    while (n) {
                        if (this.checkChild(n, e)) {
                            return n
                        }
                        if (this.isLimit(n)) {
                            return null
                        }
                        n = n.parent
                    }
                    return null
                }
                removeDisallowedAttributes(t, e) {
                    for (const n of t) {
                        if (n.is("text")) {
                            Ep(this, n, e)
                        } else {
                            const t = Gh._createIn(n);
                            const i = t.getPositions();
                            for (const t of i) {
                                const n = t.nodeBefore || t.parent;
                                Ep(this, n, e)
                            }
                        }
                    }
                }
                createContext(t) {
                    return new fp(t)
                }
                _clearCache() {
                    this._compiledDefinitions = null
                }
                _compile() {
                    const t = {};
                    const e = this._sourceDefinitions;
                    const n = Object.keys(e);
                    for (const i of n) {
                        t[i] = pp(e[i], i)
                    }
                    for (const e of n) {
                        gp(t, e)
                    }
                    for (const e of n) {
                        mp(t, e)
                    }
                    for (const e of n) {
                        bp(t, e);
                        wp(t, e)
                    }
                    for (const e of n) {
                        kp(t, e);
                        _p(t, e)
                    }
                    this._compiledDefinitions = t
                }
                _checkContextMatch(t, e, n = e.length - 1) {
                    const i = e.getItem(n);
                    if (t.allowIn.includes(i.name)) {
                        if (n == 0) {
                            return true
                        } else {
                            const t = this.getDefinition(i);
                            return this._checkContextMatch(t, e, n - 1)
                        }
                    } else {
                        return false
                    }
                }
                *_getValidRangesForRange(t, e) {
                    let n = t.start;
                    let i = t.start;
                    for (const o of t.getItems({
                        shallow: true
                    })) {
                        if (o.is("element")) {
                            yield* this._getValidRangesForRange(Gh._createIn(o), e)
                        }
                        if (!this.checkAttribute(o, e)) {
                            if (!n.isEqual(i)) {
                                yield new Gh(n, i)
                            }
                            n = $h._createAfter(o)
                        }
                        i = $h._createAfter(o)
                    }
                    if (!n.isEqual(i)) {
                        yield new Gh(n, i)
                    }
                }
            }
            vr(hp, Jc);
            class fp {
                constructor(t) {
                    if (t instanceof fp) {
                        return t
                    }
                    if (typeof t == "string") {
                        t = [t]
                    } else if (!Array.isArray(t)) {
                        t = t.getAncestors({
                            includeSelf: true
                        })
                    }
                    if (t[0] && typeof t[0] != "string" && t[0].is("documentFragment")) {
                        t.shift()
                    }
                    this._items = t.map(Pp)
                }
                get length() {
                    return this._items.length
                }
                get last() {
                    return this._items[this._items.length - 1]
                }
                [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }
                push(t) {
                    const e = new fp([t]);
                    e._items = [...this._items, ...e._items];
                    return e
                }
                getItem(t) {
                    return this._items[t]
                }
                *getNames() {
                    yield* this._items.map(t => t.name)
                }
                endsWith(t) {
                    return Array.from(this.getNames()).join(" ").endsWith(t)
                }
                startsWith(t) {
                    return Array.from(this.getNames()).join(" ").startsWith(t)
                }
            }
            function pp(t, e) {
                const n = {
                    name: e,
                    allowIn: [],
                    allowContentOf: [],
                    allowWhere: [],
                    allowAttributes: [],
                    allowAttributesOf: [],
                    inheritTypesFrom: []
                };
                vp(t, n);
                yp(t, n, "allowIn");
                yp(t, n, "allowContentOf");
                yp(t, n, "allowWhere");
                yp(t, n, "allowAttributes");
                yp(t, n, "allowAttributesOf");
                yp(t, n, "inheritTypesFrom");
                xp(t, n);
                return n
            }
            function gp(t, e) {
                for (const n of t[e].allowContentOf) {
                    if (t[n]) {
                        const i = Cp(t, n);
                        i.forEach(t => {
                            t.allowIn.push(e)
                        }
                        )
                    }
                }
                delete t[e].allowContentOf
            }
            function mp(t, e) {
                for (const n of t[e].allowWhere) {
                    const i = t[n];
                    if (i) {
                        const n = i.allowIn;
                        t[e].allowIn.push(...n)
                    }
                }
                delete t[e].allowWhere
            }
            function bp(t, e) {
                for (const n of t[e].allowAttributesOf) {
                    const i = t[n];
                    if (i) {
                        const n = i.allowAttributes;
                        t[e].allowAttributes.push(...n)
                    }
                }
                delete t[e].allowAttributesOf
            }
            function wp(t, e) {
                const n = t[e];
                for (const e of n.inheritTypesFrom) {
                    const i = t[e];
                    if (i) {
                        const t = Object.keys(i).filter(t => t.startsWith("is"));
                        for (const e of t) {
                            if (!(e in n)) {
                                n[e] = i[e]
                            }
                        }
                    }
                }
                delete n.inheritTypesFrom
            }
            function kp(t, e) {
                const n = t[e];
                const i = n.allowIn.filter(e => t[e]);
                n.allowIn = Array.from(new Set(i))
            }
            function _p(t, e) {
                const n = t[e];
                n.allowAttributes = Array.from(new Set(n.allowAttributes))
            }
            function vp(t, e) {
                for (const n of t) {
                    const t = Object.keys(n).filter(t => t.startsWith("is"));
                    for (const i of t) {
                        e[i] = n[i]
                    }
                }
            }
            function yp(t, e, n) {
                for (const i of t) {
                    if (typeof i[n] == "string") {
                        e[n].push(i[n])
                    } else if (Array.isArray(i[n])) {
                        e[n].push(...i[n])
                    }
                }
            }
            function xp(t, e) {
                for (const n of t) {
                    const t = n.inheritAllFrom;
                    if (t) {
                        e.allowContentOf.push(t);
                        e.allowWhere.push(t);
                        e.allowAttributesOf.push(t);
                        e.inheritTypesFrom.push(t)
                    }
                }
            }
            function Cp(t, e) {
                const n = t[e];
                return Ap(t).filter(t => t.allowIn.includes(n.name))
            }
            function Ap(t) {
                return Object.keys(t).map(e => t[e])
            }
            function Pp(t) {
                if (typeof t == "string") {
                    return {
                        name: t,
                        *getAttributeKeys() { },
                        getAttribute() { }
                    }
                } else {
                    return {
                        name: t.is("element") ? t.name : "$text",
                        *getAttributeKeys() {
                            yield* t.getAttributeKeys()
                        },
                        getAttribute(e) {
                            return t.getAttribute(e)
                        }
                    }
                }
            }
            function* Tp(t, e) {
                let n = false;
                while (!n) {
                    n = true;
                    if (t) {
                        const e = t.next();
                        if (!e.done) {
                            n = false;
                            yield {
                                walker: t,
                                value: e.value
                            }
                        }
                    }
                    if (e) {
                        const t = e.next();
                        if (!t.done) {
                            n = false;
                            yield {
                                walker: e,
                                value: t.value
                            }
                        }
                    }
                }
            }
            function* Sp(t) {
                for (const e of t) {
                    yield* e.getMinimalFlatRanges()
                }
            }
            function Ep(t, e, n) {
                for (const i of e.getAttributeKeys()) {
                    if (!t.checkAttribute(e, i)) {
                        n.removeAttribute(i, e)
                    }
                }
            }
            class Rp {
                constructor(t = {}) {
                    this._splitParts = new Map;
                    this._modelCursor = null;
                    this.conversionApi = Object.assign({}, t);
                    this.conversionApi.convertItem = this._convertItem.bind(this);
                    this.conversionApi.convertChildren = this._convertChildren.bind(this);
                    this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);
                    this.conversionApi.getSplitParts = this._getSplitParts.bind(this)
                }
                convert(t, e, n = ["$root"]) {
                    this.fire("viewCleanup", t);
                    this._modelCursor = Mp(n, e);
                    this.conversionApi.writer = e;
                    this.conversionApi.consumable = dp.createFrom(t);
                    this.conversionApi.store = {};
                    const { modelRange: i } = this._convertItem(t, this._modelCursor);
                    const o = e.createDocumentFragment();
                    if (i) {
                        this._removeEmptyElements();
                        for (const t of Array.from(this._modelCursor.parent.getChildren())) {
                            e.append(t, o)
                        }
                        o.markers = Op(o, e)
                    }
                    this._modelCursor = null;
                    this._splitParts.clear();
                    this.conversionApi.writer = null;
                    this.conversionApi.store = null;
                    return o
                }
                _convertItem(t, e) {
                    const n = Object.assign({
                        viewItem: t,
                        modelCursor: e,
                        modelRange: null
                    });
                    if (t.is("element")) {
                        this.fire("element:" + t.name, n, this.conversionApi)
                    } else if (t.is("text")) {
                        this.fire("text", n, this.conversionApi)
                    } else {
                        this.fire("documentFragment", n, this.conversionApi)
                    }
                    if (n.modelRange && !(n.modelRange instanceof Gh)) {
                        throw new rr["b"]("view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.", this)
                    }
                    return {
                        modelRange: n.modelRange,
                        modelCursor: n.modelCursor
                    }
                }
                _convertChildren(t, e) {
                    const n = new Gh(e);
                    let i = e;
                    for (const e of Array.from(t.getChildren())) {
                        const t = this._convertItem(e, i);
                        if (t.modelRange instanceof Gh) {
                            n.end = t.modelRange.end;
                            i = t.modelCursor
                        }
                    }
                    return {
                        modelRange: n,
                        modelCursor: i
                    }
                }
                _splitToAllowedParent(t, e) {
                    const n = this.conversionApi.schema.findAllowedParent(e, t);
                    if (!n) {
                        return null
                    }
                    if (n === e.parent) {
                        return {
                            position: e
                        }
                    }
                    if (this._modelCursor.parent.getAncestors().includes(n)) {
                        return null
                    }
                    const i = this.conversionApi.writer.split(e, n);
                    const o = [];
                    for (const t of i.range.getWalker()) {
                        if (t.type == "elementEnd") {
                            o.push(t.item)
                        } else {
                            const e = o.pop();
                            const n = t.item;
                            this._registerSplitPair(e, n)
                        }
                    }
                    return {
                        position: i.position,
                        cursorParent: i.range.end.parent
                    }
                }
                _registerSplitPair(t, e) {
                    if (!this._splitParts.has(t)) {
                        this._splitParts.set(t, [t])
                    }
                    const n = this._splitParts.get(t);
                    this._splitParts.set(e, n);
                    n.push(e)
                }
                _getSplitParts(t) {
                    let e;
                    if (!this._splitParts.has(t)) {
                        e = [t]
                    } else {
                        e = this._splitParts.get(t)
                    }
                    return e
                }
                _removeEmptyElements() {
                    let t = false;
                    for (const e of this._splitParts.keys()) {
                        if (e.isEmpty) {
                            this.conversionApi.writer.remove(e);
                            this._splitParts.delete(e);
                            t = true
                        }
                    }
                    if (t) {
                        this._removeEmptyElements()
                    }
                }
            }
            vr(Rp, dr);
            function Op(t, e) {
                const n = new Set;
                const i = new Map;
                const o = Gh._createIn(t).getItems();
                for (const t of o) {
                    if (t.name == "$marker") {
                        n.add(t)
                    }
                }
                for (const t of n) {
                    const n = t.getAttribute("data-name");
                    const o = e.createPositionBefore(t);
                    if (!i.has(n)) {
                        i.set(n, new Gh(o.clone()))
                    } else {
                        i.get(n).end = o.clone()
                    }
                    e.remove(t)
                }
                return i
            }
            function Mp(t, e) {
                let n;
                for (const i of new fp(t)) {
                    const t = {};
                    for (const e of i.getAttributeKeys()) {
                        t[e] = i.getAttribute(e)
                    }
                    const o = e.createElement(i.name, t);
                    if (n) {
                        e.append(o, n)
                    }
                    n = $h._createAt(o, 0)
                }
                return n
            }
            class Np {
                constructor(t, e) {
                    this.model = t;
                    this.processor = e;
                    this.mapper = new Kh;
                    this.downcastDispatcher = new Yh({
                        mapper: this.mapper
                    });
                    this.downcastDispatcher.on("insert:$text", vf(), {
                        priority: "lowest"
                    });
                    this.upcastDispatcher = new Rp({
                        schema: t.schema
                    });
                    this.upcastDispatcher.on("text", Gf(), {
                        priority: "lowest"
                    });
                    this.upcastDispatcher.on("element", $f(), {
                        priority: "lowest"
                    });
                    this.upcastDispatcher.on("documentFragment", $f(), {
                        priority: "lowest"
                    });
                    this.decorate("init");
                    this.on("init", () => {
                        this.fire("ready")
                    }
                        , {
                            priority: "lowest"
                        })
                }
                get(t) {
                    const { rootName: e = "main", trim: n = "empty" } = t || {};
                    if (!this._checkIfRootsExists([e])) {
                        throw new rr["b"]("datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.", this)
                    }
                    const i = this.model.document.getRoot(e);
                    if (n === "empty" && !this.model.hasContent(i, {
                        ignoreWhitespaces: true
                    })) {
                        return ""
                    }
                    return this.stringify(i)
                }
                stringify(t) {
                    const e = this.toView(t);
                    return this.processor.toData(e)
                }
                toView(t) {
                    this.mapper.clearBindings();
                    const e = Gh._createIn(t);
                    const n = new Ul;
                    const i = new Gl(new bl);
                    this.mapper.bindElements(t, n);
                    this.downcastDispatcher.convertInsert(e, i);
                    if (!t.is("documentFragment")) {
                        const e = Ip(t);
                        for (const [t, n] of e) {
                            this.downcastDispatcher.convertMarkerAdd(t, n, i)
                        }
                    }
                    return n
                }
                init(t) {
                    if (this.model.document.version) {
                        throw new rr["b"]("datacontroller-init-document-not-empty: Trying to set initial data to not empty document.", this)
                    }
                    let e = {};
                    if (typeof t === "string") {
                        e.main = t
                    } else {
                        e = t
                    }
                    if (!this._checkIfRootsExists(Object.keys(e))) {
                        throw new rr["b"]("datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.", this)
                    }
                    this.model.enqueueChange("transparent", t => {
                        for (const n of Object.keys(e)) {
                            const i = this.model.document.getRoot(n);
                            t.insert(this.parse(e[n], i), i, 0)
                        }
                    }
                    );
                    return Promise.resolve()
                }
                set(t) {
                    let e = {};
                    if (typeof t === "string") {
                        e.main = t
                    } else {
                        e = t
                    }
                    if (!this._checkIfRootsExists(Object.keys(e))) {
                        throw new rr["b"]("datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.", this)
                    }
                    this.model.enqueueChange("transparent", t => {
                        t.setSelection(null);
                        t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                        for (const n of Object.keys(e)) {
                            const i = this.model.document.getRoot(n);
                            t.remove(t.createRangeIn(i));
                            t.insert(this.parse(e[n], i), i, 0)
                        }
                    }
                    )
                }
                parse(t, e = "$root") {
                    const n = this.processor.toView(t);
                    return this.toModel(n, e)
                }
                toModel(t, e = "$root") {
                    return this.model.change(n => this.upcastDispatcher.convert(t, n, e))
                }
                destroy() {
                    this.stopListening()
                }
                _checkIfRootsExists(t) {
                    for (const e of t) {
                        if (!this.model.document.getRootNames().includes(e)) {
                            return false
                        }
                    }
                    return true
                }
            }
            vr(Np, Jc);
            function Ip(t) {
                const e = [];
                const n = t.root.document;
                if (!n) {
                    return []
                }
                const i = Gh._createIn(t);
                for (const t of n.model.markers) {
                    const n = i.getIntersection(t.getRange());
                    if (n) {
                        e.push([t.name, n])
                    }
                }
                return e
            }
            class Vp {
                constructor(t, e) {
                    this._helpers = new Map;
                    this._downcast = Array.isArray(t) ? t : [t];
                    this._createConversionHelpers({
                        name: "downcast",
                        dispatchers: this._downcast,
                        isDowncast: true
                    });
                    this._upcast = Array.isArray(e) ? e : [e];
                    this._createConversionHelpers({
                        name: "upcast",
                        dispatchers: this._upcast,
                        isDowncast: false
                    })
                }
                addAlias(t, e) {
                    const n = this._downcast.includes(e);
                    const i = this._upcast.includes(e);
                    if (!i && !n) {
                        throw new rr["b"]("conversion-add-alias-dispatcher-not-registered: " + "Trying to register and alias for a dispatcher that nas not been registered.", this)
                    }
                    this._createConversionHelpers({
                        name: t,
                        dispatchers: [e],
                        isDowncast: n
                    })
                }
                for(t) {
                    if (!this._helpers.has(t)) {
                        throw new rr["b"]("conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.", this)
                    }
                    return this._helpers.get(t)
                }
                elementToElement(t) {
                    this.for("downcast").elementToElement(t);
                    for (const { model: e, view: n } of Bp(t)) {
                        this.for("upcast").elementToElement({
                            model: e,
                            view: n,
                            converterPriority: t.converterPriority
                        })
                    }
                }
                attributeToElement(t) {
                    this.for("downcast").attributeToElement(t);
                    for (const { model: e, view: n } of Bp(t)) {
                        this.for("upcast").elementToAttribute({
                            view: n,
                            model: e,
                            converterPriority: t.converterPriority
                        })
                    }
                }
                attributeToAttribute(t) {
                    this.for("downcast").attributeToAttribute(t);
                    for (const { model: e, view: n } of Bp(t)) {
                        this.for("upcast").attributeToAttribute({
                            view: n,
                            model: e
                        })
                    }
                }
                _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
                    if (this._helpers.has(t)) {
                        throw new rr["b"]("conversion-group-exists: Trying to register a group name that has already been registered.", this)
                    }
                    const i = n ? new _f(e) : new Uf(e);
                    this._helpers.set(t, i)
                }
            }
            function* Bp(t) {
                if (t.model.values) {
                    for (const e of t.model.values) {
                        const n = {
                            key: t.model.key,
                            value: e
                        };
                        const i = t.view[e];
                        const o = t.upcastAlso ? t.upcastAlso[e] : undefined;
                        yield* Fp(n, i, o)
                    }
                } else {
                    yield* Fp(t.model, t.view, t.upcastAlso)
                }
            }
            function* Fp(t, e, n) {
                yield {
                    model: t,
                    view: e
                };
                if (n) {
                    n = Array.isArray(n) ? n : [n];
                    for (const e of n) {
                        yield {
                            model: t,
                            view: e
                        }
                    }
                }
            }
            class Dp {
                constructor(t = "default") {
                    this.operations = [];
                    this.type = t
                }
                get baseVersion() {
                    for (const t of this.operations) {
                        if (t.baseVersion !== null) {
                            return t.baseVersion
                        }
                    }
                    return null
                }
                addOperation(t) {
                    t.batch = this;
                    this.operations.push(t);
                    return t
                }
            }
            class zp {
                constructor(t) {
                    this.baseVersion = t;
                    this.isDocumentOperation = this.baseVersion !== null;
                    this.batch = null
                }
                _validate() { }
                toJSON() {
                    const t = Object.assign({}, this);
                    t.__className = this.constructor.className;
                    delete t.batch;
                    delete t.isDocumentOperation;
                    return t
                }
                static get className() {
                    return "Operation"
                }
                static fromJSON(t) {
                    return new this(t.baseVersion)
                }
            }
            class Lp {
                constructor(t) {
                    this.markers = new Map;
                    this._children = new jh;
                    if (t) {
                        this._insertChild(0, t)
                    }
                }
                [Symbol.iterator]() {
                    return this.getChildren()
                }
                get childCount() {
                    return this._children.length
                }
                get maxOffset() {
                    return this._children.maxOffset
                }
                get isEmpty() {
                    return this.childCount === 0
                }
                get root() {
                    return this
                }
                get parent() {
                    return null
                }
                is(t) {
                    return t == "documentFragment" || t == "model:documentFragment"
                }
                getChild(t) {
                    return this._children.getNode(t)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                getChildIndex(t) {
                    return this._children.getNodeIndex(t)
                }
                getChildStartOffset(t) {
                    return this._children.getNodeStartOffset(t)
                }
                getPath() {
                    return []
                }
                getNodeByPath(t) {
                    let e = this;
                    for (const n of t) {
                        e = e.getChild(e.offsetToIndex(n))
                    }
                    return e
                }
                offsetToIndex(t) {
                    return this._children.offsetToIndex(t)
                }
                toJSON() {
                    const t = [];
                    for (const e of this._children) {
                        t.push(e.toJSON())
                    }
                    return t
                }
                static fromJSON(t) {
                    const e = [];
                    for (const n of t) {
                        if (n.name) {
                            e.push(Hh.fromJSON(n))
                        } else {
                            e.push(zh.fromJSON(n))
                        }
                    }
                    return new Lp(e)
                }
                _appendChild(t) {
                    this._insertChild(this.childCount, t)
                }
                _insertChild(t, e) {
                    const n = jp(e);
                    for (const t of n) {
                        if (t.parent !== null) {
                            t._remove()
                        }
                        t.parent = this
                    }
                    this._children._insertNodes(t, n)
                }
                _removeChildren(t, e = 1) {
                    const n = this._children._removeNodes(t, e);
                    for (const t of n) {
                        t.parent = null
                    }
                    return n
                }
            }
            function jp(t) {
                if (typeof t == "string") {
                    return [new zh(t)]
                }
                if (!jr(t)) {
                    t = [t]
                }
                return Array.from(t).map(t => {
                    if (typeof t == "string") {
                        return new zh(t)
                    }
                    if (t instanceof Lh) {
                        return new zh(t.data, t.getAttributes())
                    }
                    return t
                }
                )
            }
            function Hp(t, e) {
                e = $p(e);
                const n = e.reduce((t, e) => t + e.offsetSize, 0);
                const i = t.parent;
                Kp(t);
                const o = t.index;
                i._insertChild(o, e);
                Gp(i, o + e.length);
                Gp(i, o);
                return new Gh(t, t.getShiftedBy(n))
            }
            function qp(t) {
                if (!t.isFlat) {
                    throw new rr["b"]("operation-utils-remove-range-not-flat: " + "Trying to remove a range which starts and ends in different element.", this)
                }
                const e = t.start.parent;
                Kp(t.start);
                Kp(t.end);
                const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
                Gp(e, t.start.index);
                return n
            }
            function Wp(t, e) {
                if (!t.isFlat) {
                    throw new rr["b"]("operation-utils-move-range-not-flat: " + "Trying to move a range which starts and ends in different element.", this)
                }
                const n = qp(t);
                e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
                return Hp(e, n)
            }
            function Up(t, e, n) {
                Kp(t.start);
                Kp(t.end);
                for (const i of t.getItems({
                    shallow: true
                })) {
                    const t = i.is("textProxy") ? i.textNode : i;
                    if (n !== null) {
                        t._setAttribute(e, n)
                    } else {
                        t._removeAttribute(e)
                    }
                    Gp(t.parent, t.index)
                }
                Gp(t.end.parent, t.end.index)
            }
            function $p(t) {
                const e = [];
                if (!(t instanceof Array)) {
                    t = [t]
                }
                for (let n = 0; n < t.length; n++) {
                    if (typeof t[n] == "string") {
                        e.push(new zh(t[n]))
                    } else if (t[n] instanceof Lh) {
                        e.push(new zh(t[n].data, t[n].getAttributes()))
                    } else if (t[n] instanceof Lp || t[n] instanceof jh) {
                        for (const i of t[n]) {
                            e.push(i)
                        }
                    } else if (t[n] instanceof Dh) {
                        e.push(t[n])
                    }
                }
                for (let t = 1; t < e.length; t++) {
                    const n = e[t];
                    const i = e[t - 1];
                    if (n instanceof zh && i instanceof zh && Jp(n, i)) {
                        e.splice(t - 1, 2, new zh(i.data + n.data, i.getAttributes()));
                        t--
                    }
                }
                return e
            }
            function Gp(t, e) {
                const n = t.getChild(e - 1);
                const i = t.getChild(e);
                if (n && i && n.is("text") && i.is("text") && Jp(n, i)) {
                    const o = new zh(n.data + i.data, n.getAttributes());
                    t._removeChildren(e - 1, 2);
                    t._insertChild(e - 1, o)
                }
            }
            function Kp(t) {
                const e = t.textNode;
                const n = t.parent;
                if (e) {
                    const i = t.offset - e.startOffset;
                    const o = e.index;
                    n._removeChildren(o, 1);
                    const s = new zh(e.data.substr(0, i), e.getAttributes());
                    const r = new zh(e.data.substr(i), e.getAttributes());
                    n._insertChild(o, [s, r])
                }
            }
            function Jp(t, e) {
                const n = t.getAttributes();
                const i = e.getAttributes();
                for (const t of n) {
                    if (t[1] !== e.getAttribute(t[0])) {
                        return false
                    }
                    i.next()
                }
                return i.next().done
            }
            function Qp(t, e) {
                return Uu(t, e)
            }
            var Yp = Qp;
            class Xp extends zp {
                constructor(t, e, n, i, o) {
                    super(o);
                    this.range = t.clone();
                    this.key = e;
                    this.oldValue = n === undefined ? null : n;
                    this.newValue = i === undefined ? null : i
                }
                get type() {
                    if (this.oldValue === null) {
                        return "addAttribute"
                    } else if (this.newValue === null) {
                        return "removeAttribute"
                    } else {
                        return "changeAttribute"
                    }
                }
                clone() {
                    return new Xp(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
                }
                getReversed() {
                    return new Xp(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
                }
                toJSON() {
                    const t = super.toJSON();
                    t.range = this.range.toJSON();
                    return t
                }
                _validate() {
                    if (!this.range.isFlat) {
                        throw new rr["b"]("attribute-operation-range-not-flat: The range to change is not flat.", this)
                    }
                    for (const t of this.range.getItems({
                        shallow: true
                    })) {
                        if (this.oldValue !== null && !Yp(t.getAttribute(this.key), this.oldValue)) {
                            throw new rr["b"]("attribute-operation-wrong-old-value: Changed node has different attribute value than operation's " + "old attribute value.", this, {
                                item: t,
                                key: this.key,
                                value: this.oldValue
                            })
                        }
                        if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) {
                            throw new rr["b"]("attribute-operation-attribute-exists: The attribute with given key already exists.", this, {
                                node: t,
                                key: this.key
                            })
                        }
                    }
                }
                _execute() {
                    if (!Yp(this.oldValue, this.newValue)) {
                        Up(this.range, this.key, this.newValue)
                    }
                }
                static get className() {
                    return "AttributeOperation"
                }
                static fromJSON(t, e) {
                    return new Xp(Gh.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
                }
            }
            class Zp extends zp {
                constructor(t, e) {
                    super(null);
                    this.sourcePosition = t.clone();
                    this.howMany = e
                }
                get type() {
                    return "detach"
                }
                toJSON() {
                    const t = super.toJSON();
                    t.sourcePosition = this.sourcePosition.toJSON();
                    return t
                }
                _validate() {
                    if (this.sourcePosition.root.document) {
                        throw new rr["b"]("detach-operation-on-document-node: Cannot detach document node.", this)
                    }
                }
                _execute() {
                    qp(Gh._createFromPositionAndShift(this.sourcePosition, this.howMany))
                }
                static get className() {
                    return "DetachOperation"
                }
            }
            class tg extends zp {
                constructor(t, e, n, i) {
                    super(i);
                    this.sourcePosition = t.clone();
                    this.sourcePosition.stickiness = "toNext";
                    this.howMany = e;
                    this.targetPosition = n.clone();
                    this.targetPosition.stickiness = "toNone"
                }
                get type() {
                    if (this.targetPosition.root.rootName == "$graveyard") {
                        return "remove"
                    } else if (this.sourcePosition.root.rootName == "$graveyard") {
                        return "reinsert"
                    }
                    return "move"
                }
                clone() {
                    return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
                }
                getMovedRangeStart() {
                    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
                }
                getReversed() {
                    const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                    return new this.constructor(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.sourcePosition.parent;
                    const e = this.targetPosition.parent;
                    const n = this.sourcePosition.offset;
                    const i = this.targetPosition.offset;
                    if (n + this.howMany > t.maxOffset) {
                        throw new rr["b"]("move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.", this)
                    } else if (t === e && n < i && i < n + this.howMany) {
                        throw new rr["b"]("move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.", this)
                    } else if (this.sourcePosition.root == this.targetPosition.root) {
                        if (Nr(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
                            const t = this.sourcePosition.path.length - 1;
                            if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) {
                                throw new rr["b"]("move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.", this)
                            }
                        }
                    }
                }
                _execute() {
                    Wp(Gh._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
                }
                toJSON() {
                    const t = super.toJSON();
                    t.sourcePosition = this.sourcePosition.toJSON();
                    t.targetPosition = this.targetPosition.toJSON();
                    return t
                }
                static get className() {
                    return "MoveOperation"
                }
                static fromJSON(t, e) {
                    const n = $h.fromJSON(t.sourcePosition, e);
                    const i = $h.fromJSON(t.targetPosition, e);
                    return new this(n, t.howMany, i, t.baseVersion)
                }
            }
            class eg extends zp {
                constructor(t, e, n) {
                    super(n);
                    this.position = t.clone();
                    this.position.stickiness = "toNone";
                    this.nodes = new jh($p(e));
                    this.shouldReceiveAttributes = false
                }
                get type() {
                    return "insert"
                }
                get howMany() {
                    return this.nodes.maxOffset
                }
                clone() {
                    const t = new jh([...this.nodes].map(t => t._clone(true)));
                    const e = new eg(this.position, t, this.baseVersion);
                    e.shouldReceiveAttributes = this.shouldReceiveAttributes;
                    return e
                }
                getReversed() {
                    const t = this.position.root.document.graveyard;
                    const e = new $h(t, [0]);
                    return new tg(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.position.parent;
                    if (!t || t.maxOffset < this.position.offset) {
                        throw new rr["b"]("insert-operation-position-invalid: Insertion position is invalid.", this)
                    }
                }
                _execute() {
                    const t = this.nodes;
                    this.nodes = new jh([...t].map(t => t._clone(true)));
                    Hp(this.position, t)
                }
                toJSON() {
                    const t = super.toJSON();
                    t.position = this.position.toJSON();
                    t.nodes = this.nodes.toJSON();
                    return t
                }
                static get className() {
                    return "InsertOperation"
                }
                static fromJSON(t, e) {
                    const n = [];
                    for (const e of t.nodes) {
                        if (e.name) {
                            n.push(Hh.fromJSON(e))
                        } else {
                            n.push(zh.fromJSON(e))
                        }
                    }
                    const i = new eg($h.fromJSON(t.position, e), n, t.baseVersion);
                    i.shouldReceiveAttributes = t.shouldReceiveAttributes;
                    return i
                }
            }
            class ng extends zp {
                constructor(t, e, n, i, o, s) {
                    super(s);
                    this.name = t;
                    this.oldRange = e ? e.clone() : null;
                    this.newRange = n ? n.clone() : null;
                    this.affectsData = o;
                    this._markers = i
                }
                get type() {
                    return "marker"
                }
                clone() {
                    return new ng(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
                }
                getReversed() {
                    return new ng(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
                }
                _execute() {
                    const t = this.newRange ? "_set" : "_remove";
                    this._markers[t](this.name, this.newRange, true, this.affectsData)
                }
                toJSON() {
                    const t = super.toJSON();
                    if (this.oldRange) {
                        t.oldRange = this.oldRange.toJSON()
                    }
                    if (this.newRange) {
                        t.newRange = this.newRange.toJSON()
                    }
                    delete t._markers;
                    return t
                }
                static get className() {
                    return "MarkerOperation"
                }
                static fromJSON(t, e) {
                    return new ng(t.name, t.oldRange ? Gh.fromJSON(t.oldRange, e) : null, t.newRange ? Gh.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion)
                }
            }
            class ig extends zp {
                constructor(t, e, n, i) {
                    super(i);
                    this.position = t;
                    this.position.stickiness = "toNext";
                    this.oldName = e;
                    this.newName = n
                }
                get type() {
                    return "rename"
                }
                clone() {
                    return new ig(this.position.clone(), this.oldName, this.newName, this.baseVersion)
                }
                getReversed() {
                    return new ig(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.position.nodeAfter;
                    if (!(t instanceof Hh)) {
                        throw new rr["b"]("rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.", this)
                    } else if (t.name !== this.oldName) {
                        throw new rr["b"]("rename-operation-wrong-name: Element to change has different name than operation's old name.", this)
                    }
                }
                _execute() {
                    const t = this.position.nodeAfter;
                    t.name = this.newName
                }
                toJSON() {
                    const t = super.toJSON();
                    t.position = this.position.toJSON();
                    return t
                }
                static get className() {
                    return "RenameOperation"
                }
                static fromJSON(t, e) {
                    return new ig($h.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
                }
            }
            class og extends zp {
                constructor(t, e, n, i, o) {
                    super(o);
                    this.root = t;
                    this.key = e;
                    this.oldValue = n;
                    this.newValue = i
                }
                get type() {
                    if (this.oldValue === null) {
                        return "addRootAttribute"
                    } else if (this.newValue === null) {
                        return "removeRootAttribute"
                    } else {
                        return "changeRootAttribute"
                    }
                }
                clone() {
                    return new og(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
                }
                getReversed() {
                    return new og(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
                }
                _validate() {
                    if (this.root != this.root.root || this.root.is("documentFragment")) {
                        throw new rr["b"]("rootattribute-operation-not-a-root: The element to change is not a root element.", this, {
                            root: this.root,
                            key: this.key
                        })
                    }
                    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
                        throw new rr["b"]("rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation's " + "old attribute value.", this, {
                            root: this.root,
                            key: this.key
                        })
                    }
                    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
                        throw new rr["b"]("rootattribute-operation-attribute-exists: The attribute with given key already exists.", this, {
                            root: this.root,
                            key: this.key
                        })
                    }
                }
                _execute() {
                    if (this.newValue !== null) {
                        this.root._setAttribute(this.key, this.newValue)
                    } else {
                        this.root._removeAttribute(this.key)
                    }
                }
                toJSON() {
                    const t = super.toJSON();
                    t.root = this.root.toJSON();
                    return t
                }
                static get className() {
                    return "RootAttributeOperation"
                }
                static fromJSON(t, e) {
                    if (!e.getRoot(t.root)) {
                        throw new rr["b"]("rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.", this, {
                            rootName: t.root
                        })
                    }
                    return new og(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
                }
            }
            class sg extends zp {
                constructor(t, e, n, i, o) {
                    super(o);
                    this.sourcePosition = t.clone();
                    this.sourcePosition.stickiness = "toPrevious";
                    this.howMany = e;
                    this.targetPosition = n.clone();
                    this.targetPosition.stickiness = "toNext";
                    this.graveyardPosition = i.clone()
                }
                get type() {
                    return "merge"
                }
                get deletionPosition() {
                    return new $h(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
                }
                get movedRange() {
                    const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new Gh(this.sourcePosition, t)
                }
                clone() {
                    return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
                }
                getReversed() {
                    const t = this.targetPosition._getTransformedByMergeOperation(this);
                    const e = this.sourcePosition.path.slice(0, -1);
                    const n = new $h(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
                    const i = new rg(t, this.howMany, this.graveyardPosition, this.baseVersion + 1);
                    i.insertionPosition = n;
                    return i
                }
                _validate() {
                    const t = this.sourcePosition.parent;
                    const e = this.targetPosition.parent;
                    if (!t.parent) {
                        throw new rr["b"]("merge-operation-source-position-invalid: Merge source position is invalid.", this)
                    } else if (!e.parent) {
                        throw new rr["b"]("merge-operation-target-position-invalid: Merge target position is invalid.", this)
                    } else if (this.howMany != t.maxOffset) {
                        throw new rr["b"]("merge-operation-how-many-invalid: Merge operation specifies wrong number of nodes to move.", this)
                    }
                }
                _execute() {
                    const t = this.sourcePosition.parent;
                    const e = Gh._createIn(t);
                    Wp(e, this.targetPosition);
                    Wp(Gh._createOn(t), this.graveyardPosition)
                }
                toJSON() {
                    const t = super.toJSON();
                    t.sourcePosition = t.sourcePosition.toJSON();
                    t.targetPosition = t.targetPosition.toJSON();
                    t.graveyardPosition = t.graveyardPosition.toJSON();
                    return t
                }
                static get className() {
                    return "MergeOperation"
                }
                static fromJSON(t, e) {
                    const n = $h.fromJSON(t.sourcePosition, e);
                    const i = $h.fromJSON(t.targetPosition, e);
                    const o = $h.fromJSON(t.graveyardPosition, e);
                    return new this(n, t.howMany, i, o, t.baseVersion)
                }
            }
            class rg extends zp {
                constructor(t, e, n, i) {
                    super(i);
                    this.splitPosition = t.clone();
                    this.splitPosition.stickiness = "toNext";
                    this.howMany = e;
                    this.insertionPosition = rg.getInsertionPosition(t);
                    this.insertionPosition.stickiness = "toNone";
                    this.graveyardPosition = n ? n.clone() : null;
                    if (this.graveyardPosition) {
                        this.graveyardPosition.stickiness = "toNext"
                    }
                }
                get type() {
                    return "split"
                }
                get moveTargetPosition() {
                    const t = this.insertionPosition.path.slice();
                    t.push(0);
                    return new $h(this.insertionPosition.root, t)
                }
                get movedRange() {
                    const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new Gh(this.splitPosition, t)
                }
                clone() {
                    const t = new this.constructor(this.splitPosition, this.howMany, this.graveyardPosition, this.baseVersion);
                    t.insertionPosition = this.insertionPosition;
                    return t
                }
                getReversed() {
                    const t = this.splitPosition.root.document.graveyard;
                    const e = new $h(t, [0]);
                    return new sg(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1)
                }
                _validate() {
                    const t = this.splitPosition.parent;
                    const e = this.splitPosition.offset;
                    if (!t || t.maxOffset < e) {
                        throw new rr["b"]("split-operation-position-invalid: Split position is invalid.", this)
                    } else if (!t.parent) {
                        throw new rr["b"]("split-operation-split-in-root: Cannot split root element.", this)
                    } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
                        throw new rr["b"]("split-operation-how-many-invalid: Split operation specifies wrong number of nodes to move.", this)
                    } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
                        throw new rr["b"]("split-operation-graveyard-position-invalid: Graveyard position invalid.", this)
                    }
                }
                _execute() {
                    const t = this.splitPosition.parent;
                    if (this.graveyardPosition) {
                        Wp(Gh._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition)
                    } else {
                        const e = t._clone();
                        Hp(this.insertionPosition, e)
                    }
                    const e = new Gh($h._createAt(t, this.splitPosition.offset), $h._createAt(t, t.maxOffset));
                    Wp(e, this.moveTargetPosition)
                }
                toJSON() {
                    const t = super.toJSON();
                    t.splitPosition = this.splitPosition.toJSON();
                    t.insertionPosition = this.insertionPosition.toJSON();
                    if (this.graveyardPosition) {
                        t.graveyardPosition = this.graveyardPosition.toJSON()
                    }
                    return t
                }
                static get className() {
                    return "SplitOperation"
                }
                static getInsertionPosition(t) {
                    const e = t.path.slice(0, -1);
                    e[e.length - 1]++;
                    return new $h(t.root, e)
                }
                static fromJSON(t, e) {
                    const n = $h.fromJSON(t.splitPosition, e);
                    const i = $h.fromJSON(t.insertionPosition, e);
                    const o = t.graveyardPosition ? $h.fromJSON(t.graveyardPosition, e) : null;
                    const s = new this(n, t.howMany, o, t.baseVersion);
                    s.insertionPosition = i;
                    return s
                }
            }
            class ag extends Hh {
                constructor(t, e, n = "main") {
                    super(e);
                    this._doc = t;
                    this.rootName = n
                }
                get document() {
                    return this._doc
                }
                is(t, e) {
                    const n = t.replace("model:", "");
                    if (!e) {
                        return n == "rootElement" || super.is(t)
                    } else {
                        return n == "rootElement" && e == this.name || super.is(t, e)
                    }
                }
                toJSON() {
                    return this.rootName
                }
            }
            class cg {
                constructor(t, e) {
                    this.model = t;
                    this.batch = e
                }
                createText(t, e) {
                    return new zh(t, e)
                }
                createElement(t, e) {
                    return new Hh(t, e)
                }
                createDocumentFragment() {
                    return new Lp
                }
                insert(t, e, n = 0) {
                    this._assertWriterUsedCorrectly();
                    if (t instanceof zh && t.data == "") {
                        return
                    }
                    const i = $h._createAt(e, n);
                    if (t.parent) {
                        if (fg(t.root, i.root)) {
                            this.move(Gh._createOn(t), i);
                            return
                        } else {
                            if (t.root.document) {
                                throw new rr["b"]("model-writer-insert-forbidden-move: " + "Cannot move a node from a document to a different tree. " + "It is forbidden to move a node that was already in a document outside of it.", this)
                            } else {
                                this.remove(t)
                            }
                        }
                    }
                    const o = i.root.document ? i.root.document.version : null;
                    const s = new eg(i, t, o);
                    if (t instanceof zh) {
                        s.shouldReceiveAttributes = true
                    }
                    this.batch.addOperation(s);
                    this.model.applyOperation(s);
                    if (t instanceof Lp) {
                        for (const [e, n] of t.markers) {
                            const t = $h._createAt(n.root, 0);
                            const o = new Gh(n.start._getCombined(t, i), n.end._getCombined(t, i));
                            const s = {
                                range: o,
                                usingOperation: true,
                                affectsData: true
                            };
                            if (this.model.markers.has(e)) {
                                this.updateMarker(e, s)
                            } else {
                                this.addMarker(e, s)
                            }
                        }
                    }
                }
                insertText(t, e, n, i) {
                    if (e instanceof Lp || e instanceof Hh || e instanceof $h) {
                        this.insert(this.createText(t), e, n)
                    } else {
                        this.insert(this.createText(t, e), n, i)
                    }
                }
                insertElement(t, e, n, i) {
                    if (e instanceof Lp || e instanceof Hh || e instanceof $h) {
                        this.insert(this.createElement(t), e, n)
                    } else {
                        this.insert(this.createElement(t, e), n, i)
                    }
                }
                append(t, e) {
                    this.insert(t, e, "end")
                }
                appendText(t, e, n) {
                    if (e instanceof Lp || e instanceof Hh) {
                        this.insert(this.createText(t), e, "end")
                    } else {
                        this.insert(this.createText(t, e), n, "end")
                    }
                }
                appendElement(t, e, n) {
                    if (e instanceof Lp || e instanceof Hh) {
                        this.insert(this.createElement(t), e, "end")
                    } else {
                        this.insert(this.createElement(t, e), n, "end")
                    }
                }
                setAttribute(t, e, n) {
                    this._assertWriterUsedCorrectly();
                    if (n instanceof Gh) {
                        const i = n.getMinimalFlatRanges();
                        for (const n of i) {
                            lg(this, t, e, n)
                        }
                    } else {
                        dg(this, t, e, n)
                    }
                }
                setAttributes(t, e) {
                    for (const [n, i] of Hr(t)) {
                        this.setAttribute(n, i, e)
                    }
                }
                removeAttribute(t, e) {
                    this._assertWriterUsedCorrectly();
                    if (e instanceof Gh) {
                        const n = e.getMinimalFlatRanges();
                        for (const e of n) {
                            lg(this, t, null, e)
                        }
                    } else {
                        dg(this, t, null, e)
                    }
                }
                clearAttributes(t) {
                    this._assertWriterUsedCorrectly();
                    const e = t => {
                        for (const e of t.getAttributeKeys()) {
                            this.removeAttribute(e, t)
                        }
                    }
                        ;
                    if (!(t instanceof Gh)) {
                        e(t)
                    } else {
                        for (const n of t.getItems()) {
                            e(n)
                        }
                    }
                }
                move(t, e, n) {
                    this._assertWriterUsedCorrectly();
                    if (!(t instanceof Gh)) {
                        throw new rr["b"]("writer-move-invalid-range: Invalid range to move.", this)
                    }
                    if (!t.isFlat) {
                        throw new rr["b"]("writer-move-range-not-flat: Range to move is not flat.", this)
                    }
                    const i = $h._createAt(e, n);
                    if (i.isEqual(t.start)) {
                        return
                    }
                    this._addOperationForAffectedMarkers("move", t);
                    if (!fg(t.root, i.root)) {
                        throw new rr["b"]("writer-move-different-document: Range is going to be moved between different documents.", this)
                    }
                    const o = t.root.document ? t.root.document.version : null;
                    const s = new tg(t.start, t.end.offset - t.start.offset, i, o);
                    this.batch.addOperation(s);
                    this.model.applyOperation(s)
                }
                remove(t) {
                    this._assertWriterUsedCorrectly();
                    const e = t instanceof Gh ? t : Gh._createOn(t);
                    const n = e.getMinimalFlatRanges().reverse();
                    for (const t of n) {
                        this._addOperationForAffectedMarkers("move", t);
                        hg(t.start, t.end.offset - t.start.offset, this.batch, this.model)
                    }
                }
                merge(t) {
                    this._assertWriterUsedCorrectly();
                    const e = t.nodeBefore;
                    const n = t.nodeAfter;
                    this._addOperationForAffectedMarkers("merge", t);
                    if (!(e instanceof Hh)) {
                        throw new rr["b"]("writer-merge-no-element-before: Node before merge position must be an element.", this)
                    }
                    if (!(n instanceof Hh)) {
                        throw new rr["b"]("writer-merge-no-element-after: Node after merge position must be an element.", this)
                    }
                    if (!t.root.document) {
                        this._mergeDetached(t)
                    } else {
                        this._merge(t)
                    }
                }
                createPositionFromPath(t, e, n) {
                    return this.model.createPositionFromPath(t, e, n)
                }
                createPositionAt(t, e) {
                    return this.model.createPositionAt(t, e)
                }
                createPositionAfter(t) {
                    return this.model.createPositionAfter(t)
                }
                createPositionBefore(t) {
                    return this.model.createPositionBefore(t)
                }
                createRange(t, e) {
                    return this.model.createRange(t, e)
                }
                createRangeIn(t) {
                    return this.model.createRangeIn(t)
                }
                createRangeOn(t) {
                    return this.model.createRangeOn(t)
                }
                createSelection(t, e, n) {
                    return this.model.createSelection(t, e, n)
                }
                _mergeDetached(t) {
                    const e = t.nodeBefore;
                    const n = t.nodeAfter;
                    this.move(Gh._createIn(n), $h._createAt(e, "end"));
                    this.remove(n)
                }
                _merge(t) {
                    const e = $h._createAt(t.nodeBefore, "end");
                    const n = $h._createAt(t.nodeAfter, 0);
                    const i = t.root.document.graveyard;
                    const o = new $h(i, [0]);
                    const s = t.root.document.version;
                    const r = new sg(n, t.nodeAfter.maxOffset, e, o, s);
                    this.batch.addOperation(r);
                    this.model.applyOperation(r)
                }
                rename(t, e) {
                    this._assertWriterUsedCorrectly();
                    if (!(t instanceof Hh)) {
                        throw new rr["b"]("writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.", this)
                    }
                    const n = t.root.document ? t.root.document.version : null;
                    const i = new ig($h._createBefore(t), t.name, e, n);
                    this.batch.addOperation(i);
                    this.model.applyOperation(i)
                }
                split(t, e) {
                    this._assertWriterUsedCorrectly();
                    let n = t.parent;
                    if (!n.parent) {
                        throw new rr["b"]("writer-split-element-no-parent: Element with no parent can not be split.", this)
                    }
                    if (!e) {
                        e = n.parent
                    }
                    if (!t.parent.getAncestors({
                        includeSelf: true
                    }).includes(e)) {
                        throw new rr["b"]("writer-split-invalid-limit-element: Limit element is not a position ancestor.", this)
                    }
                    let i, o;
                    do {
                        const e = n.root.document ? n.root.document.version : null;
                        const s = n.maxOffset - t.offset;
                        const r = new rg(t, s, null, e);
                        this.batch.addOperation(r);
                        this.model.applyOperation(r);
                        if (!i && !o) {
                            i = n;
                            o = t.parent.nextSibling
                        }
                        t = this.createPositionAfter(t.parent);
                        n = t.parent
                    } while (n !== e); return {
                        position: t,
                        range: new Gh($h._createAt(i, "end"), $h._createAt(o, 0))
                    }
                }
                wrap(t, e) {
                    this._assertWriterUsedCorrectly();
                    if (!t.isFlat) {
                        throw new rr["b"]("writer-wrap-range-not-flat: Range to wrap is not flat.", this)
                    }
                    const n = e instanceof Hh ? e : new Hh(e);
                    if (n.childCount > 0) {
                        throw new rr["b"]("writer-wrap-element-not-empty: Element to wrap with is not empty.", this)
                    }
                    if (n.parent !== null) {
                        throw new rr["b"]("writer-wrap-element-attached: Element to wrap with is already attached to tree model.", this)
                    }
                    this.insert(n, t.start);
                    const i = new Gh(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
                    this.move(i, $h._createAt(n, 0))
                }
                unwrap(t) {
                    this._assertWriterUsedCorrectly();
                    if (t.parent === null) {
                        throw new rr["b"]("writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.", this)
                    }
                    this.move(Gh._createIn(t), this.createPositionAfter(t));
                    this.remove(t)
                }
                addMarker(t, e) {
                    this._assertWriterUsedCorrectly();
                    if (!e || typeof e.usingOperation != "boolean") {
                        throw new rr["b"]("writer-addMarker-no-usingOperation: The options.usingOperation parameter is required when adding a new marker.", this)
                    }
                    const n = e.usingOperation;
                    const i = e.range;
                    const o = e.affectsData === undefined ? false : e.affectsData;
                    if (this.model.markers.has(t)) {
                        throw new rr["b"]("writer-addMarker-marker-exists: Marker with provided name already exists.", this)
                    }
                    if (!i) {
                        throw new rr["b"]("writer-addMarker-no-range: Range parameter is required when adding a new marker.", this)
                    }
                    if (!n) {
                        return this.model.markers._set(t, i, n, o)
                    }
                    ug(this, t, null, i, o);
                    return this.model.markers.get(t)
                }
                updateMarker(t, e) {
                    this._assertWriterUsedCorrectly();
                    const n = typeof t == "string" ? t : t.name;
                    const i = this.model.markers.get(n);
                    if (!i) {
                        throw new rr["b"]("writer-updateMarker-marker-not-exists: Marker with provided name does not exists.", this)
                    }
                    if (!e) {
                        this.model.markers._refresh(i);
                        return
                    }
                    const o = typeof e.usingOperation == "boolean";
                    const s = typeof e.affectsData == "boolean";
                    const r = s ? e.affectsData : i.affectsData;
                    if (!o && !e.range && !s) {
                        throw new rr["b"]("writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.", this)
                    }
                    const a = i.getRange();
                    const c = e.range ? e.range : a;
                    if (o && e.usingOperation !== i.managedUsingOperations) {
                        if (e.usingOperation) {
                            ug(this, n, null, c, r)
                        } else {
                            ug(this, n, a, null, r);
                            this.model.markers._set(n, c, undefined, r)
                        }
                        return
                    }
                    if (i.managedUsingOperations) {
                        ug(this, n, a, c, r)
                    } else {
                        this.model.markers._set(n, c, undefined, r)
                    }
                }
                removeMarker(t) {
                    this._assertWriterUsedCorrectly();
                    const e = typeof t == "string" ? t : t.name;
                    if (!this.model.markers.has(e)) {
                        throw new rr["b"]("writer-removeMarker-no-marker: Trying to remove marker which does not exist.", this)
                    }
                    const n = this.model.markers.get(e);
                    if (!n.managedUsingOperations) {
                        this.model.markers._remove(e);
                        return
                    }
                    const i = n.getRange();
                    ug(this, e, i, null, n.affectsData)
                }
                setSelection(t, e, n) {
                    this._assertWriterUsedCorrectly();
                    this.model.document.selection._setTo(t, e, n)
                }
                setSelectionFocus(t, e) {
                    this._assertWriterUsedCorrectly();
                    this.model.document.selection._setFocus(t, e)
                }
                setSelectionAttribute(t, e) {
                    this._assertWriterUsedCorrectly();
                    if (typeof t === "string") {
                        this._setSelectionAttribute(t, e)
                    } else {
                        for (const [e, n] of Hr(t)) {
                            this._setSelectionAttribute(e, n)
                        }
                    }
                }
                removeSelectionAttribute(t) {
                    this._assertWriterUsedCorrectly();
                    if (typeof t === "string") {
                        this._removeSelectionAttribute(t)
                    } else {
                        for (const e of t) {
                            this._removeSelectionAttribute(e)
                        }
                    }
                }
                overrideSelectionGravity() {
                    return this.model.document.selection._overrideGravity()
                }
                restoreSelectionGravity(t) {
                    this.model.document.selection._restoreGravity(t)
                }
                _setSelectionAttribute(t, e) {
                    const n = this.model.document.selection;
                    if (n.isCollapsed && n.anchor.parent.isEmpty) {
                        const i = uf._getStoreAttributeKey(t);
                        this.setAttribute(i, e, n.anchor.parent)
                    }
                    n._setAttribute(t, e)
                }
                _removeSelectionAttribute(t) {
                    const e = this.model.document.selection;
                    if (e.isCollapsed && e.anchor.parent.isEmpty) {
                        const n = uf._getStoreAttributeKey(t);
                        this.removeAttribute(n, e.anchor.parent)
                    }
                    e._removeAttribute(t)
                }
                _assertWriterUsedCorrectly() {
                    if (this.model._currentWriter !== this) {
                        throw new rr["b"]("writer-incorrect-use: Trying to use a writer outside the change() block.", this)
                    }
                }
                _addOperationForAffectedMarkers(t, e) {
                    for (const n of this.model.markers) {
                        if (!n.managedUsingOperations) {
                            continue
                        }
                        const i = n.getRange();
                        let o = false;
                        if (t == "move") {
                            o = e.containsPosition(i.start) || e.start.isEqual(i.start) || e.containsPosition(i.end) || e.end.isEqual(i.end)
                        } else {
                            const t = e.nodeBefore;
                            const n = e.nodeAfter;
                            const s = i.start.parent == t && i.start.isAtEnd;
                            const r = i.end.parent == n && i.end.offset == 0;
                            const a = i.end.nodeAfter == n;
                            const c = i.start.nodeAfter == n;
                            o = s || r || a || c
                        }
                        if (o) {
                            this.updateMarker(n.name, {
                                range: i
                            })
                        }
                    }
                }
            }
            function lg(t, e, n, i) {
                const o = t.model;
                const s = o.document;
                let r = i.start;
                let a;
                let c;
                let l;
                for (const t of i.getWalker({
                    shallow: true
                })) {
                    l = t.item.getAttribute(e);
                    if (a && c != l) {
                        if (c != n) {
                            d()
                        }
                        r = a
                    }
                    a = t.nextPosition;
                    c = l
                }
                if (a instanceof $h && a != r && c != n) {
                    d()
                }
                function d() {
                    const i = new Gh(r, a);
                    const l = i.root.document ? s.version : null;
                    const d = new Xp(i, e, c, n, l);
                    t.batch.addOperation(d);
                    o.applyOperation(d)
                }
            }
            function dg(t, e, n, i) {
                const o = t.model;
                const s = o.document;
                const r = i.getAttribute(e);
                let a, c;
                if (r != n) {
                    const l = i.root === i;
                    if (l) {
                        const t = i.document ? s.version : null;
                        c = new og(i, e, r, n, t)
                    } else {
                        a = new Gh($h._createBefore(i), t.createPositionAfter(i));
                        const o = a.root.document ? s.version : null;
                        c = new Xp(a, e, r, n, o)
                    }
                    t.batch.addOperation(c);
                    o.applyOperation(c)
                }
            }
            function ug(t, e, n, i, o) {
                const s = t.model;
                const r = s.document;
                const a = new ng(e, n, i, s.markers, o, r.version);
                t.batch.addOperation(a);
                s.applyOperation(a)
            }
            function hg(t, e, n, i) {
                let o;
                if (t.root.document) {
                    const n = i.document;
                    const s = new $h(n.graveyard, [0]);
                    o = new tg(t, e, s, n.version)
                } else {
                    o = new Zp(t, e)
                }
                n.addOperation(o);
                i.applyOperation(o)
            }
            function fg(t, e) {
                if (t === e) {
                    return true
                }
                if (t instanceof ag && e instanceof ag) {
                    return true
                }
                return false
            }
            class pg {
                constructor(t) {
                    this._markerCollection = t;
                    this._changesInElement = new Map;
                    this._elementSnapshots = new Map;
                    this._changedMarkers = new Map;
                    this._changeCount = 0;
                    this._cachedChanges = null;
                    this._cachedChangesWithGraveyard = null
                }
                get isEmpty() {
                    return this._changesInElement.size == 0 && this._changedMarkers.size == 0
                }
                refreshItem(t) {
                    if (this._isInInsertedElement(t.parent)) {
                        return
                    }
                    this._markRemove(t.parent, t.startOffset, t.offsetSize);
                    this._markInsert(t.parent, t.startOffset, t.offsetSize);
                    const e = Gh._createOn(t);
                    for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                        const e = t.getRange();
                        this.bufferMarkerChange(t.name, e, e, t.affectsData)
                    }
                    this._cachedChanges = null
                }
                bufferOperation(t) {
                    switch (t.type) {
                        case "insert":
                            {
                                if (this._isInInsertedElement(t.position.parent)) {
                                    return
                                }
                                this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                                break
                            }
                        case "addAttribute":
                        case "removeAttribute":
                        case "changeAttribute":
                            {
                                for (const e of t.range.getItems({
                                    shallow: true
                                })) {
                                    if (this._isInInsertedElement(e.parent)) {
                                        continue
                                    }
                                    this._markAttribute(e)
                                }
                                break
                            }
                        case "remove":
                        case "move":
                        case "reinsert":
                            {
                                if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)) {
                                    return
                                }
                                const e = this._isInInsertedElement(t.sourcePosition.parent);
                                const n = this._isInInsertedElement(t.targetPosition.parent);
                                if (!e) {
                                    this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany)
                                }
                                if (!n) {
                                    this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany)
                                }
                                break
                            }
                        case "rename":
                            {
                                if (this._isInInsertedElement(t.position.parent)) {
                                    return
                                }
                                this._markRemove(t.position.parent, t.position.offset, 1);
                                this._markInsert(t.position.parent, t.position.offset, 1);
                                const e = Gh._createFromPositionAndShift(t.position, 1);
                                for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                                    const e = t.getRange();
                                    this.bufferMarkerChange(t.name, e, e, t.affectsData)
                                }
                                break
                            }
                        case "split":
                            {
                                const e = t.splitPosition.parent;
                                if (!this._isInInsertedElement(e)) {
                                    this._markRemove(e, t.splitPosition.offset, t.howMany)
                                }
                                if (!this._isInInsertedElement(t.insertionPosition.parent)) {
                                    this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1)
                                }
                                if (t.graveyardPosition) {
                                    this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1)
                                }
                                break
                            }
                        case "merge":
                            {
                                const e = t.sourcePosition.parent;
                                if (!this._isInInsertedElement(e.parent)) {
                                    this._markRemove(e.parent, e.startOffset, 1)
                                }
                                const n = t.graveyardPosition.parent;
                                this._markInsert(n, t.graveyardPosition.offset, 1);
                                const i = t.targetPosition.parent;
                                if (!this._isInInsertedElement(i)) {
                                    this._markInsert(i, t.targetPosition.offset, e.maxOffset)
                                }
                                break
                            }
                    }
                    this._cachedChanges = null
                }
                bufferMarkerChange(t, e, n, i) {
                    const o = this._changedMarkers.get(t);
                    if (!o) {
                        this._changedMarkers.set(t, {
                            oldRange: e,
                            newRange: n,
                            affectsData: i
                        })
                    } else {
                        o.newRange = n;
                        o.affectsData = i;
                        if (o.oldRange == null && o.newRange == null) {
                            this._changedMarkers.delete(t)
                        }
                    }
                }
                getMarkersToRemove() {
                    const t = [];
                    for (const [e, n] of this._changedMarkers) {
                        if (n.oldRange != null) {
                            t.push({
                                name: e,
                                range: n.oldRange
                            })
                        }
                    }
                    return t
                }
                getMarkersToAdd() {
                    const t = [];
                    for (const [e, n] of this._changedMarkers) {
                        if (n.newRange != null) {
                            t.push({
                                name: e,
                                range: n.newRange
                            })
                        }
                    }
                    return t
                }
                getChangedMarkers() {
                    return Array.from(this._changedMarkers).map(t => ({
                        name: t[0],
                        data: {
                            oldRange: t[1].oldRange,
                            newRange: t[1].newRange
                        }
                    }))
                }
                hasDataChanges() {
                    for (const [, t] of this._changedMarkers) {
                        if (t.affectsData) {
                            return true
                        }
                    }
                    return this._changesInElement.size > 0
                }
                getChanges(t = {
                    includeChangesInGraveyard: false
                }) {
                    if (this._cachedChanges) {
                        if (t.includeChangesInGraveyard) {
                            return this._cachedChangesWithGraveyard.slice()
                        } else {
                            return this._cachedChanges.slice()
                        }
                    }
                    const e = [];
                    for (const t of this._changesInElement.keys()) {
                        const n = this._changesInElement.get(t).sort((t, e) => {
                            if (t.offset === e.offset) {
                                if (t.type != e.type) {
                                    return t.type == "remove" ? -1 : 1
                                }
                                return 0
                            }
                            return t.offset < e.offset ? -1 : 1
                        }
                        );
                        const i = this._elementSnapshots.get(t);
                        const o = gg(t.getChildren());
                        const s = mg(i.length, n);
                        let r = 0;
                        let a = 0;
                        for (const n of s) {
                            if (n === "i") {
                                e.push(this._getInsertDiff(t, r, o[r].name));
                                r++
                            } else if (n === "r") {
                                e.push(this._getRemoveDiff(t, r, i[a].name));
                                a++
                            } else if (n === "a") {
                                const n = o[r].attributes;
                                const s = i[a].attributes;
                                let c;
                                if (o[r].name == "$text") {
                                    c = new Gh($h._createAt(t, r), $h._createAt(t, r + 1))
                                } else {
                                    const e = t.offsetToIndex(r);
                                    c = new Gh($h._createAt(t, r), $h._createAt(t.getChild(e), 0))
                                }
                                e.push(...this._getAttributesDiff(c, s, n));
                                r++;
                                a++
                            } else {
                                r++;
                                a++
                            }
                        }
                    }
                    e.sort((t, e) => {
                        if (t.position.root != e.position.root) {
                            return t.position.root.rootName < e.position.root.rootName ? -1 : 1
                        }
                        if (t.position.isEqual(e.position)) {
                            return t.changeCount - e.changeCount
                        }
                        return t.position.isBefore(e.position) ? -1 : 1
                    }
                    );
                    for (let t = 1; t < e.length; t++) {
                        const n = e[t - 1];
                        const i = e[t];
                        const o = n.type == "remove" && i.type == "remove" && n.name == "$text" && i.name == "$text" && n.position.isEqual(i.position);
                        const s = n.type == "insert" && i.type == "insert" && n.name == "$text" && i.name == "$text" && n.position.parent == i.position.parent && n.position.offset + n.length == i.position.offset;
                        const r = n.type == "attribute" && i.type == "attribute" && n.position.parent == i.position.parent && n.range.isFlat && i.range.isFlat && n.position.offset + n.length == i.position.offset && n.attributeKey == i.attributeKey && n.attributeOldValue == i.attributeOldValue && n.attributeNewValue == i.attributeNewValue;
                        if (o || s || r) {
                            e[t - 1].length++;
                            if (r) {
                                e[t - 1].range.end = e[t - 1].range.end.getShiftedBy(1)
                            }
                            e.splice(t, 1);
                            t--
                        }
                    }
                    for (const t of e) {
                        delete t.changeCount;
                        if (t.type == "attribute") {
                            delete t.position;
                            delete t.length
                        }
                    }
                    this._changeCount = 0;
                    this._cachedChangesWithGraveyard = e.slice();
                    this._cachedChanges = e.slice().filter(bg);
                    if (t.includeChangesInGraveyard) {
                        return this._cachedChangesWithGraveyard
                    } else {
                        return this._cachedChanges
                    }
                }
                reset() {
                    this._changesInElement.clear();
                    this._elementSnapshots.clear();
                    this._changedMarkers.clear();
                    this._cachedChanges = null
                }
                _markInsert(t, e, n) {
                    const i = {
                        type: "insert",
                        offset: e,
                        howMany: n,
                        count: this._changeCount++
                    };
                    this._markChange(t, i)
                }
                _markRemove(t, e, n) {
                    const i = {
                        type: "remove",
                        offset: e,
                        howMany: n,
                        count: this._changeCount++
                    };
                    this._markChange(t, i);
                    this._removeAllNestedChanges(t, e, n)
                }
                _markAttribute(t) {
                    const e = {
                        type: "attribute",
                        offset: t.startOffset,
                        howMany: t.offsetSize,
                        count: this._changeCount++
                    };
                    this._markChange(t.parent, e)
                }
                _markChange(t, e) {
                    this._makeSnapshot(t);
                    const n = this._getChangesForElement(t);
                    this._handleChange(e, n);
                    n.push(e);
                    for (let t = 0; t < n.length; t++) {
                        if (n[t].howMany < 1) {
                            n.splice(t, 1);
                            t--
                        }
                    }
                }
                _getChangesForElement(t) {
                    let e;
                    if (this._changesInElement.has(t)) {
                        e = this._changesInElement.get(t)
                    } else {
                        e = [];
                        this._changesInElement.set(t, e)
                    }
                    return e
                }
                _makeSnapshot(t) {
                    if (!this._elementSnapshots.has(t)) {
                        this._elementSnapshots.set(t, gg(t.getChildren()))
                    }
                }
                _handleChange(t, e) {
                    t.nodesToHandle = t.howMany;
                    for (const n of e) {
                        const i = t.offset + t.howMany;
                        const o = n.offset + n.howMany;
                        if (t.type == "insert") {
                            if (n.type == "insert") {
                                if (t.offset <= n.offset) {
                                    n.offset += t.howMany
                                } else if (t.offset < o) {
                                    n.howMany += t.nodesToHandle;
                                    t.nodesToHandle = 0
                                }
                            }
                            if (n.type == "remove") {
                                if (t.offset < n.offset) {
                                    n.offset += t.howMany
                                }
                            }
                            if (n.type == "attribute") {
                                if (t.offset <= n.offset) {
                                    n.offset += t.howMany
                                } else if (t.offset < o) {
                                    const o = n.howMany;
                                    n.howMany = t.offset - n.offset;
                                    e.unshift({
                                        type: "attribute",
                                        offset: i,
                                        howMany: o - n.howMany,
                                        count: this._changeCount++
                                    })
                                }
                            }
                        }
                        if (t.type == "remove") {
                            if (n.type == "insert") {
                                if (i <= n.offset) {
                                    n.offset -= t.howMany
                                } else if (i <= o) {
                                    if (t.offset < n.offset) {
                                        const e = i - n.offset;
                                        n.offset = t.offset;
                                        n.howMany -= e;
                                        t.nodesToHandle -= e
                                    } else {
                                        n.howMany -= t.nodesToHandle;
                                        t.nodesToHandle = 0
                                    }
                                } else {
                                    if (t.offset <= n.offset) {
                                        t.nodesToHandle -= n.howMany;
                                        n.howMany = 0
                                    } else if (t.offset < o) {
                                        const e = o - t.offset;
                                        n.howMany -= e;
                                        t.nodesToHandle -= e
                                    }
                                }
                            }
                            if (n.type == "remove") {
                                if (i <= n.offset) {
                                    n.offset -= t.howMany
                                } else if (t.offset < n.offset) {
                                    t.nodesToHandle += n.howMany;
                                    n.howMany = 0
                                }
                            }
                            if (n.type == "attribute") {
                                if (i <= n.offset) {
                                    n.offset -= t.howMany
                                } else if (t.offset < n.offset) {
                                    const e = i - n.offset;
                                    n.offset = t.offset;
                                    n.howMany -= e
                                } else if (t.offset < o) {
                                    if (i <= o) {
                                        const i = n.howMany;
                                        n.howMany = t.offset - n.offset;
                                        const o = i - n.howMany - t.nodesToHandle;
                                        e.unshift({
                                            type: "attribute",
                                            offset: t.offset,
                                            howMany: o,
                                            count: this._changeCount++
                                        })
                                    } else {
                                        n.howMany -= o - t.offset
                                    }
                                }
                            }
                        }
                        if (t.type == "attribute") {
                            if (n.type == "insert") {
                                if (t.offset < n.offset && i > n.offset) {
                                    if (i > o) {
                                        const t = {
                                            type: "attribute",
                                            offset: o,
                                            howMany: i - o,
                                            count: this._changeCount++
                                        };
                                        this._handleChange(t, e);
                                        e.push(t)
                                    }
                                    t.nodesToHandle = n.offset - t.offset;
                                    t.howMany = t.nodesToHandle
                                } else if (t.offset >= n.offset && t.offset < o) {
                                    if (i > o) {
                                        t.nodesToHandle = i - o;
                                        t.offset = o
                                    } else {
                                        t.nodesToHandle = 0
                                    }
                                }
                            }
                            if (n.type == "remove") {
                                if (t.offset < n.offset && i > n.offset) {
                                    const o = {
                                        type: "attribute",
                                        offset: n.offset,
                                        howMany: i - n.offset,
                                        count: this._changeCount++
                                    };
                                    this._handleChange(o, e);
                                    e.push(o);
                                    t.nodesToHandle = n.offset - t.offset;
                                    t.howMany = t.nodesToHandle
                                }
                            }
                            if (n.type == "attribute") {
                                if (t.offset >= n.offset && i <= o) {
                                    t.nodesToHandle = 0;
                                    t.howMany = 0;
                                    t.offset = 0
                                } else if (t.offset <= n.offset && i >= o) {
                                    n.howMany = 0
                                }
                            }
                        }
                    }
                    t.howMany = t.nodesToHandle;
                    delete t.nodesToHandle
                }
                _getInsertDiff(t, e, n) {
                    return {
                        type: "insert",
                        position: $h._createAt(t, e),
                        name: n,
                        length: 1,
                        changeCount: this._changeCount++
                    }
                }
                _getRemoveDiff(t, e, n) {
                    return {
                        type: "remove",
                        position: $h._createAt(t, e),
                        name: n,
                        length: 1,
                        changeCount: this._changeCount++
                    }
                }
                _getAttributesDiff(t, e, n) {
                    const i = [];
                    n = new Map(n);
                    for (const [o, s] of e) {
                        const e = n.has(o) ? n.get(o) : null;
                        if (e !== s) {
                            i.push({
                                type: "attribute",
                                position: t.start,
                                range: t.clone(),
                                length: 1,
                                attributeKey: o,
                                attributeOldValue: s,
                                attributeNewValue: e,
                                changeCount: this._changeCount++
                            })
                        }
                        n.delete(o)
                    }
                    for (const [e, o] of n) {
                        i.push({
                            type: "attribute",
                            position: t.start,
                            range: t.clone(),
                            length: 1,
                            attributeKey: e,
                            attributeOldValue: null,
                            attributeNewValue: o,
                            changeCount: this._changeCount++
                        })
                    }
                    return i
                }
                _isInInsertedElement(t) {
                    const e = t.parent;
                    if (!e) {
                        return false
                    }
                    const n = this._changesInElement.get(e);
                    const i = t.startOffset;
                    if (n) {
                        for (const t of n) {
                            if (t.type == "insert" && i >= t.offset && i < t.offset + t.howMany) {
                                return true
                            }
                        }
                    }
                    return this._isInInsertedElement(e)
                }
                _removeAllNestedChanges(t, e, n) {
                    const i = new Gh($h._createAt(t, e), $h._createAt(t, e + n));
                    for (const t of i.getItems({
                        shallow: true
                    })) {
                        if (t.is("element")) {
                            this._elementSnapshots.delete(t);
                            this._changesInElement.delete(t);
                            this._removeAllNestedChanges(t, 0, t.maxOffset)
                        }
                    }
                }
            }
            function gg(t) {
                const e = [];
                for (const n of t) {
                    if (n.is("text")) {
                        for (let t = 0; t < n.data.length; t++) {
                            e.push({
                                name: "$text",
                                attributes: new Map(n.getAttributes())
                            })
                        }
                    } else {
                        e.push({
                            name: n.name,
                            attributes: new Map(n.getAttributes())
                        })
                    }
                }
                return e
            }
            function mg(t, e) {
                const n = [];
                let i = 0;
                let o = 0;
                for (const t of e) {
                    if (t.offset > i) {
                        for (let e = 0; e < t.offset - i; e++) {
                            n.push("e")
                        }
                        o += t.offset - i
                    }
                    if (t.type == "insert") {
                        for (let e = 0; e < t.howMany; e++) {
                            n.push("i")
                        }
                        i = t.offset + t.howMany
                    } else if (t.type == "remove") {
                        for (let e = 0; e < t.howMany; e++) {
                            n.push("r")
                        }
                        i = t.offset;
                        o += t.howMany
                    } else {
                        n.push(..."a".repeat(t.howMany).split(""));
                        i = t.offset + t.howMany;
                        o += t.howMany
                    }
                }
                if (o < t) {
                    for (let e = 0; e < t - o - i; e++) {
                        n.push("e")
                    }
                }
                return n
            }
            function bg(t) {
                const e = t.position && t.position.root.rootName == "$graveyard";
                const n = t.range && t.range.root.rootName == "$graveyard";
                return !e && !n
            }
            class wg {
                constructor() {
                    this._operations = [];
                    this._undoPairs = new Map;
                    this._undoneOperations = new Set
                }
                addOperation(t) {
                    if (this._operations.includes(t)) {
                        return
                    }
                    this._operations.push(t)
                }
                getOperations(t = 0, e = Number.POSITIVE_INFINITY) {
                    if (t < 0) {
                        return []
                    }
                    return this._operations.slice(t, e)
                }
                getOperation(t) {
                    return this._operations[t]
                }
                setOperationAsUndone(t, e) {
                    this._undoPairs.set(e, t);
                    this._undoneOperations.add(t)
                }
                isUndoingOperation(t) {
                    return this._undoPairs.has(t)
                }
                isUndoneOperation(t) {
                    return this._undoneOperations.has(t)
                }
                getUndoneOperation(t) {
                    return this._undoPairs.get(t)
                }
            }
            function kg(t) {
                return !!t && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t)
            }
            function _g(t) {
                return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t)
            }
            function vg(t) {
                return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t)
            }
            function yg(t, e) {
                return _g(t.charAt(e - 1)) && vg(t.charAt(e))
            }
            function xg(t, e) {
                return kg(t.charAt(e))
            }
            const Cg = "$graveyard";
            class Ag {
                constructor(t) {
                    this.model = t;
                    this.version = 0;
                    this.history = new wg(this);
                    this.selection = new uf(this);
                    this.roots = new yr({
                        idProperty: "rootName"
                    });
                    this.differ = new pg(t.markers);
                    this._postFixers = new Set;
                    this._hasSelectionChangedFromTheLastChangeBlock = false;
                    this.createRoot("$root", Cg);
                    this.listenTo(t, "applyOperation", (t, e) => {
                        const n = e[0];
                        if (n.isDocumentOperation && n.baseVersion !== this.version) {
                            throw new rr["b"]("model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.", this, {
                                operation: n
                            })
                        }
                    }
                        , {
                            priority: "highest"
                        });
                    this.listenTo(t, "applyOperation", (t, e) => {
                        const n = e[0];
                        if (n.isDocumentOperation) {
                            this.differ.bufferOperation(n)
                        }
                    }
                        , {
                            priority: "high"
                        });
                    this.listenTo(t, "applyOperation", (t, e) => {
                        const n = e[0];
                        if (n.isDocumentOperation) {
                            this.version++;
                            this.history.addOperation(n)
                        }
                    }
                        , {
                            priority: "low"
                        });
                    this.listenTo(this.selection, "change", () => {
                        this._hasSelectionChangedFromTheLastChangeBlock = true
                    }
                    );
                    this.listenTo(t.markers, "update", (t, e, n, i) => {
                        this.differ.bufferMarkerChange(e.name, n, i, e.affectsData);
                        if (n === null) {
                            e.on("change", (t, n) => {
                                this.differ.bufferMarkerChange(e.name, n, e.getRange(), e.affectsData)
                            }
                            )
                        }
                    }
                    )
                }
                get graveyard() {
                    return this.getRoot(Cg)
                }
                createRoot(t = "$root", e = "main") {
                    if (this.roots.get(e)) {
                        throw new rr["b"]("model-document-createRoot-name-exists: Root with specified name already exists.", this, {
                            name: e
                        })
                    }
                    const n = new ag(this, t, e);
                    this.roots.add(n);
                    return n
                }
                destroy() {
                    this.selection.destroy();
                    this.stopListening()
                }
                getRoot(t = "main") {
                    return this.roots.get(t)
                }
                getRootNames() {
                    return Array.from(this.roots, t => t.rootName).filter(t => t != Cg)
                }
                registerPostFixer(t) {
                    this._postFixers.add(t)
                }
                toJSON() {
                    const t = Br(this);
                    t.selection = "[engine.model.DocumentSelection]";
                    t.model = "[engine.model.Model]";
                    return t
                }
                _handleChangeBlock(t) {
                    if (this._hasDocumentChangedFromTheLastChangeBlock()) {
                        this._callPostFixers(t);
                        this.selection.refresh();
                        if (this.differ.hasDataChanges()) {
                            this.fire("change:data", t.batch)
                        } else {
                            this.fire("change", t.batch)
                        }
                        this.selection.refresh();
                        this.differ.reset()
                    }
                    this._hasSelectionChangedFromTheLastChangeBlock = false
                }
                _hasDocumentChangedFromTheLastChangeBlock() {
                    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
                }
                _getDefaultRoot() {
                    for (const t of this.roots) {
                        if (t !== this.graveyard) {
                            return t
                        }
                    }
                    return this.graveyard
                }
                _getDefaultRange() {
                    const t = this._getDefaultRoot();
                    const e = this.model;
                    const n = e.schema;
                    const i = e.createPositionFromPath(t, [0]);
                    const o = n.getNearestSelectionRange(i);
                    return o || e.createRange(i)
                }
                _validateSelectionRange(t) {
                    return Pg(t.start) && Pg(t.end)
                }
                _callPostFixers(t) {
                    let e = false;
                    do {
                        for (const n of this._postFixers) {
                            this.selection.refresh();
                            e = n(t);
                            if (e) {
                                break
                            }
                        }
                    } while (e)
                }
            }
            vr(Ag, dr);
            function Pg(t) {
                const e = t.textNode;
                if (e) {
                    const n = e.data;
                    const i = t.offset - e.startOffset;
                    return !yg(n, i) && !xg(n, i)
                }
                return true
            }
            class Tg {
                constructor() {
                    this._markers = new Map
                }
                [Symbol.iterator]() {
                    return this._markers.values()
                }
                has(t) {
                    return this._markers.has(t)
                }
                get(t) {
                    return this._markers.get(t) || null
                }
                _set(t, e, n = false, i = false) {
                    const o = t instanceof Sg ? t.name : t;
                    const s = this._markers.get(o);
                    if (s) {
                        const t = s.getRange();
                        let r = false;
                        if (!t.isEqual(e)) {
                            s._attachLiveRange(rf.fromRange(e));
                            r = true
                        }
                        if (n != s.managedUsingOperations) {
                            s._managedUsingOperations = n;
                            r = true
                        }
                        if (typeof i === "boolean" && i != s.affectsData) {
                            s._affectsData = i;
                            r = true
                        }
                        if (r) {
                            this.fire("update:" + o, s, t, e)
                        }
                        return s
                    }
                    const r = rf.fromRange(e);
                    const a = new Sg(o, r, n, i);
                    this._markers.set(o, a);
                    this.fire("update:" + o, a, null, e);
                    return a
                }
                _remove(t) {
                    const e = t instanceof Sg ? t.name : t;
                    const n = this._markers.get(e);
                    if (n) {
                        this._markers.delete(e);
                        this.fire("update:" + e, n, n.getRange(), null);
                        this._destroyMarker(n);
                        return true
                    }
                    return false
                }
                _refresh(t) {
                    const e = t instanceof Sg ? t.name : t;
                    const n = this._markers.get(e);
                    if (!n) {
                        throw new rr["b"]("markercollection-refresh-marker-not-exists: Marker with provided name does not exists.", this)
                    }
                    const i = n.getRange();
                    this.fire("update:" + e, n, i, i, n.managedUsingOperations, n.affectsData)
                }
                *getMarkersAtPosition(t) {
                    for (const e of this) {
                        if (e.getRange().containsPosition(t)) {
                            yield e
                        }
                    }
                }
                *getMarkersIntersectingRange(t) {
                    for (const e of this) {
                        if (e.getRange().getIntersection(t) !== null) {
                            yield e
                        }
                    }
                }
                destroy() {
                    for (const t of this._markers.values()) {
                        this._destroyMarker(t)
                    }
                    this._markers = null;
                    this.stopListening()
                }
                *getMarkersGroup(t) {
                    for (const e of this._markers.values()) {
                        if (e.name.startsWith(t + ":")) {
                            yield e
                        }
                    }
                }
                _destroyMarker(t) {
                    t.stopListening();
                    t._detachLiveRange()
                }
            }
            vr(Tg, dr);
            class Sg {
                constructor(t, e, n, i) {
                    this.name = t;
                    this._liveRange = this._attachLiveRange(e);
                    this._managedUsingOperations = n;
                    this._affectsData = i
                }
                get managedUsingOperations() {
                    if (!this._liveRange) {
                        throw new rr["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this)
                    }
                    return this._managedUsingOperations
                }
                get affectsData() {
                    if (!this._liveRange) {
                        throw new rr["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this)
                    }
                    return this._affectsData
                }
                getStart() {
                    if (!this._liveRange) {
                        throw new rr["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this)
                    }
                    return this._liveRange.start.clone()
                }
                getEnd() {
                    if (!this._liveRange) {
                        throw new rr["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this)
                    }
                    return this._liveRange.end.clone()
                }
                getRange() {
                    if (!this._liveRange) {
                        throw new rr["b"]("marker-destroyed: Cannot use a destroyed marker instance.", this)
                    }
                    return this._liveRange.toRange()
                }
                is(t) {
                    return t == "marker" || t == "model:marker"
                }
                _attachLiveRange(t) {
                    if (this._liveRange) {
                        this._detachLiveRange()
                    }
                    t.delegate("change:range").to(this);
                    t.delegate("change:content").to(this);
                    this._liveRange = t;
                    return t
                }
                _detachLiveRange() {
                    this._liveRange.stopDelegating("change:range", this);
                    this._liveRange.stopDelegating("change:content", this);
                    this._liveRange.detach();
                    this._liveRange = null
                }
            }
            vr(Sg, dr);
            class Eg extends zp {
                get type() {
                    return "noop"
                }
                clone() {
                    return new Eg(this.baseVersion)
                }
                getReversed() {
                    return new Eg(this.baseVersion + 1)
                }
                _execute() { }
                static get className() {
                    return "NoOperation"
                }
            }
            const Rg = {};
            Rg[Xp.className] = Xp;
            Rg[eg.className] = eg;
            Rg[ng.className] = ng;
            Rg[tg.className] = tg;
            Rg[Eg.className] = Eg;
            Rg[zp.className] = zp;
            Rg[ig.className] = ig;
            Rg[og.className] = og;
            Rg[rg.className] = rg;
            Rg[sg.className] = sg;
            class Og {
                static fromJSON(t, e) {
                    return Rg[t.__className].fromJSON(t, e)
                }
            }
            class Mg extends $h {
                constructor(t, e, n = "toNone") {
                    super(t, e, n);
                    if (!this.root.is("rootElement")) {
                        throw new rr["b"]("model-liveposition-root-not-rootelement: LivePosition's root has to be an instance of RootElement.", t)
                    }
                    Ng.call(this)
                }
                detach() {
                    this.stopListening()
                }
                is(t) {
                    return t == "livePosition" || t == "model:livePosition" || super.is(t)
                }
                toPosition() {
                    return new $h(this.root, this.path.slice(), this.stickiness)
                }
                static fromPosition(t, e) {
                    return new this(t.root, t.path.slice(), e ? e : t.stickiness)
                }
            }
            function Ng() {
                this.listenTo(this.root.document.model, "applyOperation", (t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation) {
                        return
                    }
                    Ig.call(this, n)
                }
                    , {
                        priority: "low"
                    })
            }
            function Ig(t) {
                const e = this.getTransformedByOperation(t);
                if (!this.isEqual(e)) {
                    const t = this.toPosition();
                    this.path = e.path;
                    this.root = e.root;
                    this.fire("change", t)
                }
            }
            vr(Mg, dr);
            function Vg(t, e, n, i) {
                return t.change(o => {
                    let s;
                    if (!n) {
                        s = t.document.selection
                    } else if (n instanceof Zh || n instanceof uf) {
                        s = n
                    } else {
                        s = o.createSelection(n, i)
                    }
                    const r = s.getFirstPosition();
                    if (!s.isCollapsed) {
                        t.deleteContent(s, {
                            doNotAutoparagraph: true
                        })
                    }
                    const a = new Bg(t, o, r);
                    let c;
                    if (e.is("documentFragment")) {
                        c = e.getChildren()
                    } else {
                        c = [e]
                    }
                    a.handleNodes(c, {
                        isFirst: true,
                        isLast: true
                    });
                    const l = a.getSelectionRange();
                    if (l) {
                        if (s instanceof uf) {
                            o.setSelection(l)
                        } else {
                            s.setTo(l)
                        }
                    } else { }
                    const d = a.getAffectedRange() || t.createRange(r);
                    a.destroy();
                    return d
                }
                )
            }
            class Bg {
                constructor(t, e, n) {
                    this.model = t;
                    this.writer = e;
                    this.position = n;
                    this.canMergeWith = new Set([this.position.parent]);
                    this.schema = t.schema;
                    this._filterAttributesOf = [];
                    this._affectedStart = null;
                    this._affectedEnd = null
                }
                handleNodes(t, e) {
                    t = Array.from(t);
                    for (let n = 0; n < t.length; n++) {
                        const i = t[n];
                        this._handleNode(i, {
                            isFirst: n === 0 && e.isFirst,
                            isLast: n === t.length - 1 && e.isLast
                        })
                    }
                    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
                    this._filterAttributesOf = []
                }
                getSelectionRange() {
                    if (this.nodeToSelect) {
                        return Gh._createOn(this.nodeToSelect)
                    }
                    return this.model.schema.getNearestSelectionRange(this.position)
                }
                getAffectedRange() {
                    if (!this._affectedStart) {
                        return null
                    }
                    return new Gh(this._affectedStart, this._affectedEnd)
                }
                destroy() {
                    if (this._affectedStart) {
                        this._affectedStart.detach()
                    }
                    if (this._affectedEnd) {
                        this._affectedEnd.detach()
                    }
                }
                _handleNode(t, e) {
                    if (this.schema.isObject(t)) {
                        this._handleObject(t, e);
                        return
                    }
                    const n = this._checkAndSplitToAllowedPosition(t, e);
                    if (!n) {
                        this._handleDisallowedNode(t, e);
                        return
                    }
                    this._insert(t);
                    this._mergeSiblingsOf(t, e)
                }
                _handleObject(t, e) {
                    if (this._checkAndSplitToAllowedPosition(t)) {
                        this._insert(t)
                    } else {
                        this._tryAutoparagraphing(t, e)
                    }
                }
                _handleDisallowedNode(t, e) {
                    if (t.is("element")) {
                        this.handleNodes(t.getChildren(), e)
                    } else {
                        this._tryAutoparagraphing(t, e)
                    }
                }
                _insert(t) {
                    if (!this.schema.checkChild(this.position, t)) {
                        throw new rr["b"]("insertcontent-wrong-position: Given node cannot be inserted on the given position.", this, {
                            node: t,
                            position: this.position
                        })
                    }
                    const e = Mg.fromPosition(this.position, "toNext");
                    this._setAffectedBoundaries(this.position);
                    this.writer.insert(t, this.position);
                    this.position = e.toPosition();
                    e.detach();
                    if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) {
                        this.nodeToSelect = t
                    } else {
                        this.nodeToSelect = null
                    }
                    this._filterAttributesOf.push(t)
                }
                _setAffectedBoundaries(t) {
                    if (!this._affectedStart) {
                        this._affectedStart = Mg.fromPosition(t, "toPrevious")
                    }
                    if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
                        if (this._affectedEnd) {
                            this._affectedEnd.detach()
                        }
                        this._affectedEnd = Mg.fromPosition(t, "toNext")
                    }
                }
                _mergeSiblingsOf(t, e) {
                    if (!(t instanceof Hh)) {
                        return
                    }
                    const n = this._canMergeLeft(t, e);
                    const i = this._canMergeRight(t, e);
                    const o = Mg._createBefore(t);
                    o.stickiness = "toNext";
                    const s = Mg._createAfter(t);
                    s.stickiness = "toNext";
                    if (n) {
                        const t = Mg.fromPosition(this.position);
                        t.stickiness = "toNext";
                        if (this._affectedStart.isEqual(o)) {
                            this._affectedStart.detach();
                            this._affectedStart = Mg._createAt(o.nodeBefore, "end", "toPrevious")
                        }
                        this.writer.merge(o);
                        if (o.isEqual(this._affectedEnd) && e.isLast) {
                            this._affectedEnd.detach();
                            this._affectedEnd = Mg._createAt(o.nodeBefore, "end", "toNext")
                        }
                        this.position = t.toPosition();
                        t.detach()
                    }
                    if (i) {
                        if (!this.position.isEqual(s)) {
                            throw new rr["b"]("insertcontent-invalid-insertion-position", this)
                        }
                        this.position = $h._createAt(s.nodeBefore, "end");
                        const t = Mg.fromPosition(this.position, "toPrevious");
                        if (this._affectedEnd.isEqual(s)) {
                            this._affectedEnd.detach();
                            this._affectedEnd = Mg._createAt(s.nodeBefore, "end", "toNext")
                        }
                        this.writer.merge(s);
                        if (s.getShiftedBy(-1).isEqual(this._affectedStart) && e.isFirst) {
                            this._affectedStart.detach();
                            this._affectedStart = Mg._createAt(s.nodeBefore, 0, "toPrevious")
                        }
                        this.position = t.toPosition();
                        t.detach()
                    }
                    if (n || i) {
                        this._filterAttributesOf.push(this.position.parent)
                    }
                    o.detach();
                    s.detach()
                }
                _canMergeLeft(t, e) {
                    const n = t.previousSibling;
                    return e.isFirst && n instanceof Hh && this.canMergeWith.has(n) && this.model.schema.checkMerge(n, t)
                }
                _canMergeRight(t, e) {
                    const n = t.nextSibling;
                    return e.isLast && n instanceof Hh && this.canMergeWith.has(n) && this.model.schema.checkMerge(t, n)
                }
                _tryAutoparagraphing(t, e) {
                    const n = this.writer.createElement("paragraph");
                    if (this._getAllowedIn(n, this.position.parent) && this.schema.checkChild(n, t)) {
                        n._appendChild(t);
                        this._handleNode(n, e)
                    }
                }
                _checkAndSplitToAllowedPosition(t) {
                    const e = this._getAllowedIn(t, this.position.parent);
                    if (!e) {
                        return false
                    }
                    while (e != this.position.parent) {
                        if (this.schema.isLimit(this.position.parent)) {
                            return false
                        }
                        if (this.position.isAtStart) {
                            const t = this.position.parent;
                            this.position = this.writer.createPositionBefore(t);
                            if (t.isEmpty && t.parent === e) {
                                this.writer.remove(t)
                            }
                        } else if (this.position.isAtEnd) {
                            this.position = this.writer.createPositionAfter(this.position.parent)
                        } else {
                            const t = this.writer.createPositionAfter(this.position.parent);
                            this._setAffectedBoundaries(this.position);
                            this.writer.split(this.position);
                            this.position = t;
                            this.canMergeWith.add(this.position.nodeAfter)
                        }
                    }
                    return true
                }
                _getAllowedIn(t, e) {
                    if (this.schema.checkChild(e, t)) {
                        return e
                    }
                    if (e.parent) {
                        return this._getAllowedIn(t, e.parent)
                    }
                    return null
                }
            }
            function Fg(t, e, n = {}) {
                if (e.isCollapsed) {
                    return
                }
                const i = e.getFirstRange();
                if (i.root.rootName == "$graveyard") {
                    return
                }
                const o = t.schema;
                t.change(t => {
                    if (!n.doNotResetEntireContent && qg(o, e)) {
                        Hg(t, e, o);
                        return
                    }
                    const s = i.start;
                    const r = Mg.fromPosition(i.end, "toNext");
                    if (!i.start.isTouching(i.end)) {
                        t.remove(i)
                    }
                    if (!n.leaveUnmerged) {
                        Dg(t, s, r);
                        o.removeDisallowedAttributes(s.parent.getChildren(), t)
                    }
                    Wg(t, e, s);
                    if (zg(o, s)) {
                        const i = o.getNearestSelectionRange(s);
                        if (n.doNotAutoparagraph && i) {
                            Wg(t, e, i)
                        } else {
                            jg(t, s, e)
                        }
                    }
                    r.detach()
                }
                )
            }
            function Dg(t, e, n) {
                const i = e.parent;
                const o = n.parent;
                if (i == o) {
                    return
                }
                if (t.model.schema.isLimit(i) || t.model.schema.isLimit(o)) {
                    return
                }
                if (!Lg(e, n, t.model.schema)) {
                    return
                }
                e = t.createPositionAfter(i);
                n = t.createPositionBefore(o);
                if (!n.isEqual(e)) {
                    t.insert(o, e)
                }
                t.merge(e);
                while (n.parent.isEmpty) {
                    const e = n.parent;
                    n = t.createPositionBefore(e);
                    t.remove(e)
                }
                Dg(t, e, n)
            }
            function zg(t, e) {
                const n = t.checkChild(e, "$text");
                const i = t.checkChild(e, "paragraph");
                return !n && i
            }
            function Lg(t, e, n) {
                const i = new Gh(t, e);
                for (const t of i.getWalker()) {
                    if (n.isLimit(t.item)) {
                        return false
                    }
                }
                return true
            }
            function jg(t, e, n) {
                const i = t.createElement("paragraph");
                t.insert(i, e);
                Wg(t, n, t.createPositionAt(i, 0))
            }
            function Hg(t, e) {
                const n = t.model.schema.getLimitElement(e);
                t.remove(t.createRangeIn(n));
                jg(t, t.createPositionAt(n, 0), e)
            }
            function qg(t, e) {
                const n = t.getLimitElement(e);
                if (!e.containsEntireContent(n)) {
                    return false
                }
                const i = e.getFirstRange();
                if (i.start.parent == i.end.parent) {
                    return false
                }
                return t.checkChild(n, "paragraph")
            }
            function Wg(t, e, n) {
                if (e instanceof uf) {
                    t.setSelection(n)
                } else {
                    e.setTo(n)
                }
            }
            const Ug = ' ,.?!:;"-()';
            function $g(t, e, n = {}) {
                const i = t.schema;
                const o = n.direction != "backward";
                const s = n.unit ? n.unit : "character";
                const r = e.focus;
                const a = new Wh({
                    boundaries: Qg(r, o),
                    singleCharacters: true,
                    direction: o ? "forward" : "backward"
                });
                const c = {
                    walker: a,
                    schema: i,
                    isForward: o,
                    unit: s
                };
                let l;
                while (l = a.next()) {
                    if (l.done) {
                        return
                    }
                    const n = Gg(c, l.value);
                    if (n) {
                        if (e instanceof uf) {
                            t.change(t => {
                                t.setSelectionFocus(n)
                            }
                            )
                        } else {
                            e.setFocus(n)
                        }
                        return
                    }
                }
            }
            function Gg(t, e) {
                if (e.type == "text") {
                    if (t.unit === "word") {
                        return Jg(t.walker, t.isForward)
                    }
                    return Kg(t.walker, t.unit, t.isForward)
                }
                if (e.type == (t.isForward ? "elementStart" : "elementEnd")) {
                    if (t.schema.isObject(e.item)) {
                        return $h._createAt(e.item, t.isForward ? "after" : "before")
                    }
                    if (t.schema.checkChild(e.nextPosition, "$text")) {
                        return e.nextPosition
                    }
                } else {
                    if (t.schema.isLimit(e.item)) {
                        t.walker.skip(() => true);
                        return
                    }
                    if (t.schema.checkChild(e.nextPosition, "$text")) {
                        return e.nextPosition
                    }
                }
            }
            function Kg(t, e) {
                const n = t.position.textNode;
                if (n) {
                    const i = n.data;
                    let o = t.position.offset - n.startOffset;
                    while (yg(i, o) || e == "character" && xg(i, o)) {
                        t.next();
                        o = t.position.offset - n.startOffset
                    }
                }
                return t.position
            }
            function Jg(t, e) {
                let n = t.position.textNode;
                if (n) {
                    let i = t.position.offset - n.startOffset;
                    while (!Yg(n.data, i, e) && !Xg(n, i, e)) {
                        t.next();
                        const o = e ? t.position.nodeAfter : t.position.nodeBefore;
                        if (o && o.is("text")) {
                            const i = o.data.charAt(e ? 0 : o.data.length - 1);
                            if (!Ug.includes(i)) {
                                t.next();
                                n = t.position.textNode
                            }
                        }
                        i = t.position.offset - n.startOffset
                    }
                }
                return t.position
            }
            function Qg(t, e) {
                const n = t.root;
                const i = $h._createAt(n, e ? "end" : 0);
                if (e) {
                    return new Gh(t, i)
                } else {
                    return new Gh(i, t)
                }
            }
            function Yg(t, e, n) {
                const i = e + (n ? 0 : -1);
                return Ug.includes(t.charAt(i))
            }
            function Xg(t, e, n) {
                return e === (n ? t.endOffset : 0)
            }
            function Zg(t, e) {
                return t.change(t => {
                    const n = t.createDocumentFragment();
                    const i = e.getFirstRange();
                    if (!i || i.isCollapsed) {
                        return n
                    }
                    const o = i.start.root;
                    const s = i.start.getCommonPath(i.end);
                    const r = o.getNodeByPath(s);
                    let a;
                    if (i.start.parent == i.end.parent) {
                        a = i
                    } else {
                        a = t.createRange(t.createPositionAt(r, i.start.path[s.length]), t.createPositionAt(r, i.end.path[s.length] + 1))
                    }
                    const c = a.end.offset - a.start.offset;
                    for (const e of a.getItems({
                        shallow: true
                    })) {
                        if (e.is("textProxy")) {
                            t.appendText(e.data, e.getAttributes(), n)
                        } else {
                            t.append(e._clone(true), n)
                        }
                    }
                    if (a != i) {
                        const e = i._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0];
                        const o = t.createRange(t.createPositionAt(n, 0), e.start);
                        const s = t.createRange(e.end, t.createPositionAt(n, "end"));
                        tm(s, t);
                        tm(o, t)
                    }
                    return n
                }
                )
            }
            function tm(t, e) {
                const n = [];
                Array.from(t.getItems({
                    direction: "backward"
                })).map(t => e.createRangeOn(t)).filter(e => {
                    const n = (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end));
                    return n
                }
                ).forEach(t => {
                    n.push(t.start.parent);
                    e.remove(t)
                }
                );
                n.forEach(t => {
                    let n = t;
                    while (n.parent && n.isEmpty) {
                        const t = e.createRangeOn(n);
                        n = n.parent;
                        e.remove(t)
                    }
                }
                )
            }
            function em(t) {
                t.document.registerPostFixer(e => nm(e, t))
            }
            function nm(t, e) {
                const n = e.document.selection;
                const i = e.schema;
                const o = [];
                let s = false;
                for (const t of n.getRanges()) {
                    const e = im(t, i);
                    if (e) {
                        o.push(e);
                        s = true
                    } else {
                        o.push(t)
                    }
                }
                if (s) {
                    t.setSelection(cm(o), {
                        backward: n.isBackward
                    })
                }
            }
            function im(t, e) {
                if (t.isCollapsed) {
                    return om(t, e)
                }
                return sm(t, e)
            }
            function om(t, e) {
                const n = t.start;
                const i = e.getNearestSelectionRange(n);
                if (!i) {
                    return null
                }
                if (!i.isCollapsed) {
                    return i
                }
                const o = i.start;
                if (n.isEqual(o)) {
                    return null
                }
                return new Gh(o)
            }
            function sm(t, e) {
                const n = t.start;
                const i = t.end;
                const o = e.checkChild(n, "$text");
                const s = e.checkChild(i, "$text");
                const r = e.getLimitElement(n);
                const a = e.getLimitElement(i);
                if (r === a) {
                    if (o && s) {
                        return null
                    }
                    if (am(n, i, e)) {
                        const t = n.nodeAfter && e.isObject(n.nodeAfter);
                        const o = t ? null : e.getNearestSelectionRange(n, "forward");
                        const s = i.nodeBefore && e.isObject(i.nodeBefore);
                        const r = s ? null : e.getNearestSelectionRange(i, "backward");
                        const a = o ? o.start : n;
                        const c = r ? r.start : i;
                        return new Gh(a, c)
                    }
                }
                const c = r && !r.is("rootElement");
                const l = a && !a.is("rootElement");
                if (c || l) {
                    const t = n.nodeAfter && i.nodeBefore && n.nodeAfter.parent === i.nodeBefore.parent;
                    const o = c && (!t || !lm(n.nodeAfter, e));
                    const s = l && (!t || !lm(i.nodeBefore, e));
                    let d = n;
                    let u = i;
                    if (o) {
                        d = $h._createBefore(rm(r, e))
                    }
                    if (s) {
                        u = $h._createAfter(rm(a, e))
                    }
                    return new Gh(d, u)
                }
                return null
            }
            function rm(t, e) {
                let n = t;
                let i = n;
                while (e.isLimit(i) && i.parent) {
                    n = i;
                    i = i.parent
                }
                return n
            }
            function am(t, e, n) {
                const i = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text");
                const o = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text");
                return i || o
            }
            function cm(t) {
                const e = [];
                e.push(t.shift());
                for (const n of t) {
                    const t = e.pop();
                    if (n.isIntersecting(t)) {
                        const i = t.start.isAfter(n.start) ? n.start : t.start;
                        const o = t.end.isAfter(n.end) ? t.end : n.end;
                        const s = new Gh(i, o);
                        e.push(s)
                    } else {
                        e.push(t);
                        e.push(n)
                    }
                }
                return e
            }
            function lm(t, e) {
                return t && e.isObject(t)
            }
            class dm {
                constructor() {
                    this.markers = new Tg;
                    this.document = new Ag(this);
                    this.schema = new hp;
                    this._pendingChanges = [];
                    this._currentWriter = null;
                    ["insertContent", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach(t => this.decorate(t));
                    this.on("applyOperation", (t, e) => {
                        const n = e[0];
                        n._validate()
                    }
                        , {
                            priority: "highest"
                        });
                    this.schema.register("$root", {
                        isLimit: true
                    });
                    this.schema.register("$block", {
                        allowIn: "$root",
                        isBlock: true
                    });
                    this.schema.register("$text", {
                        allowIn: "$block",
                        isInline: true
                    });
                    this.schema.register("$clipboardHolder", {
                        allowContentOf: "$root",
                        isLimit: true
                    });
                    this.schema.extend("$text", {
                        allowIn: "$clipboardHolder"
                    });
                    this.schema.register("$marker");
                    this.schema.addChildCheck((t, e) => {
                        if (e.name === "$marker") {
                            return true
                        }
                    }
                    );
                    em(this)
                }
                change(t) {
                    try {
                        if (this._pendingChanges.length === 0) {
                            this._pendingChanges.push({
                                batch: new Dp,
                                callback: t
                            });
                            return this._runPendingChanges()[0]
                        } else {
                            return t(this._currentWriter)
                        }
                    } catch (t) {
                        rr["b"].rethrowUnexpectedError(t, this)
                    }
                }
                enqueueChange(t, e) {
                    try {
                        if (typeof t === "string") {
                            t = new Dp(t)
                        } else if (typeof t == "function") {
                            e = t;
                            t = new Dp
                        }
                        this._pendingChanges.push({
                            batch: t,
                            callback: e
                        });
                        if (this._pendingChanges.length == 1) {
                            this._runPendingChanges()
                        }
                    } catch (t) {
                        rr["b"].rethrowUnexpectedError(t, this)
                    }
                }
                applyOperation(t) {
                    t._execute()
                }
                insertContent(t, e, n) {
                    return Vg(this, t, e, n)
                }
                deleteContent(t, e) {
                    Fg(this, t, e)
                }
                modifySelection(t, e) {
                    $g(this, t, e)
                }
                getSelectedContent(t) {
                    return Zg(this, t)
                }
                hasContent(t, e) {
                    const n = t instanceof Hh ? Gh._createIn(t) : t;
                    if (n.isCollapsed) {
                        return false
                    }
                    for (const t of this.markers.getMarkersIntersectingRange(n)) {
                        if (t.affectsData) {
                            return true
                        }
                    }
                    const { ignoreWhitespaces: i = false } = e || {};
                    for (const t of n.getItems()) {
                        if (t.is("textProxy")) {
                            if (!i) {
                                return true
                            } else if (t.data.search(/\S/) !== -1) {
                                return true
                            }
                        } else if (this.schema.isObject(t)) {
                            return true
                        }
                    }
                    return false
                }
                createPositionFromPath(t, e, n) {
                    return new $h(t, e, n)
                }
                createPositionAt(t, e) {
                    return $h._createAt(t, e)
                }
                createPositionAfter(t) {
                    return $h._createAfter(t)
                }
                createPositionBefore(t) {
                    return $h._createBefore(t)
                }
                createRange(t, e) {
                    return new Gh(t, e)
                }
                createRangeIn(t) {
                    return Gh._createIn(t)
                }
                createRangeOn(t) {
                    return Gh._createOn(t)
                }
                createSelection(t, e, n) {
                    return new Zh(t, e, n)
                }
                createBatch(t) {
                    return new Dp(t)
                }
                createOperationFromJSON(t) {
                    return Og.fromJSON(t, this.document)
                }
                destroy() {
                    this.document.destroy();
                    this.stopListening()
                }
                _runPendingChanges() {
                    const t = [];
                    this.fire("_beforeChanges");
                    while (this._pendingChanges.length) {
                        const e = this._pendingChanges[0].batch;
                        this._currentWriter = new cg(this, e);
                        const n = this._pendingChanges[0].callback(this._currentWriter);
                        t.push(n);
                        this.document._handleChangeBlock(this._currentWriter);
                        this._pendingChanges.shift();
                        this._currentWriter = null
                    }
                    this.fire("_afterChanges");
                    return t
                }
            }
            vr(dm, Jc);
            class um {
                constructor() {
                    this._listener = Object.create(Ud)
                }
                listenTo(t) {
                    this._listener.listenTo(t, "keydown", (t, e) => {
                        this._listener.fire("_keydown:" + Bl(e), e)
                    }
                    )
                }
                set(t, e, n = {}) {
                    const i = Fl(t);
                    const o = n.priority;
                    this._listener.listenTo(this._listener, "_keydown:" + i, (t, n) => {
                        e(n, () => {
                            n.preventDefault();
                            n.stopPropagation();
                            t.stop()
                        }
                        );
                        t.return = true
                    }
                        , {
                            priority: o
                        })
                }
                press(t) {
                    return !!this._listener.fire("_keydown:" + Bl(t), t)
                }
                destroy() {
                    this._listener.stopListening()
                }
            }
            class hm extends um {
                constructor(t) {
                    super();
                    this.editor = t
                }
                set(t, e, n = {}) {
                    if (typeof e == "string") {
                        const t = e;
                        e = (e, n) => {
                            this.editor.execute(t);
                            n()
                        }
                    }
                    super.set(t, e, n)
                }
            }
            class fm {
                constructor(t = {}) {
                    this._context = t.context || new Mr({
                        language: t.language
                    });
                    this._context._addEditor(this, !t.context);
                    const e = Array.from(this.constructor.builtinPlugins || []);
                    this.config = new Js(t, this.constructor.defaultConfig);
                    this.config.define("plugins", e);
                    this.config.define(this._context._getEditorConfig());
                    this.plugins = new xr(this, e, this._context.plugins);
                    this.locale = this._context.locale;
                    this.t = this.locale.t;
                    this.commands = new lp;
                    this.set("state", "initializing");
                    this.once("ready", () => this.state = "ready", {
                        priority: "high"
                    });
                    this.once("destroy", () => this.state = "destroyed", {
                        priority: "high"
                    });
                    this.set("isReadOnly", false);
                    this.model = new dm;
                    this.data = new Np(this.model);
                    this.editing = new cp(this.model);
                    this.editing.view.document.bind("isReadOnly").to(this);
                    this.conversion = new Vp([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
                    this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
                    this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
                    this.keystrokes = new hm(this);
                    this.keystrokes.listenTo(this.editing.view.document)
                }
                initPlugins() {
                    const t = this.config;
                    const e = t.get("plugins");
                    const n = t.get("removePlugins") || [];
                    const i = t.get("extraPlugins") || [];
                    return this.plugins.init(e.concat(i), n)
                }
                destroy() {
                    let t = Promise.resolve();
                    if (this.state == "initializing") {
                        t = new Promise(t => this.once("ready", t))
                    }
                    return t.then(() => {
                        this.fire("destroy");
                        this.stopListening();
                        this.commands.destroy()
                    }
                    ).then(() => this.plugins.destroy()).then(() => {
                        this.model.destroy();
                        this.data.destroy();
                        this.editing.destroy();
                        this.keystrokes.destroy()
                    }
                    ).then(() => this._context._removeEditor(this))
                }
                execute(...t) {
                    try {
                        this.commands.execute(...t)
                    } catch (t) {
                        rr["b"].rethrowUnexpectedError(t, this)
                    }
                }
            }
            vr(fm, Jc);
            const pm = {
                setData(t) {
                    this.data.set(t)
                },
                getData(t) {
                    return this.data.get(t)
                }
            };
            var gm = pm;
            function mm(t, e) {
                if (t instanceof HTMLTextAreaElement) {
                    t.value = e
                }
                t.innerHTML = e
            }
            const bm = {
                updateSourceElement() {
                    if (!this.sourceElement) {
                        throw new rr["b"]("editor-missing-sourceelement: Cannot update the source element of a detached editor.", this)
                    }
                    mm(this.sourceElement, this.data.get())
                }
            };
            var wm = bm;
            function km(t) {
                if (!pt(t.updateSourceElement)) {
                    throw new rr["b"]("attachtoform-missing-elementapi-interface: Editor passed to attachToForm() must implement ElementApi.", t)
                }
                const e = t.sourceElement;
                if (e && e.tagName.toLowerCase() === "textarea" && e.form) {
                    let n;
                    const i = e.form;
                    const o = () => t.updateSourceElement();
                    if (pt(i.submit)) {
                        n = i.submit;
                        i.submit = () => {
                            o();
                            n.apply(i)
                        }
                    }
                    i.addEventListener("submit", o);
                    t.on("destroy", () => {
                        i.removeEventListener("submit", o);
                        if (n) {
                            i.submit = n
                        }
                    }
                    )
                }
            }
            class _m {
                getHtml(t) {
                    const e = document.implementation.createHTMLDocument("");
                    const n = e.createElement("div");
                    n.appendChild(t);
                    return n.innerHTML
                }
            }
            class vm {
                constructor() {
                    this._domParser = new DOMParser;
                    this._domConverter = new Dd({
                        blockFillerMode: "nbsp"
                    });
                    this._htmlWriter = new _m
                }
                toData(t) {
                    const e = this._domConverter.viewToDom(t, document);
                    return this._htmlWriter.getHtml(e)
                }
                toView(t) {
                    const e = this._toDom(t);
                    return this._domConverter.domToView(e)
                }
                _toDom(t) {
                    const e = this._domParser.parseFromString(t, "text/html");
                    const n = e.createDocumentFragment();
                    const i = e.body.childNodes;
                    while (i.length > 0) {
                        n.appendChild(i[0])
                    }
                    return n
                }
            }
            class ym {
                constructor(t) {
                    this.editor = t;
                    this._components = new Map
                }
                *names() {
                    for (const t of this._components.values()) {
                        yield t.originalName
                    }
                }
                add(t, e) {
                    if (this.has(t)) {
                        throw new rr["b"]("componentfactory-item-exists: The item already exists in the component factory.", this, {
                            name: t
                        })
                    }
                    this._components.set(xm(t), {
                        callback: e,
                        originalName: t
                    })
                }
                create(t) {
                    if (!this.has(t)) {
                        throw new rr["b"]("componentfactory-item-missing: The required component is not registered in the factory.", this, {
                            name: t
                        })
                    }
                    return this._components.get(xm(t)).callback(this.editor.locale)
                }
                has(t) {
                    return this._components.has(xm(t))
                }
            }
            function xm(t) {
                return String(t).toLowerCase()
            }
            class Cm {
                constructor() {
                    this.set("isFocused", false);
                    this.set("focusedElement", null);
                    this._elements = new Set;
                    this._nextEventLoopTimeout = null
                }
                add(t) {
                    if (this._elements.has(t)) {
                        throw new rr["b"]("focusTracker-add-element-already-exist", this)
                    }
                    this.listenTo(t, "focus", () => this._focus(t), {
                        useCapture: true
                    });
                    this.listenTo(t, "blur", () => this._blur(), {
                        useCapture: true
                    });
                    this._elements.add(t)
                }
                remove(t) {
                    if (t === this.focusedElement) {
                        this._blur(t)
                    }
                    if (this._elements.has(t)) {
                        this.stopListening(t);
                        this._elements.delete(t)
                    }
                }
                destroy() {
                    this.stopListening()
                }
                _focus(t) {
                    clearTimeout(this._nextEventLoopTimeout);
                    this.focusedElement = t;
                    this.isFocused = true
                }
                _blur() {
                    clearTimeout(this._nextEventLoopTimeout);
                    this._nextEventLoopTimeout = setTimeout(() => {
                        this.focusedElement = null;
                        this.isFocused = false
                    }
                        , 0)
                }
            }
            vr(Cm, Ud);
            vr(Cm, Jc);
            class Am {
                constructor(t) {
                    this.editor = t;
                    this.componentFactory = new ym(t);
                    this.focusTracker = new Cm;
                    this._editableElementsMap = new Map;
                    this.listenTo(t.editing.view.document, "layoutChanged", () => this.update())
                }
                get element() {
                    return null
                }
                update() {
                    this.fire("update")
                }
                destroy() {
                    this.stopListening();
                    this.focusTracker.destroy();
                    for (const t of this._editableElementsMap.values()) {
                        t.ckeditorInstance = null
                    }
                    this._editableElementsMap = new Map
                }
                setEditableElement(t, e) {
                    this._editableElementsMap.set(t, e);
                    if (!e.ckeditorInstance) {
                        e.ckeditorInstance = this.editor
                    }
                }
                getEditableElement(t = "main") {
                    return this._editableElementsMap.get(t)
                }
                getEditableElementsNames() {
                    return this._editableElementsMap.keys()
                }
                get _editableElements() {
                    console.warn("editor-ui-deprecated-editable-elements: " + "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {
                        editorUI: this
                    });
                    return this._editableElementsMap
                }
            }
            vr(Am, dr);
            function Pm({ origin: t, originKeystrokeHandler: e, originFocusTracker: n, toolbar: i, beforeFocus: o, afterBlur: s }) {
                n.add(i.element);
                e.set("Alt+F10", (t, e) => {
                    if (n.isFocused && !i.focusTracker.isFocused) {
                        if (o) {
                            o()
                        }
                        i.focus();
                        e()
                    }
                }
                );
                i.keystrokes.set("Esc", (e, n) => {
                    if (i.focusTracker.isFocused) {
                        t.focus();
                        if (s) {
                            s()
                        }
                        n()
                    }
                }
                )
            }
            function Tm(t) {
                if (Array.isArray(t)) {
                    return {
                        items: t
                    }
                }
                if (!t) {
                    return {
                        items: []
                    }
                }
                return Object.assign({
                    items: []
                }, t)
            }
            var Sm = n(13);
            const Em = new WeakMap;
            function Rm(t) {
                const { view: e, element: n, text: i, isDirectHost: o = true } = t;
                const s = e.document;
                if (!Em.has(s)) {
                    Em.set(s, new Map);
                    s.registerPostFixer(t => Vm(s, t))
                }
                Em.get(s).set(n, {
                    text: i,
                    isDirectHost: o
                });
                e.change(t => Vm(s, t))
            }
            function Om(t, e) {
                const n = e.document;
                t.change(t => {
                    if (!Em.has(n)) {
                        return
                    }
                    const i = Em.get(n);
                    const o = i.get(e);
                    t.removeAttribute("data-placeholder", o.hostElement);
                    Nm(t, o.hostElement);
                    i.delete(e)
                }
                )
            }
            function Mm(t, e) {
                if (!e.hasClass("ck-placeholder")) {
                    t.addClass("ck-placeholder", e);
                    return true
                }
                return false
            }
            function Nm(t, e) {
                if (e.hasClass("ck-placeholder")) {
                    t.removeClass("ck-placeholder", e);
                    return true
                }
                return false
            }
            function Im(t) {
                const e = t.document;
                if (!e) {
                    return false
                }
                const n = !Array.from(t.getChildren()).some(t => !t.is("uiElement"));
                if (!e.isFocused && n) {
                    return true
                }
                const i = e.selection;
                const o = i.anchor;
                if (n && o && o.parent !== t) {
                    return true
                }
                return false
            }
            function Vm(t, e) {
                const n = Em.get(t);
                let i = false;
                for (const [t, o] of n) {
                    if (Bm(e, t, o)) {
                        i = true
                    }
                }
                return i
            }
            function Bm(t, e, n) {
                const { text: i, isDirectHost: o } = n;
                const s = o ? e : Fm(e);
                let r = false;
                if (!s) {
                    return false
                }
                n.hostElement = s;
                if (s.getAttribute("data-placeholder") !== i) {
                    t.setAttribute("data-placeholder", i, s);
                    r = true
                }
                if (Im(s)) {
                    if (Mm(t, s)) {
                        r = true
                    }
                } else if (Nm(t, s)) {
                    r = true
                }
                return r
            }
            function Fm(t) {
                if (t.childCount === 1) {
                    const e = t.getChild(0);
                    if (e.is("element") && !e.is("uiElement")) {
                        return e
                    }
                }
                return null
            }
            class Dm {
                constructor() {
                    this._replacedElements = []
                }
                replace(t, e) {
                    this._replacedElements.push({
                        element: t,
                        newElement: e
                    });
                    t.style.display = "none";
                    if (e) {
                        t.parentNode.insertBefore(e, t.nextSibling)
                    }
                }
                restore() {
                    this._replacedElements.forEach(({ element: t, newElement: e }) => {
                        t.style.display = "";
                        if (e) {
                            e.remove()
                        }
                    }
                    );
                    this._replacedElements = []
                }
            }
            class zm extends Am {
                constructor(t, e) {
                    super(t);
                    this.view = e;
                    this._toolbarConfig = Tm(t.config.get("toolbar"));
                    this._elementReplacer = new Dm
                }
                get element() {
                    return this.view.element
                }
                init(t) {
                    const e = this.editor;
                    const n = this.view;
                    const i = e.editing.view;
                    const o = n.editable;
                    const s = i.document.getRoot();
                    o.name = s.rootName;
                    n.render();
                    const r = o.element;
                    this.setEditableElement(o.name, r);
                    this.focusTracker.add(r);
                    n.editable.bind("isFocused").to(this.focusTracker);
                    i.attachDomRoot(r);
                    if (t) {
                        this._elementReplacer.replace(t, this.element)
                    }
                    this._initPlaceholder();
                    this._initToolbar();
                    this.fire("ready")
                }
                destroy() {
                    const t = this.view;
                    const e = this.editor.editing.view;
                    this._elementReplacer.restore();
                    e.detachDomRoot(t.editable.name);
                    t.destroy();
                    super.destroy()
                }
                _initToolbar() {
                    const t = this.editor;
                    const e = this.view;
                    const n = t.editing.view;
                    e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
                    e.stickyPanel.limiterElement = e.element;
                    if (this._toolbarConfig.viewportTopOffset) {
                        e.stickyPanel.viewportTopOffset = this._toolbarConfig.viewportTopOffset
                    }
                    e.toolbar.fillFromConfig(this._toolbarConfig.items, this.componentFactory);
                    Pm({
                        origin: n,
                        originFocusTracker: this.focusTracker,
                        originKeystrokeHandler: t.keystrokes,
                        toolbar: e.toolbar
                    })
                }
                _initPlaceholder() {
                    const t = this.editor;
                    const e = t.editing.view;
                    const n = e.document.getRoot();
                    const i = t.sourceElement;
                    const o = t.config.get("placeholder") || i && i.tagName.toLowerCase() === "textarea" && i.getAttribute("placeholder");
                    if (o) {
                        Rm({
                            view: e,
                            element: n,
                            text: o,
                            isDirectHost: false
                        })
                    }
                }
            }
            class Lm extends yr {
                constructor(t) {
                    super({
                        idProperty: "viewUid"
                    });
                    this.on("add", (t, e, n) => {
                        if (!e.isRendered) {
                            e.render()
                        }
                        if (e.element && this._parentElement) {
                            this._parentElement.insertBefore(e.element, this._parentElement.children[n])
                        }
                    }
                    );
                    this.on("remove", (t, e) => {
                        if (e.element && this._parentElement) {
                            e.element.remove()
                        }
                    }
                    );
                    this.locale = t;
                    this._parentElement = null
                }
                destroy() {
                    this.map(t => t.destroy())
                }
                setParent(t) {
                    this._parentElement = t
                }
                delegate(...t) {
                    if (!t.length || !jm(t)) {
                        throw new rr["b"]("ui-viewcollection-delegate-wrong-events: All event names must be strings.", this)
                    }
                    return {
                        to: e => {
                            for (const n of this) {
                                for (const i of t) {
                                    n.delegate(i).to(e)
                                }
                            }
                            this.on("add", (n, i) => {
                                for (const n of t) {
                                    i.delegate(n).to(e)
                                }
                            }
                            );
                            this.on("remove", (n, i) => {
                                for (const n of t) {
                                    i.stopDelegating(n, e)
                                }
                            }
                            )
                        }
                    }
                }
            }
            function jm(t) {
                return t.every(t => typeof t == "string")
            }
            const Hm = "http://www.w3.org/1999/xhtml";
            class qm {
                constructor(t) {
                    Object.assign(this, tb(Zm(t)));
                    this._isRendered = false;
                    this._revertData = null
                }
                render() {
                    const t = this._renderNode({
                        intoFragment: true
                    });
                    this._isRendered = true;
                    return t
                }
                apply(t) {
                    this._revertData = fb();
                    this._renderNode({
                        node: t,
                        isApplying: true,
                        revertData: this._revertData
                    });
                    return t
                }
                revert(t) {
                    if (!this._revertData) {
                        throw new rr["b"]("ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.", [this, t])
                    }
                    this._revertTemplateFromNode(t, this._revertData)
                }
                *getViews() {
                    function* t(e) {
                        if (e.children) {
                            for (const n of e.children) {
                                if (db(n)) {
                                    yield n
                                } else if (ub(n)) {
                                    yield* t(n)
                                }
                            }
                        }
                    }
                    yield* t(this)
                }
                static bind(t, e) {
                    return {
                        to(n, i) {
                            return new Um({
                                eventNameOrFunction: n,
                                attribute: n,
                                observable: t,
                                emitter: e,
                                callback: i
                            })
                        },
                        if(n, i, o) {
                            return new $m({
                                observable: t,
                                emitter: e,
                                attribute: n,
                                valueIfTrue: i,
                                callback: o
                            })
                        }
                    }
                }
                static extend(t, e) {
                    if (t._isRendered) {
                        throw new rr["b"]("template-extend-render: Attempting to extend a template which has already been rendered.", [this, t])
                    }
                    cb(t, tb(Zm(e)))
                }
                _renderNode(t) {
                    let e;
                    if (t.node) {
                        e = this.tag && this.text
                    } else {
                        e = this.tag ? this.text : !this.text
                    }
                    if (e) {
                        throw new rr["b"]('ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering a new Node.', this)
                    }
                    if (this.text) {
                        return this._renderText(t)
                    } else {
                        return this._renderElement(t)
                    }
                }
                _renderElement(t) {
                    let e = t.node;
                    if (!e) {
                        e = t.node = document.createElementNS(this.ns || Hm, this.tag)
                    }
                    this._renderAttributes(t);
                    this._renderElementChildren(t);
                    this._setUpListeners(t);
                    return e
                }
                _renderText(t) {
                    let e = t.node;
                    if (e) {
                        t.revertData.text = e.textContent
                    } else {
                        e = t.node = document.createTextNode("")
                    }
                    if (Gm(this.text)) {
                        this._bindToObservable({
                            schema: this.text,
                            updater: Qm(e),
                            data: t
                        })
                    } else {
                        e.textContent = this.text.join("")
                    }
                    return e
                }
                _renderAttributes(t) {
                    let e, n, i, o;
                    if (!this.attributes) {
                        return
                    }
                    const s = t.node;
                    const r = t.revertData;
                    for (e in this.attributes) {
                        i = s.getAttribute(e);
                        n = this.attributes[e];
                        if (r) {
                            r.attributes[e] = i
                        }
                        o = ct(n[0]) && n[0].ns ? n[0].ns : null;
                        if (Gm(n)) {
                            const a = o ? n[0].value : n;
                            if (r && pb(e)) {
                                a.unshift(i)
                            }
                            this._bindToObservable({
                                schema: a,
                                updater: Ym(s, e, o),
                                data: t
                            })
                        } else if (e == "style" && typeof n[0] !== "string") {
                            this._renderStyleAttribute(n[0], t)
                        } else {
                            if (r && i && pb(e)) {
                                n.unshift(i)
                            }
                            n = n.map(t => t ? t.value || t : t).reduce((t, e) => t.concat(e), []).reduce(rb, "");
                            if (!lb(n)) {
                                s.setAttributeNS(o, e, n)
                            }
                        }
                    }
                }
                _renderStyleAttribute(t, e) {
                    const n = e.node;
                    for (const i in t) {
                        const o = t[i];
                        if (Gm(o)) {
                            this._bindToObservable({
                                schema: [o],
                                updater: Xm(n, i),
                                data: e
                            })
                        } else {
                            n.style[i] = o
                        }
                    }
                }
                _renderElementChildren(t) {
                    const e = t.node;
                    const n = t.intoFragment ? document.createDocumentFragment() : e;
                    const i = t.isApplying;
                    let o = 0;
                    for (const s of this.children) {
                        if (hb(s)) {
                            if (!i) {
                                s.setParent(e);
                                for (const t of s) {
                                    n.appendChild(t.element)
                                }
                            }
                        } else if (db(s)) {
                            if (!i) {
                                if (!s.isRendered) {
                                    s.render()
                                }
                                n.appendChild(s.element)
                            }
                        } else if (Cd(s)) {
                            n.appendChild(s)
                        } else {
                            if (i) {
                                const e = t.revertData;
                                const i = fb();
                                e.children.push(i);
                                s._renderNode({
                                    node: n.childNodes[o++],
                                    isApplying: true,
                                    revertData: i
                                })
                            } else {
                                n.appendChild(s.render())
                            }
                        }
                    }
                    if (t.intoFragment) {
                        e.appendChild(n)
                    }
                }
                _setUpListeners(t) {
                    if (!this.eventListeners) {
                        return
                    }
                    for (const e in this.eventListeners) {
                        const n = this.eventListeners[e].map(n => {
                            const [i, o] = e.split("@");
                            return n.activateDomEventListener(i, o, t)
                        }
                        );
                        if (t.revertData) {
                            t.revertData.bindings.push(n)
                        }
                    }
                }
                _bindToObservable({ schema: t, updater: e, data: n }) {
                    const i = n.revertData;
                    Jm(t, e, n);
                    const o = t.filter(t => !lb(t)).filter(t => t.observable).map(i => i.activateAttributeListener(t, e, n));
                    if (i) {
                        i.bindings.push(o)
                    }
                }
                _revertTemplateFromNode(t, e) {
                    for (const t of e.bindings) {
                        for (const e of t) {
                            e()
                        }
                    }
                    if (e.text) {
                        t.textContent = e.text;
                        return
                    }
                    for (const n in e.attributes) {
                        const i = e.attributes[n];
                        if (i === null) {
                            t.removeAttribute(n)
                        } else {
                            t.setAttribute(n, i)
                        }
                    }
                    for (let n = 0; n < e.children.length; ++n) {
                        this._revertTemplateFromNode(t.childNodes[n], e.children[n])
                    }
                }
            }
            vr(qm, dr);
            class Wm {
                constructor(t) {
                    Object.assign(this, t)
                }
                getValue(t) {
                    const e = this.observable[this.attribute];
                    return this.callback ? this.callback(e, t) : e
                }
                activateAttributeListener(t, e, n) {
                    const i = () => Jm(t, e, n);
                    this.emitter.listenTo(this.observable, "change:" + this.attribute, i);
                    return () => {
                        this.emitter.stopListening(this.observable, "change:" + this.attribute, i)
                    }
                }
            }
            class Um extends Wm {
                activateDomEventListener(t, e, n) {
                    const i = (t, n) => {
                        if (!e || n.target.matches(e)) {
                            if (typeof this.eventNameOrFunction == "function") {
                                this.eventNameOrFunction(n)
                            } else {
                                this.observable.fire(this.eventNameOrFunction, n)
                            }
                        }
                    }
                        ;
                    this.emitter.listenTo(n.node, t, i);
                    return () => {
                        this.emitter.stopListening(n.node, t, i)
                    }
                }
            }
            class $m extends Wm {
                getValue(t) {
                    const e = super.getValue(t);
                    return lb(e) ? false : this.valueIfTrue || true
                }
            }
            function Gm(t) {
                if (!t) {
                    return false
                }
                if (t.value) {
                    t = t.value
                }
                if (Array.isArray(t)) {
                    return t.some(Gm)
                } else if (t instanceof Wm) {
                    return true
                }
                return false
            }
            function Km(t, e) {
                return t.map(t => {
                    if (t instanceof Wm) {
                        return t.getValue(e)
                    }
                    return t
                }
                )
            }
            function Jm(t, e, { node: n }) {
                let i = Km(t, n);
                if (t.length == 1 && t[0] instanceof $m) {
                    i = i[0]
                } else {
                    i = i.reduce(rb, "")
                }
                if (lb(i)) {
                    e.remove()
                } else {
                    e.set(i)
                }
            }
            function Qm(t) {
                return {
                    set(e) {
                        t.textContent = e
                    },
                    remove() {
                        t.textContent = ""
                    }
                }
            }
            function Ym(t, e, n) {
                return {
                    set(i) {
                        t.setAttributeNS(n, e, i)
                    },
                    remove() {
                        t.removeAttributeNS(n, e)
                    }
                }
            }
            function Xm(t, e) {
                return {
                    set(n) {
                        t.style[e] = n
                    },
                    remove() {
                        t.style[e] = null
                    }
                }
            }
            function Zm(t) {
                const e = $s(t, t => {
                    if (t && (t instanceof Wm || ub(t) || db(t) || hb(t))) {
                        return t
                    }
                }
                );
                return e
            }
            function tb(t) {
                if (typeof t == "string") {
                    t = ib(t)
                } else if (t.text) {
                    ob(t)
                }
                if (t.on) {
                    t.eventListeners = nb(t.on);
                    delete t.on
                }
                if (!t.text) {
                    if (t.attributes) {
                        eb(t.attributes)
                    }
                    const e = [];
                    if (t.children) {
                        if (hb(t.children)) {
                            e.push(t.children)
                        } else {
                            for (const n of t.children) {
                                if (ub(n) || db(n) || Cd(n)) {
                                    e.push(n)
                                } else {
                                    e.push(new qm(n))
                                }
                            }
                        }
                    }
                    t.children = e
                }
                return t
            }
            function eb(t) {
                for (const e in t) {
                    if (t[e].value) {
                        t[e].value = [].concat(t[e].value)
                    }
                    sb(t, e)
                }
            }
            function nb(t) {
                for (const e in t) {
                    sb(t, e)
                }
                return t
            }
            function ib(t) {
                return {
                    text: [t]
                }
            }
            function ob(t) {
                if (!Array.isArray(t.text)) {
                    t.text = [t.text]
                }
            }
            function sb(t, e) {
                if (!Array.isArray(t[e])) {
                    t[e] = [t[e]]
                }
            }
            function rb(t, e) {
                if (lb(e)) {
                    return t
                } else if (lb(t)) {
                    return e
                } else {
                    return `${t} ${e}`
                }
            }
            function ab(t, e) {
                for (const n in e) {
                    if (t[n]) {
                        t[n].push(...e[n])
                    } else {
                        t[n] = e[n]
                    }
                }
            }
            function cb(t, e) {
                if (e.attributes) {
                    if (!t.attributes) {
                        t.attributes = {}
                    }
                    ab(t.attributes, e.attributes)
                }
                if (e.eventListeners) {
                    if (!t.eventListeners) {
                        t.eventListeners = {}
                    }
                    ab(t.eventListeners, e.eventListeners)
                }
                if (e.text) {
                    t.text.push(...e.text)
                }
                if (e.children && e.children.length) {
                    if (t.children.length != e.children.length) {
                        throw new rr["b"]("ui-template-extend-children-mismatch: The number of children in extended definition does not match.", t)
                    }
                    let n = 0;
                    for (const i of e.children) {
                        cb(t.children[n++], i)
                    }
                }
            }
            function lb(t) {
                return !t && t !== 0
            }
            function db(t) {
                return t instanceof mb
            }
            function ub(t) {
                return t instanceof qm
            }
            function hb(t) {
                return t instanceof Lm
            }
            function fb() {
                return {
                    children: [],
                    bindings: [],
                    attributes: {}
                }
            }
            function pb(t) {
                return t == "class" || t == "style"
            }
            var gb = n(15);
            class mb {
                constructor(t) {
                    this.element = null;
                    this.isRendered = false;
                    this.locale = t;
                    this.t = t && t.t;
                    this._viewCollections = new yr;
                    this._unboundChildren = this.createCollection();
                    this._viewCollections.on("add", (e, n) => {
                        n.locale = t
                    }
                    );
                    this.decorate("render")
                }
                get bindTemplate() {
                    if (this._bindTemplate) {
                        return this._bindTemplate
                    }
                    return this._bindTemplate = qm.bind(this, this)
                }
                createCollection() {
                    const t = new Lm;
                    this._viewCollections.add(t);
                    return t
                }
                registerChild(t) {
                    if (!jr(t)) {
                        t = [t]
                    }
                    for (const e of t) {
                        this._unboundChildren.add(e)
                    }
                }
                deregisterChild(t) {
                    if (!jr(t)) {
                        t = [t]
                    }
                    for (const e of t) {
                        this._unboundChildren.remove(e)
                    }
                }
                setTemplate(t) {
                    this.template = new qm(t)
                }
                extendTemplate(t) {
                    qm.extend(this.template, t)
                }
                render() {
                    if (this.isRendered) {
                        throw new rr["b"]("ui-view-render-already-rendered: This View has already been rendered.", this)
                    }
                    if (this.template) {
                        this.element = this.template.render();
                        this.registerChild(this.template.getViews())
                    }
                    this.isRendered = true
                }
                destroy() {
                    this.stopListening();
                    this._viewCollections.map(t => t.destroy());
                    if (this.template && this.template._revertData) {
                        this.template.revert(this.element)
                    }
                }
            }
            vr(mb, Ud);
            vr(mb, Jc);
            var bb = "[object String]";
            function wb(t) {
                return typeof t == "string" || !Je(t) && P(t) && _(t) == bb
            }
            var kb = wb;
            function _b(t, e, n = {}, i = []) {
                const o = n && n.xmlns;
                const s = o ? t.createElementNS(o, e) : t.createElement(e);
                for (const t in n) {
                    s.setAttribute(t, n[t])
                }
                if (kb(i) || !jr(i)) {
                    i = [i]
                }
                for (let e of i) {
                    if (kb(e)) {
                        e = t.createTextNode(e)
                    }
                    s.appendChild(e)
                }
                return s
            }
            class vb extends Lm {
                attachToDom() {
                    this._bodyCollectionContainer = new qm({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                            dir: this.locale.uiLanguageDirection
                        },
                        children: this
                    }).render();
                    let t = document.querySelector(".ck-body-wrapper");
                    if (!t) {
                        t = _b(document, "div", {
                            class: "ck-body-wrapper"
                        });
                        document.body.appendChild(t)
                    }
                    t.appendChild(this._bodyCollectionContainer)
                }
                detachFromDom() {
                    super.destroy();
                    if (this._bodyCollectionContainer) {
                        this._bodyCollectionContainer.remove()
                    }
                    const t = document.querySelector(".ck-body-wrapper");
                    if (t && t.childElementCount == 0) {
                        t.remove()
                    }
                }
            }
            var yb = n(17);
            class xb extends mb {
                constructor(t) {
                    super(t);
                    this.body = new vb(t)
                }
                render() {
                    super.render();
                    this.body.attachToDom()
                }
                destroy() {
                    this.body.detachFromDom();
                    return super.destroy()
                }
            }
            var Cb = n(19);
            class Ab extends mb {
                constructor(t) {
                    super(t);
                    this.set("text");
                    this.set("for");
                    this.id = `ck-editor__label_${nr()}`;
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "label",
                        attributes: {
                            class: ["ck", "ck-label"],
                            id: this.id,
                            for: e.to("for")
                        },
                        children: [{
                            text: e.to("text")
                        }]
                    })
                }
            }
            class Pb extends xb {
                constructor(t) {
                    super(t);
                    this.top = this.createCollection();
                    this.main = this.createCollection();
                    this._voiceLabelView = this._createVoiceLabel();
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                            role: "application",
                            dir: t.uiLanguageDirection,
                            lang: t.uiLanguage,
                            "aria-labelledby": this._voiceLabelView.id
                        },
                        children: [this._voiceLabelView, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-editor__top", "ck-reset_all"],
                                role: "presentation"
                            },
                            children: this.top
                        }, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-editor__main"],
                                role: "presentation"
                            },
                            children: this.main
                        }]
                    })
                }
                _createVoiceLabel() {
                    const t = this.t;
                    const e = new Ab;
                    e.text = t("bj");
                    e.extendTemplate({
                        attributes: {
                            class: "ck-voice-label"
                        }
                    });
                    return e
                }
            }
            class Tb extends mb {
                constructor(t, e, n) {
                    super(t);
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                            lang: t.contentLanguage,
                            dir: t.contentLanguageDirection
                        }
                    });
                    this.name = null;
                    this.set("isFocused", false);
                    this._editableElement = n;
                    this._hasExternalElement = !!this._editableElement;
                    this._editingView = e
                }
                render() {
                    super.render();
                    if (this._hasExternalElement) {
                        this.template.apply(this.element = this._editableElement)
                    } else {
                        this._editableElement = this.element
                    }
                    this.on("change:isFocused", () => this._updateIsFocusedClasses());
                    this._updateIsFocusedClasses()
                }
                destroy() {
                    if (this._hasExternalElement) {
                        this.template.revert(this._editableElement)
                    }
                    super.destroy()
                }
                _updateIsFocusedClasses() {
                    const t = this._editingView;
                    if (t.isRenderingInProgress) {
                        n(this)
                    } else {
                        e(this)
                    }
                    function e(e) {
                        t.change(n => {
                            const i = t.document.getRoot(e.name);
                            n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i);
                            n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i)
                        }
                        )
                    }
                    function n(i) {
                        t.once("change:isRenderingInProgress", (t, o, s) => {
                            if (!s) {
                                e(i)
                            } else {
                                n(i)
                            }
                        }
                        )
                    }
                }
            }
            class Sb extends Tb {
                constructor(t, e, n) {
                    super(t, e, n);
                    this.extendTemplate({
                        attributes: {
                            role: "textbox",
                            class: "ck-editor__editable_inline"
                        }
                    })
                }
                render() {
                    super.render();
                    const t = this._editingView;
                    const e = this.t;
                    t.change(n => {
                        const i = t.document.getRoot(this.name);
                        n.setAttribute("aria-label", e("bk", [this.name]), i)
                    }
                    )
                }
            }
            function Eb(t) {
                return e => e + t
            }
            var Rb = n(21);
            const Ob = Eb("px");
            class Mb extends mb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("isActive", false);
                    this.set("isSticky", false);
                    this.set("limiterElement", null);
                    this.set("limiterBottomOffset", 50);
                    this.set("viewportTopOffset", 0);
                    this.set("_marginLeft", null);
                    this.set("_isStickyToTheLimiter", false);
                    this.set("_hasViewportTopOffset", false);
                    this.content = this.createCollection();
                    this._contentPanelPlaceholder = new qm({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__placeholder"],
                            style: {
                                display: e.to("isSticky", t => t ? "block" : "none"),
                                height: e.to("isSticky", t => t ? Ob(this._panelRect.height) : null)
                            }
                        }
                    }).render();
                    this._contentPanel = new qm({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__content", e.if("isSticky", "ck-sticky-panel__content_sticky"), e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                            style: {
                                width: e.to("isSticky", t => t ? Ob(this._contentPanelPlaceholder.getBoundingClientRect().width) : null),
                                top: e.to("_hasViewportTopOffset", t => t ? Ob(this.viewportTopOffset) : null),
                                bottom: e.to("_isStickyToTheLimiter", t => t ? Ob(this.limiterBottomOffset) : null),
                                marginLeft: e.to("_marginLeft")
                            }
                        },
                        children: this.content
                    }).render();
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel"]
                        },
                        children: [this._contentPanelPlaceholder, this._contentPanel]
                    })
                }
                render() {
                    super.render();
                    this._checkIfShouldBeSticky();
                    this.listenTo(Nd.window, "scroll", () => {
                        this._checkIfShouldBeSticky()
                    }
                    );
                    this.listenTo(this, "change:isActive", () => {
                        this._checkIfShouldBeSticky()
                    }
                    )
                }
                _checkIfShouldBeSticky() {
                    const t = this._panelRect = this._contentPanel.getBoundingClientRect();
                    let e;
                    if (!this.limiterElement) {
                        this.isSticky = false
                    } else {
                        e = this._limiterRect = this.limiterElement.getBoundingClientRect();
                        this.isSticky = this.isActive && e.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e.height
                    }
                    if (this.isSticky) {
                        this._isStickyToTheLimiter = e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset;
                        this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;
                        this._marginLeft = this._isStickyToTheLimiter ? null : Ob(-Nd.window.scrollX)
                    } else {
                        this._isStickyToTheLimiter = false;
                        this._hasViewportTopOffset = false;
                        this._marginLeft = null
                    }
                }
            }
            class Nb {
                constructor(t) {
                    Object.assign(this, t);
                    if (t.actions && t.keystrokeHandler) {
                        for (const e in t.actions) {
                            let n = t.actions[e];
                            if (typeof n == "string") {
                                n = [n]
                            }
                            for (const i of n) {
                                t.keystrokeHandler.set(i, (t, n) => {
                                    this[e]();
                                    n()
                                }
                                )
                            }
                        }
                    }
                }
                get first() {
                    return this.focusables.find(Ib) || null
                }
                get last() {
                    return this.focusables.filter(Ib).slice(-1)[0] || null
                }
                get next() {
                    return this._getFocusableItem(1)
                }
                get previous() {
                    return this._getFocusableItem(-1)
                }
                get current() {
                    let t = null;
                    if (this.focusTracker.focusedElement === null) {
                        return null
                    }
                    this.focusables.find((e, n) => {
                        const i = e.element === this.focusTracker.focusedElement;
                        if (i) {
                            t = n
                        }
                        return i
                    }
                    );
                    return t
                }
                focusFirst() {
                    this._focus(this.first)
                }
                focusLast() {
                    this._focus(this.last)
                }
                focusNext() {
                    this._focus(this.next)
                }
                focusPrevious() {
                    this._focus(this.previous)
                }
                _focus(t) {
                    if (t) {
                        t.focus()
                    }
                }
                _getFocusableItem(t) {
                    const e = this.current;
                    const n = this.focusables.length;
                    if (!n) {
                        return null
                    }
                    if (e === null) {
                        return this[t === 1 ? "first" : "last"]
                    }
                    let i = (e + n + t) % n;
                    do {
                        const e = this.focusables.get(i);
                        if (Ib(e)) {
                            return e
                        }
                        i = (i + n + t) % n
                    } while (i !== e); return null
                }
            }
            function Ib(t) {
                return !!(t.focus && Nd.window.getComputedStyle(t.element).display != "none")
            }
            class Vb extends mb {
                constructor(t) {
                    super(t);
                    this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-toolbar__separator"]
                        }
                    })
                }
            }
            const Bb = 100;
            class Fb {
                constructor(t, e) {
                    if (!Fb._observerInstance) {
                        Fb._createObserver()
                    }
                    this._element = t;
                    this._callback = e;
                    Fb._addElementCallback(t, e);
                    Fb._observerInstance.observe(t)
                }
                destroy() {
                    Fb._deleteElementCallback(this._element, this._callback)
                }
                static _addElementCallback(t, e) {
                    if (!Fb._elementCallbacks) {
                        Fb._elementCallbacks = new Map
                    }
                    let n = Fb._elementCallbacks.get(t);
                    if (!n) {
                        n = new Set;
                        Fb._elementCallbacks.set(t, n)
                    }
                    n.add(e)
                }
                static _deleteElementCallback(t, e) {
                    const n = Fb._getElementCallbacks(t);
                    if (n) {
                        n.delete(e);
                        if (!n.size) {
                            Fb._elementCallbacks.delete(t);
                            Fb._observerInstance.unobserve(t)
                        }
                    }
                    if (Fb._elementCallbacks && !Fb._elementCallbacks.size) {
                        Fb._observerInstance = null;
                        Fb._elementCallbacks = null
                    }
                }
                static _getElementCallbacks(t) {
                    if (!Fb._elementCallbacks) {
                        return null
                    }
                    return Fb._elementCallbacks.get(t)
                }
                static _createObserver() {
                    let t;
                    if (typeof Nd.window.ResizeObserver === "function") {
                        t = Nd.window.ResizeObserver
                    } else {
                        t = Db
                    }
                    Fb._observerInstance = new t(t => {
                        for (const e of t) {
                            const t = Fb._getElementCallbacks(e.target);
                            if (t) {
                                for (const n of t) {
                                    n(e)
                                }
                            }
                        }
                    }
                    )
                }
            }
            Fb._observerInstance = null;
            Fb._elementCallbacks = null;
            class Db {
                constructor(t) {
                    this._callback = t;
                    this._elements = new Set;
                    this._previousRects = new Map;
                    this._periodicCheckTimeout = null
                }
                observe(t) {
                    this._elements.add(t);
                    this._checkElementRectsAndExecuteCallback();
                    if (this._elements.size === 1) {
                        this._startPeriodicCheck()
                    }
                }
                unobserve(t) {
                    this._elements.delete(t);
                    this._previousRects.delete(t);
                    if (!this._elements.size) {
                        this._stopPeriodicCheck()
                    }
                }
                _startPeriodicCheck() {
                    const t = () => {
                        this._checkElementRectsAndExecuteCallback();
                        this._periodicCheckTimeout = setTimeout(t, Bb)
                    }
                        ;
                    this.listenTo(Nd.window, "resize", () => {
                        this._checkElementRectsAndExecuteCallback()
                    }
                    );
                    this._periodicCheckTimeout = setTimeout(t, Bb)
                }
                _stopPeriodicCheck() {
                    clearTimeout(this._periodicCheckTimeout);
                    this.stopListening();
                    this._previousRects.clear()
                }
                _checkElementRectsAndExecuteCallback() {
                    const t = [];
                    for (const e of this._elements) {
                        if (this._hasRectChanged(e)) {
                            t.push({
                                target: e,
                                contentRect: this._previousRects.get(e)
                            })
                        }
                    }
                    if (t.length) {
                        this._callback(t)
                    }
                }
                _hasRectChanged(t) {
                    if (!t.ownerDocument.body.contains(t)) {
                        return false
                    }
                    const e = new yh(t);
                    const n = this._previousRects.get(t);
                    const i = !n || !n.isEqual(e);
                    this._previousRects.set(t, e);
                    return i
                }
            }
            vr(Db, Ud);
            function zb(t) {
                return t.bindTemplate.to(e => {
                    if (e.target === t.element) {
                        e.preventDefault()
                    }
                }
                )
            }
            class Lb extends mb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("isVisible", false);
                    this.set("position", "se");
                    this.children = this.createCollection();
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", t => `ck-dropdown__panel_${t}`), e.if("isVisible", "ck-dropdown__panel-visible")]
                        },
                        children: this.children,
                        on: {
                            selectstart: e.to(t => t.preventDefault())
                        }
                    })
                }
                focus() {
                    if (this.children.length) {
                        this.children.first.focus()
                    }
                }
                focusLast() {
                    if (this.children.length) {
                        const t = this.children.last;
                        if (typeof t.focusLast === "function") {
                            t.focusLast()
                        } else {
                            t.focus()
                        }
                    }
                }
            }
            var jb = n(23);
            function Hb(t) {
                while (t && t.tagName.toLowerCase() != "html") {
                    if (Nd.window.getComputedStyle(t).position != "static") {
                        return t
                    }
                    t = t.parentElement
                }
                return null
            }
            function qb({ element: t, target: e, positions: n, limiter: i, fitInViewport: o }) {
                if (pt(e)) {
                    e = e()
                }
                if (pt(i)) {
                    i = i()
                }
                const s = Hb(t.parentElement);
                const r = new yh(t);
                const a = new yh(e);
                let c;
                let l;
                if (!i && !o) {
                    [l, c] = Wb(n[0], a, r)
                } else {
                    const t = i && new yh(i).getVisible();
                    const e = o && new yh(Nd.window);
                    [l, c] = Ub(n, a, r, t, e) || Wb(n[0], a, r)
                }
                let { left: d, top: u } = $b(c);
                if (s) {
                    const t = $b(new yh(s));
                    const e = _h(s);
                    d -= t.left;
                    u -= t.top;
                    d += s.scrollLeft;
                    u += s.scrollTop;
                    d -= e.left;
                    u -= e.top
                }
                return {
                    left: d,
                    top: u,
                    name: l
                }
            }
            function Wb(t, e, n) {
                const { left: i, top: o, name: s } = t(e, n);
                return [s, n.clone().moveTo(i, o)]
            }
            function Ub(t, e, n, i, o) {
                let s = 0;
                let r = 0;
                let a;
                let c;
                const l = n.getArea();
                t.some(t => {
                    const [d, u] = Wb(t, e, n);
                    let h;
                    let f;
                    if (i) {
                        if (o) {
                            const t = i.getIntersection(o);
                            if (t) {
                                h = t.getIntersectionArea(u)
                            } else {
                                h = 0
                            }
                        } else {
                            h = i.getIntersectionArea(u)
                        }
                    }
                    if (o) {
                        f = o.getIntersectionArea(u)
                    }
                    if (o && !i) {
                        if (f > r) {
                            p()
                        }
                    } else if (!o && i) {
                        if (h > s) {
                            p()
                        }
                    } else {
                        if (f > r && h >= s) {
                            p()
                        } else if (f >= r && h > s) {
                            p()
                        }
                    }
                    function p() {
                        r = f;
                        s = h;
                        a = u;
                        c = d
                    }
                    return h === l
                }
                );
                return a ? [c, a] : null
            }
            function $b({ left: t, top: e }) {
                const { scrollX: n, scrollY: i } = Nd.window;
                return {
                    left: t + n,
                    top: e + i
                }
            }
            class Gb extends mb {
                constructor(t, e, n) {
                    super(t);
                    const i = this.bindTemplate;
                    this.buttonView = e;
                    this.panelView = n;
                    this.set("isOpen", false);
                    this.set("isEnabled", true);
                    this.set("class");
                    this.set("id");
                    this.set("panelPosition", "auto");
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-dropdown", i.to("class"), i.if("isEnabled", "ck-disabled", t => !t)],
                            id: i.to("id"),
                            "aria-describedby": i.to("ariaDescribedById")
                        },
                        children: [e, n]
                    });
                    e.extendTemplate({
                        attributes: {
                            class: ["ck-dropdown__button"]
                        }
                    })
                }
                render() {
                    super.render();
                    this.listenTo(this.buttonView, "open", () => {
                        this.isOpen = !this.isOpen
                    }
                    );
                    this.panelView.bind("isVisible").to(this, "isOpen");
                    this.on("change:isOpen", () => {
                        if (!this.isOpen) {
                            return
                        }
                        if (this.panelPosition === "auto") {
                            this.panelView.position = Gb._getOptimalPosition({
                                element: this.panelView.element,
                                target: this.buttonView.element,
                                fitInViewport: true,
                                positions: this._panelPositions
                            }).name
                        } else {
                            this.panelView.position = this.panelPosition
                        }
                    }
                    );
                    this.keystrokes.listenTo(this.element);
                    this.focusTracker.add(this.element);
                    const t = (t, e) => {
                        if (this.isOpen) {
                            this.buttonView.focus();
                            this.isOpen = false;
                            e()
                        }
                    }
                        ;
                    this.keystrokes.set("arrowdown", (t, e) => {
                        if (this.buttonView.isEnabled && !this.isOpen) {
                            this.isOpen = true;
                            e()
                        }
                    }
                    );
                    this.keystrokes.set("arrowright", (t, e) => {
                        if (this.isOpen) {
                            e()
                        }
                    }
                    );
                    this.keystrokes.set("arrowleft", t);
                    this.keystrokes.set("esc", t)
                }
                focus() {
                    this.buttonView.focus()
                }
                get _panelPositions() {
                    const { southEast: t, southWest: e, northEast: n, northWest: i } = Gb.defaultPanelPositions;
                    if (this.locale.uiLanguageDirection === "ltr") {
                        return [t, e, n, i]
                    } else {
                        return [e, t, i, n]
                    }
                }
            }
            Gb.defaultPanelPositions = {
                southEast: t => ({
                    top: t.bottom,
                    left: t.left,
                    name: "se"
                }),
                southWest: (t, e) => ({
                    top: t.bottom,
                    left: t.left - e.width + t.width,
                    name: "sw"
                }),
                northEast: (t, e) => ({
                    top: t.top - e.height,
                    left: t.left,
                    name: "ne"
                }),
                northWest: (t, e) => ({
                    top: t.bottom - e.height,
                    left: t.left - e.width + t.width,
                    name: "nw"
                })
            };
            Gb._getOptimalPosition = qb;
            var Kb = n(25);
            class Jb extends mb {
                constructor() {
                    super();
                    const t = this.bindTemplate;
                    this.set("content", "");
                    this.set("viewBox", "0 0 20 20");
                    this.set("fillColor", "");
                    this.setTemplate({
                        tag: "svg",
                        ns: "http://www.w3.org/2000/svg",
                        attributes: {
                            class: ["ck", "ck-icon"],
                            viewBox: t.to("viewBox")
                        }
                    })
                }
                render() {
                    super.render();
                    this._updateXMLContent();
                    this._colorFillPaths();
                    this.on("change:content", () => {
                        this._updateXMLContent();
                        this._colorFillPaths()
                    }
                    );
                    this.on("change:fillColor", () => {
                        this._colorFillPaths()
                    }
                    )
                }
                _updateXMLContent() {
                    if (this.content) {
                        const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml");
                        const e = t.querySelector("svg");
                        const n = e.getAttribute("viewBox");
                        if (n) {
                            this.viewBox = n
                        }
                        this.element.innerHTML = "";
                        while (e.childNodes.length > 0) {
                            this.element.appendChild(e.childNodes[0])
                        }
                    }
                }
                _colorFillPaths() {
                    if (this.fillColor) {
                        this.element.querySelectorAll(".ck-icon__fill").forEach(t => {
                            t.style.fill = this.fillColor
                        }
                        )
                    }
                }
            }
            var Qb = n(27);
            class Yb extends mb {
                constructor(t) {
                    super(t);
                    this.set("text", "");
                    this.set("position", "s");
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-tooltip", e.to("position", t => "ck-tooltip_" + t), e.if("text", "ck-hidden", t => !t.trim())]
                        },
                        children: [{
                            tag: "span",
                            attributes: {
                                class: ["ck", "ck-tooltip__text"]
                            },
                            children: [{
                                text: e.to("text")
                            }]
                        }]
                    })
                }
            }
            var Xb = n(29);
            class Zb extends mb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    const n = nr();
                    this.set("class");
                    this.set("labelStyle");
                    this.set("icon");
                    this.set("isEnabled", true);
                    this.set("isOn", false);
                    this.set("isVisible", true);
                    this.set("isToggleable", false);
                    this.set("keystroke");
                    this.set("label");
                    this.set("tabindex", -1);
                    this.set("tooltip");
                    this.set("tooltipPosition", "s");
                    this.set("type", "button");
                    this.set("withText", false);
                    this.set("withKeystroke", false);
                    this.children = this.createCollection();
                    this.tooltipView = this._createTooltipView();
                    this.labelView = this._createLabelView(n);
                    this.iconView = new Jb;
                    this.iconView.extendTemplate({
                        attributes: {
                            class: "ck-button__icon"
                        }
                    });
                    this.keystrokeView = this._createKeystrokeView();
                    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                    this.setTemplate({
                        tag: "button",
                        attributes: {
                            class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", t => !t), e.if("isVisible", "ck-hidden", t => !t), e.to("isOn", t => t ? "ck-on" : "ck-off"), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")],
                            type: e.to("type", t => t ? t : "button"),
                            tabindex: e.to("tabindex"),
                            "aria-labelledby": `ck-editor__aria-label_${n}`,
                            "aria-disabled": e.if("isEnabled", true, t => !t),
                            "aria-pressed": e.to("isOn", t => this.isToggleable ? String(t) : false)
                        },
                        children: this.children,
                        on: {
                            mousedown: e.to(t => {
                                t.preventDefault()
                            }
                            ),
                            click: e.to(t => {
                                if (this.isEnabled) {
                                    this.fire("execute")
                                } else {
                                    t.preventDefault()
                                }
                            }
                            )
                        }
                    })
                }
                render() {
                    super.render();
                    if (this.icon) {
                        this.iconView.bind("content").to(this, "icon");
                        this.children.add(this.iconView)
                    }
                    this.children.add(this.tooltipView);
                    this.children.add(this.labelView);
                    if (this.withKeystroke) {
                        this.children.add(this.keystrokeView)
                    }
                }
                focus() {
                    this.element.focus()
                }
                _createTooltipView() {
                    const t = new Yb;
                    t.bind("text").to(this, "_tooltipString");
                    t.bind("position").to(this, "tooltipPosition");
                    return t
                }
                _createLabelView(t) {
                    const e = new mb;
                    const n = this.bindTemplate;
                    e.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__label"],
                            style: n.to("labelStyle"),
                            id: `ck-editor__aria-label_${t}`
                        },
                        children: [{
                            text: this.bindTemplate.to("label")
                        }]
                    });
                    return e
                }
                _createKeystrokeView() {
                    const t = new mb;
                    t.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__keystroke"]
                        },
                        children: [{
                            text: this.bindTemplate.to("keystroke", t => Dl(t))
                        }]
                    });
                    return t
                }
                _getTooltipString(t, e, n) {
                    if (t) {
                        if (typeof t == "string") {
                            return t
                        } else {
                            if (n) {
                                n = Dl(n)
                            }
                            if (t instanceof Function) {
                                return t(e, n)
                            } else {
                                return `${e}${n ? ` (${n})` : ""}`
                            }
                        }
                    }
                    return ""
                }
            }
            var tw = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 111.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 111.06 1.06l-3.549 3.55a.75.75 0 01-1.168-.136L.941 4.523z"/></svg>';
            class ew extends Zb {
                constructor(t) {
                    super(t);
                    this.arrowView = this._createArrowView();
                    this.extendTemplate({
                        attributes: {
                            "aria-haspopup": true
                        }
                    });
                    this.delegate("execute").to(this, "open")
                }
                render() {
                    super.render();
                    this.children.add(this.arrowView)
                }
                _createArrowView() {
                    const t = new Jb;
                    t.content = tw;
                    t.extendTemplate({
                        attributes: {
                            class: "ck-dropdown__arrow"
                        }
                    });
                    return t
                }
            }
            var nw = n(31);
            class iw extends mb {
                constructor() {
                    super();
                    this.items = this.createCollection();
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this._focusCycler = new Nb({
                        focusables: this.items,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "arrowup",
                            focusNext: "arrowdown"
                        }
                    });
                    this.setTemplate({
                        tag: "ul",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-list"]
                        },
                        children: this.items
                    })
                }
                render() {
                    super.render();
                    for (const t of this.items) {
                        this.focusTracker.add(t.element)
                    }
                    this.items.on("add", (t, e) => {
                        this.focusTracker.add(e.element)
                    }
                    );
                    this.items.on("remove", (t, e) => {
                        this.focusTracker.remove(e.element)
                    }
                    );
                    this.keystrokes.listenTo(this.element)
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                focusLast() {
                    this._focusCycler.focusLast()
                }
            }
            class ow extends mb {
                constructor(t) {
                    super(t);
                    this.children = this.createCollection();
                    this.setTemplate({
                        tag: "li",
                        attributes: {
                            class: ["ck", "ck-list__item"]
                        },
                        children: this.children
                    })
                }
                focus() {
                    this.children.first.focus()
                }
            }
            class sw extends mb {
                constructor(t) {
                    super(t);
                    this.setTemplate({
                        tag: "li",
                        attributes: {
                            class: ["ck", "ck-list__separator"]
                        }
                    })
                }
            }
            var rw = n(33);
            class aw extends Zb {
                constructor(t) {
                    super(t);
                    this.isToggleable = true;
                    this.toggleSwitchView = this._createToggleView();
                    this.extendTemplate({
                        attributes: {
                            class: "ck-switchbutton"
                        }
                    })
                }
                render() {
                    super.render();
                    this.children.add(this.toggleSwitchView)
                }
                _createToggleView() {
                    const t = new mb;
                    t.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__toggle"]
                        },
                        children: [{
                            tag: "span",
                            attributes: {
                                class: ["ck", "ck-button__toggle__inner"]
                            }
                        }]
                    });
                    return t
                }
            }
            function cw({ emitter: t, activator: e, callback: n, contextElements: i }) {
                t.listenTo(document, "mousedown", (t, { target: o }) => {
                    if (!e()) {
                        return
                    }
                    for (const t of i) {
                        if (t.contains(o)) {
                            return
                        }
                    }
                    n()
                }
                )
            }
            var lw = n(35);
            var dw = n(37);
            function uw(t, e = ew) {
                const n = new e(t);
                const i = new Lb(t);
                const o = new Gb(t, n, i);
                n.bind("isEnabled").to(o);
                if (n instanceof ew) {
                    n.bind("isOn").to(o, "isOpen")
                } else {
                    n.arrowView.bind("isOn").to(o, "isOpen")
                }
                pw(o);
                return o
            }
            function hw(t, e) {
                const n = t.locale;
                const i = n.t;
                const o = t.toolbarView = new _w(n);
                o.set("ariaLabel", i("bi"));
                t.extendTemplate({
                    attributes: {
                        class: ["ck-toolbar-dropdown"]
                    }
                });
                e.map(t => o.items.add(t));
                t.panelView.children.add(o);
                o.items.delegate("execute").to(t)
            }
            function fw(t, e) {
                const n = t.locale;
                const i = t.listView = new iw(n);
                i.items.bindTo(e).using(({ type: t, model: e }) => {
                    if (t === "separator") {
                        return new sw(n)
                    } else if (t === "button" || t === "switchbutton") {
                        const i = new ow(n);
                        let o;
                        if (t === "button") {
                            o = new Zb(n)
                        } else {
                            o = new aw(n)
                        }
                        o.bind(...Object.keys(e)).to(e);
                        o.delegate("execute").to(i);
                        i.children.add(o);
                        return i
                    }
                }
                );
                t.panelView.children.add(i);
                i.items.delegate("execute").to(t)
            }
            function pw(t) {
                gw(t);
                mw(t);
                bw(t)
            }
            function gw(t) {
                t.on("render", () => {
                    cw({
                        emitter: t,
                        activator: () => t.isOpen,
                        callback: () => {
                            t.isOpen = false
                        }
                        ,
                        contextElements: [t.element]
                    })
                }
                )
            }
            function mw(t) {
                t.on("execute", e => {
                    if (e.source instanceof aw) {
                        return
                    }
                    t.isOpen = false
                }
                )
            }
            function bw(t) {
                t.keystrokes.set("arrowdown", (e, n) => {
                    if (t.isOpen) {
                        t.panelView.focus();
                        n()
                    }
                }
                );
                t.keystrokes.set("arrowup", (e, n) => {
                    if (t.isOpen) {
                        t.panelView.focusLast();
                        n()
                    }
                }
                )
            }
            var ww = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
            var kw = n(39);
            class _w extends mb {
                constructor(t, e) {
                    super(t);
                    const n = this.bindTemplate;
                    const i = this.t;
                    this.options = e || {};
                    this.set("ariaLabel", i("bg"));
                    this.items = this.createCollection();
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this.set("class");
                    this.set("isCompact", false);
                    this.itemsView = new vw(t);
                    this.children = this.createCollection();
                    this.children.add(this.itemsView);
                    this.focusables = this.createCollection();
                    this._focusCycler = new Nb({
                        focusables: this.focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: ["arrowleft", "arrowup"],
                            focusNext: ["arrowright", "arrowdown"]
                        }
                    });
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")],
                            role: "toolbar",
                            "aria-label": n.to("ariaLabel")
                        },
                        children: this.children,
                        on: {
                            mousedown: zb(this)
                        }
                    });
                    this._behavior = this.options.shouldGroupWhenFull ? new xw(this) : new yw(this)
                }
                render() {
                    super.render();
                    for (const t of this.items) {
                        this.focusTracker.add(t.element)
                    }
                    this.items.on("add", (t, e) => {
                        this.focusTracker.add(e.element)
                    }
                    );
                    this.items.on("remove", (t, e) => {
                        this.focusTracker.remove(e.element)
                    }
                    );
                    this.keystrokes.listenTo(this.element);
                    this._behavior.render(this)
                }
                destroy() {
                    this._behavior.destroy();
                    return super.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                focusLast() {
                    this._focusCycler.focusLast()
                }
                fillFromConfig(t, e) {
                    t.map(t => {
                        if (t == "|") {
                            this.items.add(new Vb)
                        } else if (e.has(t)) {
                            this.items.add(e.create(t))
                        } else {
                            console.warn(Object(rr["a"])("toolbarview-item-unavailable: The requested toolbar item is unavailable."), {
                                name: t
                            })
                        }
                    }
                    )
                }
            }
            class vw extends mb {
                constructor(t) {
                    super(t);
                    this.children = this.createCollection();
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-toolbar__items"]
                        },
                        children: this.children
                    })
                }
            }
            class yw {
                constructor(t) {
                    const e = t.bindTemplate;
                    t.set("isVertical", false);
                    t.itemsView.children.bindTo(t.items).using(t => t);
                    t.focusables.bindTo(t.items).using(t => t);
                    t.extendTemplate({
                        attributes: {
                            class: [e.if("isVertical", "ck-toolbar_vertical")]
                        }
                    })
                }
                render() { }
                destroy() { }
            }
            class xw {
                constructor(t) {
                    this.viewChildren = t.children;
                    this.viewFocusables = t.focusables;
                    this.viewItemsView = t.itemsView;
                    this.viewFocusTracker = t.focusTracker;
                    this.viewLocale = t.locale;
                    this.ungroupedItems = t.createCollection();
                    this.groupedItems = t.createCollection();
                    this.groupedItemsDropdown = this._createGroupedItemsDropdown();
                    this.resizeObserver = null;
                    this.cachedPadding = null;
                    t.itemsView.children.bindTo(this.ungroupedItems).using(t => t);
                    this.ungroupedItems.on("add", this._updateFocusCycleableItems.bind(this));
                    this.ungroupedItems.on("remove", this._updateFocusCycleableItems.bind(this));
                    t.children.on("add", this._updateFocusCycleableItems.bind(this));
                    t.children.on("remove", this._updateFocusCycleableItems.bind(this));
                    t.items.on("add", (t, e, n) => {
                        if (n > this.ungroupedItems.length) {
                            this.groupedItems.add(e, n - this.ungroupedItems.length)
                        } else {
                            this.ungroupedItems.add(e, n)
                        }
                        this._updateGrouping()
                    }
                    );
                    t.items.on("remove", (t, e, n) => {
                        if (n > this.ungroupedItems.length) {
                            this.groupedItems.remove(e)
                        } else {
                            this.ungroupedItems.remove(e)
                        }
                        this._updateGrouping()
                    }
                    );
                    t.extendTemplate({
                        attributes: {
                            class: ["ck-toolbar_grouping"]
                        }
                    })
                }
                render(t) {
                    this.viewElement = t.element;
                    this._enableGroupingOnResize()
                }
                destroy() {
                    this.groupedItemsDropdown.destroy();
                    this.resizeObserver.destroy()
                }
                _updateGrouping() {
                    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
                        return
                    }
                    let t;
                    while (this._areItemsOverflowing) {
                        this._groupLastItem();
                        t = true
                    }
                    if (!t && this.groupedItems.length) {
                        while (this.groupedItems.length && !this._areItemsOverflowing) {
                            this._ungroupFirstItem()
                        }
                        if (this._areItemsOverflowing) {
                            this._groupLastItem()
                        }
                    }
                }
                get _areItemsOverflowing() {
                    if (!this.ungroupedItems.length) {
                        return false
                    }
                    const t = this.viewElement;
                    const e = this.viewLocale.uiLanguageDirection;
                    const n = new yh(t.lastChild);
                    const i = new yh(t);
                    if (!this.cachedPadding) {
                        const n = Nd.window.getComputedStyle(t);
                        const i = e === "ltr" ? "paddingRight" : "paddingLeft";
                        this.cachedPadding = Number.parseInt(n[i])
                    }
                    if (e === "ltr") {
                        return n.right > i.right - this.cachedPadding
                    } else {
                        return n.left < i.left + this.cachedPadding
                    }
                }
                _enableGroupingOnResize() {
                    let t;
                    this.resizeObserver = new Fb(this.viewElement, e => {
                        if (!t || t !== e.contentRect.width) {
                            this._updateGrouping();
                            t = e.contentRect.width
                        }
                    }
                    );
                    this._updateGrouping()
                }
                _groupLastItem() {
                    if (!this.groupedItems.length) {
                        this.viewChildren.add(new Vb);
                        this.viewChildren.add(this.groupedItemsDropdown);
                        this.viewFocusTracker.add(this.groupedItemsDropdown.element)
                    }
                    this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
                }
                _ungroupFirstItem() {
                    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
                    if (!this.groupedItems.length) {
                        this.viewChildren.remove(this.groupedItemsDropdown);
                        this.viewChildren.remove(this.viewChildren.last);
                        this.viewFocusTracker.remove(this.groupedItemsDropdown.element)
                    }
                }
                _createGroupedItemsDropdown() {
                    const t = this.viewLocale;
                    const e = t.t;
                    const n = uw(t);
                    n.class = "ck-toolbar__grouped-dropdown";
                    n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se";
                    hw(n, []);
                    n.buttonView.set({
                        label: e("bh"),
                        tooltip: true,
                        icon: ww
                    });
                    n.toolbarView.items.bindTo(this.groupedItems).using(t => t);
                    return n
                }
                _updateFocusCycleableItems() {
                    this.viewFocusables.clear();
                    this.ungroupedItems.map(t => {
                        this.viewFocusables.add(t)
                    }
                    );
                    if (this.groupedItems.length) {
                        this.viewFocusables.add(this.groupedItemsDropdown)
                    }
                }
            }
            var Cw = n(41);
            class Aw extends Pb {
                constructor(t, e, n = {}) {
                    super(t);
                    this.stickyPanel = new Mb(t);
                    this.toolbar = new _w(t, {
                        shouldGroupWhenFull: n.shouldToolbarGroupWhenFull
                    });
                    this.editable = new Sb(t, e)
                }
                render() {
                    super.render();
                    this.stickyPanel.content.add(this.toolbar);
                    this.top.add(this.stickyPanel);
                    this.main.add(this.editable)
                }
            }
            function Pw(t) {
                if (t instanceof HTMLTextAreaElement) {
                    return t.value
                }
                return t.innerHTML
            }
            class Tw extends fm {
                constructor(t, e) {
                    super(e);
                    if (Ks(t)) {
                        this.sourceElement = t
                    }
                    this.data.processor = new vm;
                    this.model.document.createRoot();
                    const n = !this.config.get("toolbar.shouldNotGroupWhenFull");
                    const i = new Aw(this.locale, this.editing.view, {
                        shouldToolbarGroupWhenFull: n
                    });
                    this.ui = new zm(this, i);
                    km(this)
                }
                destroy() {
                    if (this.sourceElement) {
                        this.updateSourceElement()
                    }
                    this.ui.destroy();
                    return super.destroy()
                }
                static create(t, e = {}) {
                    return new Promise(n => {
                        const i = new this(t, e);
                        n(i.initPlugins().then(() => i.ui.init(Ks(t) ? t : null)).then(() => {
                            if (!Ks(t) && e.initialData) {
                                throw new rr["b"]("editor-create-initial-data: " + "The config.initialData option cannot be used together with initial data passed in Editor.create().", null)
                            }
                            const n = e.initialData || Sw(t);
                            return i.data.init(n)
                        }
                        ).then(() => i.fire("ready")).then(() => i))
                    }
                    )
                }
            }
            vr(Tw, gm);
            vr(Tw, wm);
            function Sw(t) {
                return Ks(t) ? Pw(t) : t
            }
            class Ew {
                static get pluginName() {
                    return "BlockAutoformatEditing"
                }
                constructor(t, e, n) {
                    let i;
                    let o = null;
                    if (typeof n == "function") {
                        i = n
                    } else {
                        o = t.commands.get(n);
                        i = () => {
                            t.execute(n)
                        }
                    }
                    t.model.document.on("change", (n, s) => {
                        if (o && !o.isEnabled) {
                            return
                        }
                        if (s.type == "transparent") {
                            return
                        }
                        const r = Array.from(t.model.document.differ.getChanges());
                        const a = r[0];
                        if (r.length != 1 || a.type !== "insert" || a.name != "$text" || a.length != 1) {
                            return
                        }
                        const c = a.position.parent;
                        if (!c.is("paragraph") || c.childCount !== 1) {
                            return
                        }
                        const l = e.exec(c.getChild(0).data);
                        if (!l) {
                            return
                        }
                        t.model.enqueueChange(t => {
                            const e = t.createPositionAt(c, 0);
                            const n = t.createPositionAt(c, l[0].length);
                            const o = new rf(e, n);
                            const s = i({
                                match: l
                            });
                            if (s !== false) {
                                t.remove(o)
                            }
                            o.detach()
                        }
                        )
                    }
                    )
                }
            }
            function Rw(t, e) {
                let n = t.start;
                const i = Array.from(t.getItems()).reduce((t, i) => {
                    if (!(i.is("text") || i.is("textProxy"))) {
                        n = e.createPositionAfter(i);
                        return ""
                    }
                    return t + i.data
                }
                    , "");
                return {
                    text: i,
                    range: e.createRange(n, t.end)
                }
            }
            class Ow {
                static get pluginName() {
                    return "InlineAutoformatEditing"
                }
                constructor(t, e, n) {
                    let i;
                    let o;
                    let s;
                    let r;
                    if (e instanceof RegExp) {
                        i = e
                    } else {
                        s = e
                    }
                    if (typeof n == "string") {
                        o = n
                    } else {
                        r = n
                    }
                    s = s || (t => {
                        let e;
                        const n = [];
                        const o = [];
                        while ((e = i.exec(t)) !== null) {
                            if (e && e.length < 4) {
                                break
                            }
                            let { index: t, 1: i, 2: s, 3: r } = e;
                            const a = i + s + r;
                            t += e[0].length - a.length;
                            const c = [t, t + i.length];
                            const l = [t + i.length + s.length, t + i.length + s.length + r.length];
                            n.push(c);
                            n.push(l);
                            o.push([t + i.length, t + i.length + s.length])
                        }
                        return {
                            remove: n,
                            format: o
                        }
                    }
                    );
                    r = r || ((e, n) => {
                        const i = t.model.schema.getValidRanges(n, o);
                        for (const t of i) {
                            e.setAttribute(o, true, t)
                        }
                        e.removeSelectionAttribute(o)
                    }
                    );
                    t.model.document.on("change", (e, n) => {
                        if (n.type == "transparent") {
                            return
                        }
                        const i = t.model;
                        const o = i.document.selection;
                        if (!o.isCollapsed) {
                            return
                        }
                        const a = Array.from(i.document.differ.getChanges());
                        const c = a[0];
                        if (a.length != 1 || c.type !== "insert" || c.name != "$text" || c.length != 1) {
                            return
                        }
                        const l = o.focus;
                        const d = l.parent;
                        const { text: u, range: h } = Rw(i.createRange(i.createPositionAt(d, 0), l), i);
                        const f = s(u);
                        const p = Mw(h.start, f.format, i);
                        const g = Mw(h.start, f.remove, i);
                        if (!(p.length && g.length)) {
                            return
                        }
                        i.enqueueChange(t => {
                            const e = r(t, p);
                            if (e === false) {
                                return
                            }
                            for (const e of g.reverse()) {
                                t.remove(e)
                            }
                        }
                        )
                    }
                    )
                }
            }
            function Mw(t, e, n) {
                return e.filter(t => t[0] !== undefined && t[1] !== undefined).map(e => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1])))
            }
            class Nw {
                constructor(t) {
                    this.editor = t;
                    this.set("isEnabled", true);
                    this._disableStack = new Set
                }
                forceDisabled(t) {
                    this._disableStack.add(t);
                    if (this._disableStack.size == 1) {
                        this.on("set:isEnabled", Iw, {
                            priority: "highest"
                        });
                        this.isEnabled = false
                    }
                }
                clearForceDisabled(t) {
                    this._disableStack.delete(t);
                    if (this._disableStack.size == 0) {
                        this.off("set:isEnabled", Iw);
                        this.isEnabled = true
                    }
                }
                destroy() {
                    this.stopListening()
                }
                static get isContextPlugin() {
                    return false
                }
            }
            vr(Nw, Jc);
            function Iw(t) {
                t.return = false;
                t.stop()
            }
            class Vw extends Nw {
                static get pluginName() {
                    return "Autoformat"
                }
                afterInit() {
                    this._addListAutoformats();
                    this._addBasicStylesAutoformats();
                    this._addHeadingAutoformats();
                    this._addBlockQuoteAutoformats();
                    this._addCodeBlockAutoformats()
                }
                _addListAutoformats() {
                    const t = this.editor.commands;
                    if (t.get("bulletedList")) {
                        new Ew(this.editor, /^[*-]\s$/, "bulletedList")
                    }
                    if (t.get("numberedList")) {
                        new Ew(this.editor, /^1[.|)]\s$/, "numberedList")
                    }
                }
                _addBasicStylesAutoformats() {
                    const t = this.editor.commands;
                    if (t.get("bold")) {
                        const t = Bw(this.editor, "bold");
                        new Ow(this.editor, /(\*\*)([^*]+)(\*\*)$/g, t);
                        new Ow(this.editor, /(__)([^_]+)(__)$/g, t)
                    }
                    if (t.get("italic")) {
                        const t = Bw(this.editor, "italic");
                        new Ow(this.editor, /(?:^|[^*])(\*)([^*_]+)(\*)$/g, t);
                        new Ow(this.editor, /(?:^|[^_])(_)([^_]+)(_)$/g, t)
                    }
                    if (t.get("code")) {
                        const t = Bw(this.editor, "code");
                        new Ow(this.editor, /(`)([^`]+)(`)$/g, t)
                    }
                }
                _addHeadingAutoformats() {
                    const t = this.editor.commands.get("heading");
                    if (t) {
                        t.modelElements.filter(t => t.match(/^heading[1-6]$/)).forEach(e => {
                            const n = e[7];
                            const i = new RegExp(`^(#{${n}})\\s$`);
                            new Ew(this.editor, i, () => {
                                if (!t.isEnabled) {
                                    return false
                                }
                                this.editor.execute("heading", {
                                    value: e
                                })
                            }
                            )
                        }
                        )
                    }
                }
                _addBlockQuoteAutoformats() {
                    if (this.editor.commands.get("blockQuote")) {
                        new Ew(this.editor, /^>\s$/, "blockQuote")
                    }
                }
                _addCodeBlockAutoformats() {
                    if (this.editor.commands.get("codeBlock")) {
                        new Ew(this.editor, /^```$/, "codeBlock")
                    }
                }
            }
            function Bw(t, e) {
                return (n, i) => {
                    const o = t.commands.get(e);
                    if (!o.isEnabled) {
                        return false
                    }
                    const s = t.model.schema.getValidRanges(i, e);
                    for (const t of s) {
                        n.setAttribute(e, true, t)
                    }
                    n.removeSelectionAttribute(e)
                }
            }
            class Fw {
                constructor(t) {
                    this.editor = t;
                    this.set("value", undefined);
                    this.set("isEnabled", false);
                    this._disableStack = new Set;
                    this.decorate("execute");
                    this.listenTo(this.editor.model.document, "change", () => {
                        this.refresh()
                    }
                    );
                    this.on("execute", t => {
                        if (!this.isEnabled) {
                            t.stop()
                        }
                    }
                        , {
                            priority: "high"
                        });
                    this.listenTo(t, "change:isReadOnly", (t, e, n) => {
                        if (n) {
                            this.forceDisabled("readOnlyMode")
                        } else {
                            this.clearForceDisabled("readOnlyMode")
                        }
                    }
                    )
                }
                refresh() {
                    this.isEnabled = true
                }
                forceDisabled(t) {
                    this._disableStack.add(t);
                    if (this._disableStack.size == 1) {
                        this.on("set:isEnabled", Dw, {
                            priority: "highest"
                        });
                        this.isEnabled = false
                    }
                }
                clearForceDisabled(t) {
                    this._disableStack.delete(t);
                    if (this._disableStack.size == 0) {
                        this.off("set:isEnabled", Dw);
                        this.refresh()
                    }
                }
                execute() { }
                destroy() {
                    this.stopListening()
                }
            }
            vr(Fw, Jc);
            function Dw(t) {
                t.return = false;
                t.stop()
            }
            function zw(t) {
                const e = t.next();
                if (e.done) {
                    return null
                }
                return e.value
            }
            class Lw extends Fw {
                refresh() {
                    this.value = this._getValue();
                    this.isEnabled = this._checkEnabled()
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.schema;
                    const i = e.document.selection;
                    const o = Array.from(i.getSelectedBlocks());
                    const s = t.forceValue === undefined ? !this.value : t.forceValue;
                    e.change(t => {
                        if (!s) {
                            this._removeQuote(t, o.filter(jw))
                        } else {
                            const e = o.filter(t => jw(t) || qw(n, t));
                            this._applyQuote(t, e)
                        }
                    }
                    )
                }
                _getValue() {
                    const t = this.editor.model.document.selection;
                    const e = zw(t.getSelectedBlocks());
                    return !!(e && jw(e))
                }
                _checkEnabled() {
                    if (this.value) {
                        return true
                    }
                    const t = this.editor.model.document.selection;
                    const e = this.editor.model.schema;
                    const n = zw(t.getSelectedBlocks());
                    if (!n) {
                        return false
                    }
                    return qw(e, n)
                }
                _removeQuote(t, e) {
                    Hw(t, e).reverse().forEach(e => {
                        if (e.start.isAtStart && e.end.isAtEnd) {
                            t.unwrap(e.start.parent);
                            return
                        }
                        if (e.start.isAtStart) {
                            const n = t.createPositionBefore(e.start.parent);
                            t.move(e, n);
                            return
                        }
                        if (!e.end.isAtEnd) {
                            t.split(e.end)
                        }
                        const n = t.createPositionAfter(e.end.parent);
                        t.move(e, n)
                    }
                    )
                }
                _applyQuote(t, e) {
                    const n = [];
                    Hw(t, e).reverse().forEach(e => {
                        let i = jw(e.start);
                        if (!i) {
                            i = t.createElement("blockQuote");
                            t.wrap(e, i)
                        }
                        n.push(i)
                    }
                    );
                    n.reverse().reduce((e, n) => {
                        if (e.nextSibling == n) {
                            t.merge(t.createPositionAfter(e));
                            return e
                        }
                        return n
                    }
                    )
                }
            }
            function jw(t) {
                return t.parent.name == "blockQuote" ? t.parent : null
            }
            function Hw(t, e) {
                let n;
                let i = 0;
                const o = [];
                while (i < e.length) {
                    const s = e[i];
                    const r = e[i + 1];
                    if (!n) {
                        n = t.createPositionBefore(s)
                    }
                    if (!r || s.nextSibling != r) {
                        o.push(t.createRange(n, t.createPositionAfter(s)));
                        n = null
                    }
                    i++
                }
                return o
            }
            function qw(t, e) {
                const n = t.checkChild(e.parent, "blockQuote");
                const i = t.checkChild(["$root", "blockQuote"], e);
                return n && i
            }
            class Ww extends Nw {
                static get pluginName() {
                    return "BlockQuoteEditing"
                }
                init() {
                    const t = this.editor;
                    const e = t.model.schema;
                    t.commands.add("blockQuote", new Lw(t));
                    e.register("blockQuote", {
                        allowWhere: "$block",
                        allowContentOf: "$root"
                    });
                    e.addChildCheck((t, e) => {
                        if (t.endsWith("blockQuote") && e.name == "blockQuote") {
                            return false
                        }
                    }
                    );
                    t.conversion.elementToElement({
                        model: "blockQuote",
                        view: "blockquote"
                    });
                    t.model.document.registerPostFixer(n => {
                        const i = t.model.document.differ.getChanges();
                        for (const t of i) {
                            if (t.type == "insert") {
                                const i = t.position.nodeAfter;
                                if (!i) {
                                    continue
                                }
                                if (i.is("blockQuote") && i.isEmpty) {
                                    n.remove(i);
                                    return true
                                } else if (i.is("blockQuote") && !e.checkChild(t.position, i)) {
                                    n.unwrap(i);
                                    return true
                                } else if (i.is("element")) {
                                    const t = n.createRangeIn(i);
                                    for (const i of t.getItems()) {
                                        if (i.is("blockQuote") && !e.checkChild(n.createPositionBefore(i), i)) {
                                            n.unwrap(i);
                                            return true
                                        }
                                    }
                                }
                            } else if (t.type == "remove") {
                                const e = t.position.parent;
                                if (e.is("blockQuote") && e.isEmpty) {
                                    n.remove(e);
                                    return true
                                }
                            }
                        }
                        return false
                    }
                    )
                }
                afterInit() {
                    const t = this.editor;
                    const e = t.commands.get("blockQuote");
                    this.listenTo(this.editor.editing.view.document, "enter", (t, n) => {
                        const i = this.editor.model.document;
                        const o = i.selection.getLastPosition().parent;
                        if (i.selection.isCollapsed && o.isEmpty && e.value) {
                            this.editor.execute("blockQuote");
                            this.editor.editing.view.scrollToTheSelection();
                            n.preventDefault();
                            t.stop()
                        }
                    }
                    )
                }
            }
            var Uw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 016.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 016.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
            var $w = n(43);
            class Gw extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.t;
                    t.ui.componentFactory.add("blockQuote", n => {
                        const i = t.commands.get("blockQuote");
                        const o = new Zb(n);
                        o.set({
                            label: e("d"),
                            icon: Uw,
                            tooltip: true,
                            isToggleable: true
                        });
                        o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                        this.listenTo(o, "execute", () => {
                            t.execute("blockQuote");
                            t.editing.view.focus()
                        }
                        );
                        return o
                    }
                    )
                }
            }
            class Kw extends Nw {
                static get requires() {
                    return [Ww, Gw]
                }
                static get pluginName() {
                    return "BlockQuote"
                }
            }
            class Jw extends Fw {
                constructor(t, e) {
                    super(t);
                    this.attributeKey = e
                }
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    this.value = this._getValueFromFirstAllowedNode();
                    this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document;
                    const i = n.selection;
                    const o = t.forceValue === undefined ? !this.value : t.forceValue;
                    e.change(t => {
                        if (i.isCollapsed) {
                            if (o) {
                                t.setSelectionAttribute(this.attributeKey, true)
                            } else {
                                t.removeSelectionAttribute(this.attributeKey)
                            }
                        } else {
                            const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
                            for (const e of n) {
                                if (o) {
                                    t.setAttribute(this.attributeKey, o, e)
                                } else {
                                    t.removeAttribute(this.attributeKey, e)
                                }
                            }
                        }
                    }
                    )
                }
                _getValueFromFirstAllowedNode() {
                    const t = this.editor.model;
                    const e = t.schema;
                    const n = t.document.selection;
                    if (n.isCollapsed) {
                        return n.hasAttribute(this.attributeKey)
                    }
                    for (const t of n.getRanges()) {
                        for (const n of t.getItems()) {
                            if (e.checkAttribute(n, this.attributeKey)) {
                                return n.hasAttribute(this.attributeKey)
                            }
                        }
                    }
                    return false
                }
            }
            const Qw = "bold";
            class Yw extends Nw {
                static get pluginName() {
                    return "BoldEditing"
                }
                init() {
                    const t = this.editor;
                    t.model.schema.extend("$text", {
                        allowAttributes: Qw
                    });
                    t.model.schema.setAttributeProperties(Qw, {
                        isFormatting: true,
                        copyOnEnter: true
                    });
                    t.conversion.attributeToElement({
                        model: Qw,
                        view: "strong",
                        upcastAlso: ["b", t => {
                            const e = t.getStyle("font-weight");
                            if (!e) {
                                return null
                            }
                            if (e == "bold" || Number(e) >= 600) {
                                return {
                                    name: true,
                                    styles: ["font-weight"]
                                }
                            }
                        }
                        ]
                    });
                    t.commands.add(Qw, new Jw(t, Qw));
                    t.keystrokes.set("CTRL+B", Qw)
                }
            }
            var Xw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 01.808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 01-2.296 3.504 6.1 6.1 0 01-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 00.91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
            const Zw = "bold";
            class tk extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.t;
                    t.ui.componentFactory.add(Zw, n => {
                        const i = t.commands.get(Zw);
                        const o = new Zb(n);
                        o.set({
                            label: e("ai"),
                            icon: Xw,
                            keystroke: "CTRL+B",
                            tooltip: true,
                            isToggleable: true
                        });
                        o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                        this.listenTo(o, "execute", () => {
                            t.execute(Zw);
                            t.editing.view.focus()
                        }
                        );
                        return o
                    }
                    )
                }
            }
            class ek extends Nw {
                static get requires() {
                    return [Yw, tk]
                }
                static get pluginName() {
                    return "Bold"
                }
            }
            class nk extends Fw {
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = zw(e.selection.getSelectedBlocks());
                    this.value = !!n && n.is("paragraph");
                    this.isEnabled = !!n && ik(n, t.schema)
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document;
                    e.change(i => {
                        const o = (t.selection || n.selection).getSelectedBlocks();
                        for (const t of o) {
                            if (!t.is("paragraph") && ik(t, e.schema)) {
                                i.rename(t, "paragraph")
                            }
                        }
                    }
                    )
                }
            }
            function ik(t, e) {
                return e.checkChild(t.parent, "paragraph") && !e.isObject(t)
            }
            class ok extends Nw {
                static get pluginName() {
                    return "Paragraph"
                }
                init() {
                    const t = this.editor;
                    const e = t.model;
                    const n = t.data;
                    t.commands.add("paragraph", new nk(t));
                    e.schema.register("paragraph", {
                        inheritAllFrom: "$block"
                    });
                    t.conversion.elementToElement({
                        model: "paragraph",
                        view: "p"
                    });
                    t.conversion.for("upcast").elementToElement({
                        model: (t, e) => {
                            if (!ok.paragraphLikeElements.has(t.name)) {
                                return null
                            }
                            if (t.isEmpty) {
                                return null
                            }
                            return e.createElement("paragraph")
                        }
                        ,
                        converterPriority: "low"
                    });
                    n.upcastDispatcher.on("element", (t, e, n) => {
                        if (!n.consumable.test(e.viewItem, {
                            name: e.viewItem.name
                        })) {
                            return
                        }
                        if (rk(e.viewItem, e.modelCursor, n.schema)) {
                            Object.assign(e, sk(e.viewItem, e.modelCursor, n))
                        }
                    }
                        , {
                            priority: "low"
                        });
                    n.upcastDispatcher.on("text", (t, e, n) => {
                        if (e.modelRange) {
                            return
                        }
                        if (rk(e.viewItem, e.modelCursor, n.schema)) {
                            Object.assign(e, sk(e.viewItem, e.modelCursor, n))
                        }
                    }
                        , {
                            priority: "lowest"
                        });
                    e.document.registerPostFixer(t => this._autoparagraphEmptyRoots(t));
                    t.data.on("ready", () => {
                        e.enqueueChange("transparent", t => this._autoparagraphEmptyRoots(t))
                    }
                        , {
                            priority: "lowest"
                        })
                }
                _autoparagraphEmptyRoots(t) {
                    const e = this.editor.model;
                    for (const n of e.document.getRootNames()) {
                        const i = e.document.getRoot(n);
                        if (i.isEmpty && i.rootName != "$graveyard") {
                            if (e.schema.checkChild(i, "paragraph")) {
                                t.insertElement("paragraph", i);
                                return true
                            }
                        }
                    }
                }
            }
            ok.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td"]);
            function sk(t, e, n) {
                const i = n.writer.createElement("paragraph");
                n.writer.insert(i, e);
                return n.convertItem(t, n.writer.createPositionAt(i, 0))
            }
            function rk(t, e, n) {
                const i = n.createContext(e);
                if (!n.checkChild(i, "paragraph")) {
                    return false
                }
                if (!n.checkChild(i.push("paragraph"), t)) {
                    return false
                }
                return true
            }
            class ak extends Fw {
                constructor(t, e) {
                    super(t);
                    this.modelElements = e
                }
                refresh() {
                    const t = zw(this.editor.model.document.selection.getSelectedBlocks());
                    this.value = !!t && this.modelElements.includes(t.name) && t.name;
                    this.isEnabled = !!t && this.modelElements.some(e => ck(t, e, this.editor.model.schema))
                }
                execute(t) {
                    const e = this.editor.model;
                    const n = e.document;
                    const i = t.value;
                    e.change(t => {
                        const o = Array.from(n.selection.getSelectedBlocks()).filter(t => ck(t, i, e.schema));
                        for (const e of o) {
                            if (!e.is(i)) {
                                t.rename(e, i)
                            }
                        }
                    }
                    )
                }
            }
            function ck(t, e, n) {
                return n.checkChild(t.parent, e) && !n.isObject(t)
            }
            const lk = "paragraph";
            class dk extends Nw {
                static get pluginName() {
                    return "HeadingEditing"
                }
                constructor(t) {
                    super(t);
                    t.config.define("heading", {
                        options: [{
                            model: "paragraph",
                            title: "Paragraph",
                            class: "ck-heading_paragraph"
                        }, {
                            model: "heading1",
                            view: "h2",
                            title: "Heading 1",
                            class: "ck-heading_heading1"
                        }, {
                            model: "heading2",
                            view: "h3",
                            title: "Heading 2",
                            class: "ck-heading_heading2"
                        }, {
                            model: "heading3",
                            view: "h4",
                            title: "Heading 3",
                            class: "ck-heading_heading3"
                        }]
                    })
                }
                static get requires() {
                    return [ok]
                }
                init() {
                    const t = this.editor;
                    const e = t.config.get("heading.options");
                    const n = [];
                    for (const i of e) {
                        if (i.model !== lk) {
                            t.model.schema.register(i.model, {
                                inheritAllFrom: "$block"
                            });
                            t.conversion.elementToElement(i);
                            n.push(i.model)
                        }
                    }
                    this._addDefaultH1Conversion(t);
                    t.commands.add("heading", new ak(t, n))
                }
                afterInit() {
                    const t = this.editor;
                    const e = t.commands.get("enter");
                    const n = t.config.get("heading.options");
                    if (e) {
                        this.listenTo(e, "afterExecute", (e, i) => {
                            const o = t.model.document.selection.getFirstPosition().parent;
                            const s = n.some(t => o.is(t.model));
                            if (s && !o.is(lk) && o.childCount === 0) {
                                i.writer.rename(o, lk)
                            }
                        }
                        )
                    }
                }
                _addDefaultH1Conversion(t) {
                    t.conversion.for("upcast").elementToElement({
                        model: "heading1",
                        view: "h1",
                        converterPriority: or.get("low") + 1
                    })
                }
            }
            class uk {
                constructor(t, e) {
                    if (e) {
                        Wc(this, e)
                    }
                    if (t) {
                        this.set(t)
                    }
                }
            }
            vr(uk, Jc);
            function hk(t) {
                const e = t.t;
                const n = {
                    Paragraph: e("aw"),
                    "Heading 1": e("ax"),
                    "Heading 2": e("ay"),
                    "Heading 3": e("az"),
                    "Heading 4": e("ba"),
                    "Heading 5": e("bb"),
                    "Heading 6": e("bc")
                };
                return t.config.get("heading.options").map(t => {
                    const e = n[t.title];
                    if (e && e != t.title) {
                        t.title = e
                    }
                    return t
                }
                )
            }
            var fk = n(11);
            class pk extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.t;
                    const n = hk(t);
                    const i = e("e");
                    const o = e("f");
                    t.ui.componentFactory.add("heading", e => {
                        const s = {};
                        const r = new yr;
                        const a = t.commands.get("heading");
                        const c = t.commands.get("paragraph");
                        const l = [a];
                        for (const t of n) {
                            const e = {
                                type: "button",
                                model: new uk({
                                    label: t.title,
                                    class: t.class,
                                    withText: true
                                })
                            };
                            if (t.model === "paragraph") {
                                e.model.bind("isOn").to(c, "value");
                                e.model.set("commandName", "paragraph");
                                l.push(c)
                            } else {
                                e.model.bind("isOn").to(a, "value", e => e === t.model);
                                e.model.set({
                                    commandName: "heading",
                                    commandValue: t.model
                                })
                            }
                            r.add(e);
                            s[t.model] = t.title
                        }
                        const d = uw(e);
                        fw(d, r);
                        d.buttonView.set({
                            isOn: false,
                            withText: true,
                            tooltip: o
                        });
                        d.extendTemplate({
                            attributes: {
                                class: ["ck-heading-dropdown"]
                            }
                        });
                        d.bind("isEnabled").toMany(l, "isEnabled", (...t) => t.some(t => t));
                        d.buttonView.bind("label").to(a, "value", c, "value", (t, e) => {
                            const n = t || e && "paragraph";
                            return s[n] ? s[n] : i
                        }
                        );
                        this.listenTo(d, "execute", e => {
                            t.execute(e.source.commandName, e.source.commandValue ? {
                                value: e.source.commandValue
                            } : undefined);
                            t.editing.view.focus()
                        }
                        );
                        return d
                    }
                    )
                }
            }
            class gk extends Nw {
                static get requires() {
                    return [dk, pk]
                }
                static get pluginName() {
                    return "Heading"
                }
            }
            class mk extends Kd {
                observe(t) {
                    this.listenTo(t, "load", (t, e) => {
                        const n = e.target;
                        if (n.tagName == "IMG") {
                            this._fireEvents(e)
                        }
                    }
                        , {
                            useCapture: true
                        })
                }
                _fireEvents(t) {
                    if (this.isEnabled) {
                        this.document.fire("layoutChanged");
                        this.document.fire("imageLoaded", t)
                    }
                }
            }
            function bk() {
                return e => {
                    e.on("element:figure", t)
                }
                    ;
                function t(t, e, n) {
                    if (!n.consumable.test(e.viewItem, {
                        name: true,
                        classes: "image"
                    })) {
                        return
                    }
                    const i = Array.from(e.viewItem.getChildren()).find(t => t.is("img"));
                    if (!i || !i.hasAttribute("src") || !n.consumable.test(i, {
                        name: true
                    })) {
                        return
                    }
                    const o = n.convertItem(i, e.modelCursor);
                    const s = zw(o.modelRange.getItems());
                    if (!s) {
                        return
                    }
                    n.convertChildren(e.viewItem, n.writer.createPositionAt(s, 0));
                    e.modelRange = o.modelRange;
                    e.modelCursor = o.modelCursor
                }
            }
            function wk() {
                return e => {
                    e.on("attribute:srcset:image", t)
                }
                    ;
                function t(t, e, n) {
                    if (!n.consumable.consume(e.item, t.name)) {
                        return
                    }
                    const i = n.writer;
                    const o = n.mapper.toViewElement(e.item);
                    const s = o.getChild(0);
                    if (e.attributeNewValue === null) {
                        const t = e.attributeOldValue;
                        if (t.data) {
                            i.removeAttribute("srcset", s);
                            i.removeAttribute("sizes", s);
                            if (t.width) {
                                i.removeAttribute("width", s)
                            }
                        }
                    } else {
                        const t = e.attributeNewValue;
                        if (t.data) {
                            i.setAttribute("srcset", t.data, s);
                            i.setAttribute("sizes", "100vw", s);
                            if (t.width) {
                                i.setAttribute("width", t.width, s)
                            }
                        }
                    }
                }
            }
            function kk(t) {
                return n => {
                    n.on(`attribute:${t}:image`, e)
                }
                    ;
                function e(t, e, n) {
                    if (!n.consumable.consume(e.item, t.name)) {
                        return
                    }
                    const i = n.writer;
                    const o = n.mapper.toViewElement(e.item);
                    const s = o.getChild(0);
                    if (e.attributeNewValue !== null) {
                        i.setAttribute(e.attributeKey, e.attributeNewValue, s)
                    } else {
                        i.removeAttribute(e.attributeKey, s)
                    }
                }
            }
            class _k {
                constructor() {
                    this._stack = []
                }
                add(t, e) {
                    const n = this._stack;
                    const i = n[0];
                    this._insertDescriptor(t);
                    const o = n[0];
                    if (i !== o && !vk(i, o)) {
                        this.fire("change:top", {
                            oldDescriptor: i,
                            newDescriptor: o,
                            writer: e
                        })
                    }
                }
                remove(t, e) {
                    const n = this._stack;
                    const i = n[0];
                    this._removeDescriptor(t);
                    const o = n[0];
                    if (i !== o && !vk(i, o)) {
                        this.fire("change:top", {
                            oldDescriptor: i,
                            newDescriptor: o,
                            writer: e
                        })
                    }
                }
                _insertDescriptor(t) {
                    const e = this._stack;
                    const n = e.findIndex(e => e.id === t.id);
                    if (vk(t, e[n])) {
                        return
                    }
                    if (n > -1) {
                        e.splice(n, 1)
                    }
                    let i = 0;
                    while (e[i] && yk(e[i], t)) {
                        i++
                    }
                    e.splice(i, 0, t)
                }
                _removeDescriptor(t) {
                    const e = this._stack;
                    const n = e.findIndex(e => e.id === t);
                    if (n > -1) {
                        e.splice(n, 1)
                    }
                }
            }
            vr(_k, dr);
            function vk(t, e) {
                return t && e && t.priority == e.priority && xk(t.classes) == xk(e.classes)
            }
            function yk(t, e) {
                if (t.priority > e.priority) {
                    return true
                } else if (t.priority < e.priority) {
                    return false
                }
                return xk(t.classes) > xk(e.classes)
            }
            function xk(t) {
                return Array.isArray(t) ? t.sort().join(",") : t
            }
            var Ck = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 01.5 0H4zm8 0h3.5a.5.5 0 01.5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 01-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 01-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
            const Ak = "ck-widget";
            const Pk = "ck-widget_selected";
            function Tk(t) {
                if (!t.is("element")) {
                    return false
                }
                return !!t.getCustomProperty("widget")
            }
            function Sk(t, e, n = {}) {
                if (!Pl.isEdge) {
                    e.setAttribute("contenteditable", "false", t)
                }
                e.addClass(Ak, t);
                e.setCustomProperty("widget", true, t);
                t.getFillerOffset = Vk;
                if (n.label) {
                    Rk(t, n.label, e)
                }
                if (n.hasSelectionHandle) {
                    Bk(t, e)
                }
                Ek(t, e, (t, e, n) => n.addClass(i(e.classes), t), (t, e, n) => n.removeClass(i(e.classes), t));
                return t;
                function i(t) {
                    return Array.isArray(t) ? t : [t]
                }
            }
            function Ek(t, e, n, i) {
                const o = new _k;
                o.on("change:top", (e, o) => {
                    if (o.oldDescriptor) {
                        i(t, o.oldDescriptor, o.writer)
                    }
                    if (o.newDescriptor) {
                        n(t, o.newDescriptor, o.writer)
                    }
                }
                );
                e.setCustomProperty("addHighlight", (t, e, n) => o.add(e, n), t);
                e.setCustomProperty("removeHighlight", (t, e, n) => o.remove(e, n), t)
            }
            function Rk(t, e, n) {
                n.setCustomProperty("widgetLabel", e, t)
            }
            function Ok(t) {
                const e = t.getCustomProperty("widgetLabel");
                if (!e) {
                    return ""
                }
                return typeof e == "function" ? e() : e
            }
            function Mk(t, e) {
                e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t);
                if (!Pl.isEdge) {
                    e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t);
                    t.on("change:isReadOnly", (n, i, o) => {
                        e.setAttribute("contenteditable", o ? "false" : "true", t)
                    }
                    )
                }
                t.on("change:isFocused", (n, i, o) => {
                    if (o) {
                        e.addClass("ck-editor__nested-editable_focused", t)
                    } else {
                        e.removeClass("ck-editor__nested-editable_focused", t)
                    }
                }
                );
                return t
            }
            function Nk(t, e) {
                const n = t.getSelectedElement();
                if (n && e.schema.isBlock(n)) {
                    return e.createPositionAfter(n)
                }
                const i = t.getSelectedBlocks().next().value;
                if (i) {
                    if (i.isEmpty) {
                        return e.createPositionAt(i, 0)
                    }
                    const n = e.createPositionAfter(i);
                    if (t.focus.isTouching(n)) {
                        return n
                    }
                    return e.createPositionBefore(i)
                }
                return t.focus
            }
            function Ik(t, e) {
                return (n, i) => {
                    const { mapper: o, viewPosition: s } = i;
                    const r = o.findMappedViewAncestor(s);
                    if (!e(r)) {
                        return
                    }
                    const a = o.toModelElement(r);
                    i.modelPosition = t.createPositionAt(a, s.isAtStart ? "before" : "after")
                }
            }
            function Vk() {
                return null
            }
            function Bk(t, e) {
                const n = e.createUIElement("div", {
                    class: "ck ck-widget__selection-handle"
                }, (function (t) {
                    const e = this.toDomElement(t);
                    const n = new Jb;
                    n.set("content", Ck);
                    n.render();
                    e.appendChild(n.element);
                    return e
                }
                ));
                e.insert(e.createPositionAt(t, 0), n);
                e.addClass(["ck-widget_with-selection-handle"], t)
            }
            function Fk(t, e, n) {
                e.setCustomProperty("image", true, t);
                return Sk(t, e, {
                    label: i
                });
                function i() {
                    const e = t.getChild(0);
                    const i = e.getAttribute("alt");
                    return i ? `${i} ${n}` : n
                }
            }
            function Dk(t) {
                return !!t.getCustomProperty("image") && Tk(t)
            }
            function zk(t) {
                const e = t.getSelectedElement();
                if (e && Dk(e)) {
                    return e
                }
                return null
            }
            function Lk(t) {
                return !!t && t.is("image")
            }
            function jk(t, e, n = {}) {
                const i = t.createElement("image", n);
                const o = Nk(e.document.selection, e);
                e.insertContent(i, o);
                if (i.parent) {
                    t.setSelection(i, "on")
                }
            }
            function Hk(t) {
                const e = t.schema;
                const n = t.document.selection;
                return qk(n, e, t) && !Wk(n, e) && Uk(n)
            }
            function qk(t, e, n) {
                const i = $k(t, n);
                return e.checkChild(i, "image")
            }
            function Wk(t, e) {
                const n = t.getSelectedElement();
                return n && e.isObject(n)
            }
            function Uk(t) {
                return [...t.focus.getAncestors()].every(t => !t.is("image"))
            }
            function $k(t, e) {
                const n = Nk(t, e);
                const i = n.parent;
                if (i.isEmpty && !i.is("$root")) {
                    return i.parent
                }
                return i
            }
            class Gk extends Fw {
                refresh() {
                    this.isEnabled = Hk(this.editor.model)
                }
                execute(t) {
                    const e = this.editor.model;
                    e.change(n => {
                        const i = Array.isArray(t.source) ? t.source : [t.source];
                        for (const t of i) {
                            jk(n, e, {
                                src: t
                            })
                        }
                    }
                    )
                }
            }
            class Kk extends Nw {
                static get pluginName() {
                    return "ImageEditing"
                }
                init() {
                    const t = this.editor;
                    const e = t.model.schema;
                    const n = t.t;
                    const i = t.conversion;
                    t.editing.view.addObserver(mk);
                    e.register("image", {
                        isObject: true,
                        isBlock: true,
                        allowWhere: "$block",
                        allowAttributes: ["alt", "src", "srcset"]
                    });
                    i.for("dataDowncast").elementToElement({
                        model: "image",
                        view: (t, e) => Jk(e)
                    });
                    i.for("editingDowncast").elementToElement({
                        model: "image",
                        view: (t, e) => Fk(Jk(e), e, n("ak"))
                    });
                    i.for("downcast").add(kk("src")).add(kk("alt")).add(wk());
                    i.for("upcast").elementToElement({
                        view: {
                            name: "img",
                            attributes: {
                                src: true
                            }
                        },
                        model: (t, e) => e.createElement("image", {
                            src: t.getAttribute("src")
                        })
                    }).attributeToAttribute({
                        view: {
                            name: "img",
                            key: "alt"
                        },
                        model: "alt"
                    }).attributeToAttribute({
                        view: {
                            name: "img",
                            key: "srcset"
                        },
                        model: {
                            key: "srcset",
                            value: t => {
                                const e = {
                                    data: t.getAttribute("srcset")
                                };
                                if (t.hasAttribute("width")) {
                                    e.width = t.getAttribute("width")
                                }
                                return e
                            }
                        }
                    }).add(bk());
                    t.commands.add("imageInsert", new Gk(t))
                }
            }
            function Jk(t) {
                const e = t.createEmptyElement("img");
                const n = t.createContainerElement("figure", {
                    class: "image"
                });
                t.insert(t.createPositionAt(n, 0), e);
                return n
            }
            class Qk extends Qu {
                constructor(t) {
                    super(t);
                    this.domEventType = "mousedown"
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
            }
            var Yk = n(46);
            const Xk = Fl("Ctrl+A");
            class Zk extends Nw {
                static get pluginName() {
                    return "Widget"
                }
                init() {
                    const t = this.editor.editing.view;
                    const e = t.document;
                    this._previouslySelected = new Set;
                    this.editor.editing.downcastDispatcher.on("selection", (t, e, n) => {
                        this._clearPreviouslySelectedWidgets(n.writer);
                        const i = n.writer;
                        const o = i.document.selection;
                        const s = o.getSelectedElement();
                        let r = null;
                        for (const t of o.getRanges()) {
                            for (const e of t) {
                                const t = e.item;
                                if (Tk(t) && !i_(t, r)) {
                                    i.addClass(Pk, t);
                                    this._previouslySelected.add(t);
                                    r = t;
                                    if (t == s) {
                                        i.setSelection(o.getRanges(), {
                                            fake: true,
                                            label: Ok(s)
                                        })
                                    }
                                }
                            }
                        }
                    }
                        , {
                            priority: "low"
                        });
                    t.addObserver(Qk);
                    this.listenTo(e, "mousedown", (...t) => this._onMousedown(...t));
                    this.listenTo(e, "keydown", (...t) => this._onKeydown(...t), {
                        priority: "high"
                    });
                    this.listenTo(e, "delete", (t, e) => {
                        if (this._handleDelete(e.direction == "forward")) {
                            e.preventDefault();
                            t.stop()
                        }
                    }
                        , {
                            priority: "high"
                        })
                }
                _onMousedown(t, e) {
                    const n = this.editor;
                    const i = n.editing.view;
                    const o = i.document;
                    let s = e.target;
                    if (n_(s)) {
                        if (Pl.isSafari && e.domEvent.detail >= 3) {
                            const t = n.editing.mapper;
                            const i = t.toModelElement(s);
                            this.editor.model.change(t => {
                                e.preventDefault();
                                t.setSelection(i, "in")
                            }
                            )
                        }
                        return
                    }
                    if (!Tk(s)) {
                        s = s.findAncestor(Tk);
                        if (!s) {
                            return
                        }
                    }
                    e.preventDefault();
                    if (!o.isFocused) {
                        i.focus()
                    }
                    const r = n.editing.mapper.toModelElement(s);
                    this._setSelectionOverElement(r)
                }
                _onKeydown(t, e) {
                    const n = e.keyCode;
                    const i = this.editor.locale.contentLanguageDirection === "ltr";
                    const o = n == Vl.arrowdown || n == Vl[i ? "arrowright" : "arrowleft"];
                    let s = false;
                    if (t_(n)) {
                        s = this._handleArrowKeys(o)
                    } else if (e_(e)) {
                        s = this._selectAllNestedEditableContent() || this._selectAllContent()
                    } else if (n === Vl.enter) {
                        s = this._handleEnterKey(e.shiftKey)
                    }
                    if (s) {
                        e.preventDefault();
                        t.stop()
                    }
                }
                _handleDelete(t) {
                    if (this.editor.isReadOnly) {
                        return
                    }
                    const e = this.editor.model.document;
                    const n = e.selection;
                    if (!n.isCollapsed) {
                        return
                    }
                    const i = this._getObjectElementNextToSelection(t);
                    if (i) {
                        this.editor.model.change(t => {
                            let e = n.anchor.parent;
                            while (e.isEmpty) {
                                const n = e;
                                e = n.parent;
                                t.remove(n)
                            }
                            this._setSelectionOverElement(i)
                        }
                        );
                        return true
                    }
                }
                _handleArrowKeys(t) {
                    const e = this.editor.model;
                    const n = e.schema;
                    const i = e.document;
                    const o = i.selection;
                    const s = o.getSelectedElement();
                    if (s && n.isObject(s)) {
                        const i = t ? o.getLastPosition() : o.getFirstPosition();
                        const s = n.getNearestSelectionRange(i, t ? "forward" : "backward");
                        if (s) {
                            e.change(t => {
                                t.setSelection(s)
                            }
                            )
                        }
                        return true
                    }
                    if (!o.isCollapsed) {
                        return
                    }
                    const r = this._getObjectElementNextToSelection(t);
                    if (!!r && n.isObject(r)) {
                        this._setSelectionOverElement(r);
                        return true
                    }
                }
                _handleEnterKey(t) {
                    const e = this.editor.model;
                    const n = e.document.selection;
                    const i = n.getSelectedElement();
                    if (o_(i, e.schema)) {
                        e.change(n => {
                            let o = n.createPositionAt(i, t ? "before" : "after");
                            const s = n.createElement("paragraph");
                            if (e.schema.isBlock(i.parent)) {
                                const t = e.schema.findAllowedParent(o, s);
                                o = n.split(o, t).position
                            }
                            n.insert(s, o);
                            n.setSelection(s, "in")
                        }
                        );
                        return true
                    }
                }
                _selectAllNestedEditableContent() {
                    const t = this.editor.model;
                    const e = t.document.selection;
                    const n = t.schema.getLimitElement(e);
                    if (e.getFirstRange().root == n) {
                        return false
                    }
                    t.change(t => {
                        t.setSelection(t.createRangeIn(n))
                    }
                    );
                    return true
                }
                _selectAllContent() {
                    const t = this.editor.model;
                    const e = this.editor.editing;
                    const n = e.view;
                    const i = n.document;
                    const o = i.selection;
                    const s = o.getSelectedElement();
                    if (s && Tk(s)) {
                        const n = e.mapper.toModelElement(s.parent);
                        t.change(t => {
                            t.setSelection(t.createRangeIn(n))
                        }
                        );
                        return true
                    }
                    return false
                }
                _setSelectionOverElement(t) {
                    this.editor.model.change(e => {
                        e.setSelection(e.createRangeOn(t))
                    }
                    )
                }
                _getObjectElementNextToSelection(t) {
                    const e = this.editor.model;
                    const n = e.schema;
                    const i = e.document.selection;
                    const o = e.createSelection(i);
                    e.modifySelection(o, {
                        direction: t ? "forward" : "backward"
                    });
                    const s = t ? o.focus.nodeBefore : o.focus.nodeAfter;
                    if (!!s && n.isObject(s)) {
                        return s
                    }
                    return null
                }
                _clearPreviouslySelectedWidgets(t) {
                    for (const e of this._previouslySelected) {
                        t.removeClass(Pk, e)
                    }
                    this._previouslySelected.clear()
                }
            }
            function t_(t) {
                return t == Vl.arrowright || t == Vl.arrowleft || t == Vl.arrowup || t == Vl.arrowdown
            }
            function e_(t) {
                return Bl(t) == Xk
            }
            function n_(t) {
                while (t) {
                    if (t.is("editableElement") && !t.is("rootElement")) {
                        return true
                    }
                    if (Tk(t)) {
                        return false
                    }
                    t = t.parent
                }
                return false
            }
            function i_(t, e) {
                if (!e) {
                    return false
                }
                return Array.from(t.getAncestors()).includes(e)
            }
            function o_(t, e) {
                return t && e.isObject(t) && !e.isInline(t)
            }
            class s_ extends Fw {
                refresh() {
                    const t = this.editor.model.document.selection.getSelectedElement();
                    this.isEnabled = Lk(t);
                    if (Lk(t) && t.hasAttribute("alt")) {
                        this.value = t.getAttribute("alt")
                    } else {
                        this.value = false
                    }
                }
                execute(t) {
                    const e = this.editor.model;
                    const n = e.document.selection.getSelectedElement();
                    e.change(e => {
                        e.setAttribute("alt", t.newValue, n)
                    }
                    )
                }
            }
            class r_ extends Nw {
                static get pluginName() {
                    return "ImageTextAlternativeEditing"
                }
                init() {
                    this.editor.commands.add("imageTextAlternative", new s_(this.editor))
                }
            }
            var a_ = n(48);
            class c_ extends mb {
                constructor(t, e) {
                    super(t);
                    const n = `ck-input-${nr()}`;
                    const i = `ck-status-${nr()}`;
                    this.set("label");
                    this.set("value");
                    this.set("isReadOnly", false);
                    this.set("errorText", null);
                    this.set("infoText", null);
                    this.labelView = this._createLabelView(n);
                    this.inputView = this._createInputView(e, n, i);
                    this.statusView = this._createStatusView(i);
                    this.bind("_statusText").to(this, "errorText", this, "infoText", (t, e) => t || e);
                    const o = this.bindTemplate;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-input", o.if("isReadOnly", "ck-disabled")]
                        },
                        children: [this.labelView, this.inputView, this.statusView]
                    })
                }
                _createLabelView(t) {
                    const e = new Ab(this.locale);
                    e.for = t;
                    e.bind("text").to(this, "label");
                    return e
                }
                _createInputView(t, e, n) {
                    const i = new t(this.locale, n);
                    i.id = e;
                    i.ariaDescribedById = n;
                    i.bind("value").to(this);
                    i.bind("isReadOnly").to(this);
                    i.bind("hasError").to(this, "errorText", t => !!t);
                    i.on("input", () => {
                        this.errorText = null
                    }
                    );
                    return i
                }
                _createStatusView(t) {
                    const e = new mb(this.locale);
                    const n = this.bindTemplate;
                    e.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-input__status", n.if("errorText", "ck-labeled-input__status_error"), n.if("_statusText", "ck-hidden", t => !t)],
                            id: t,
                            role: n.if("errorText", "alert")
                        },
                        children: [{
                            text: n.to("_statusText")
                        }]
                    });
                    return e
                }
                select() {
                    this.inputView.select()
                }
                focus() {
                    this.inputView.focus()
                }
            }
            var l_ = n(50);
            class d_ extends mb {
                constructor(t) {
                    super(t);
                    this.set("value");
                    this.set("id");
                    this.set("placeholder");
                    this.set("isReadOnly", false);
                    this.set("hasError", false);
                    this.set("ariaDescribedById");
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            type: "text",
                            class: ["ck", "ck-input", "ck-input-text", e.if("hasError", "ck-error")],
                            id: e.to("id"),
                            placeholder: e.to("placeholder"),
                            readonly: e.to("isReadOnly"),
                            "aria-invalid": e.if("hasError", true),
                            "aria-describedby": e.to("ariaDescribedById")
                        },
                        on: {
                            input: e.to("input")
                        }
                    })
                }
                render() {
                    super.render();
                    const t = t => {
                        this.element.value = !t && t !== 0 ? "" : t
                    }
                        ;
                    t(this.value);
                    this.on("change:value", (e, n, i) => {
                        t(i)
                    }
                    )
                }
                select() {
                    this.element.select()
                }
                focus() {
                    this.element.focus()
                }
            }
            function u_({ view: t }) {
                t.listenTo(t.element, "submit", (e, n) => {
                    n.preventDefault();
                    t.fire("submit")
                }
                    , {
                        useCapture: true
                    })
            }
            var h_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 01-.744-.292l-4.596-4.596a1 1 0 111.414-1.414l3.926 3.926 9.937-9.937a1 1 0 011.414 1.415L7.717 16.323a.997.997 0 01-.745.292z"/></svg>';
            var f_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.591 10.177l4.243 4.242a1 1 0 01-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 01-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 015.934 4.52l4.243 4.243 4.242-4.243a1 1 0 111.415 1.414l-4.243 4.243z"/></svg>';
            var p_ = n(52);
            class g_ extends mb {
                constructor(t) {
                    super(t);
                    const e = this.locale.t;
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this.labeledInput = this._createLabeledInputView();
                    this.saveButtonView = this._createButton(e("bt"), h_, "ck-button-save");
                    this.saveButtonView.type = "submit";
                    this.cancelButtonView = this._createButton(e("bu"), f_, "ck-button-cancel", "cancel");
                    this._focusables = new Lm;
                    this._focusCycler = new Nb({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    });
                    this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: ["ck", "ck-text-alternative-form"],
                            tabindex: "-1"
                        },
                        children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                    })
                }
                render() {
                    super.render();
                    this.keystrokes.listenTo(this.element);
                    u_({
                        view: this
                    });
                    [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach(t => {
                        this._focusables.add(t);
                        this.focusTracker.add(t.element)
                    }
                    )
                }
                _createButton(t, e, n, i) {
                    const o = new Zb(this.locale);
                    o.set({
                        label: t,
                        icon: e,
                        tooltip: true
                    });
                    o.extendTemplate({
                        attributes: {
                            class: n
                        }
                    });
                    if (i) {
                        o.delegate("execute").to(this, i)
                    }
                    return o
                }
                _createLabeledInputView() {
                    const t = this.locale.t;
                    const e = new c_(this.locale, d_);
                    e.label = t("bv");
                    e.inputView.placeholder = t("bv");
                    return e
                }
            }
            var m_ = n(54);
            const b_ = Eb("px");
            const w_ = Nd.document.body;
            class k_ extends mb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("top", 0);
                    this.set("left", 0);
                    this.set("position", "arrow_nw");
                    this.set("isVisible", false);
                    this.set("withArrow", true);
                    this.set("class");
                    this.content = this.createCollection();
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-balloon-panel", e.to("position", t => `ck-balloon-panel_${t}`), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")],
                            style: {
                                top: e.to("top", b_),
                                left: e.to("left", b_)
                            }
                        },
                        children: this.content
                    })
                }
                show() {
                    this.isVisible = true
                }
                hide() {
                    this.isVisible = false
                }
                attachTo(t) {
                    this.show();
                    const e = k_.defaultPositions;
                    const n = Object.assign({}, {
                        element: this.element,
                        positions: [e.southArrowNorth, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthWest, e.northArrowSouthEast],
                        limiter: w_,
                        fitInViewport: true
                    }, t);
                    const i = k_._getOptimalPosition(n);
                    const o = parseInt(i.left);
                    const s = parseInt(i.top);
                    const r = i.name;
                    Object.assign(this, {
                        top: s,
                        left: o,
                        position: r
                    })
                }
                pin(t) {
                    this.unpin();
                    this._pinWhenIsVisibleCallback = () => {
                        if (this.isVisible) {
                            this._startPinning(t)
                        } else {
                            this._stopPinning()
                        }
                    }
                        ;
                    this._startPinning(t);
                    this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
                }
                unpin() {
                    if (this._pinWhenIsVisibleCallback) {
                        this._stopPinning();
                        this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
                        this._pinWhenIsVisibleCallback = null;
                        this.hide()
                    }
                }
                _startPinning(t) {
                    this.attachTo(t);
                    const e = __(t.target);
                    const n = t.limiter ? __(t.limiter) : w_;
                    this.listenTo(Nd.document, "scroll", (i, o) => {
                        const s = o.target;
                        const r = e && s.contains(e);
                        const a = n && s.contains(n);
                        if (r || a || !e || !n) {
                            this.attachTo(t)
                        }
                    }
                        , {
                            useCapture: true
                        });
                    this.listenTo(Nd.window, "resize", () => {
                        this.attachTo(t)
                    }
                    )
                }
                _stopPinning() {
                    this.stopListening(Nd.document, "scroll");
                    this.stopListening(Nd.window, "resize")
                }
            }
            function __(t) {
                if (Ks(t)) {
                    return t
                }
                if (kh(t)) {
                    return t.commonAncestorContainer
                }
                if (typeof t == "function") {
                    return __(t())
                }
                return null
            }
            k_.arrowHorizontalOffset = 25;
            k_.arrowVerticalOffset = 10;
            k_._getOptimalPosition = qb;
            k_.defaultPositions = {
                northArrowSouth: (t, e) => ({
                    top: v_(t, e),
                    left: t.left + t.width / 2 - e.width / 2,
                    name: "arrow_s"
                }),
                northArrowSouthEast: (t, e) => ({
                    top: v_(t, e),
                    left: t.left + t.width / 2 - e.width + k_.arrowHorizontalOffset,
                    name: "arrow_se"
                }),
                northArrowSouthWest: (t, e) => ({
                    top: v_(t, e),
                    left: t.left + t.width / 2 - k_.arrowHorizontalOffset,
                    name: "arrow_sw"
                }),
                northWestArrowSouth: (t, e) => ({
                    top: v_(t, e),
                    left: t.left - e.width / 2,
                    name: "arrow_s"
                }),
                northWestArrowSouthWest: (t, e) => ({
                    top: v_(t, e),
                    left: t.left - k_.arrowHorizontalOffset,
                    name: "arrow_sw"
                }),
                northWestArrowSouthEast: (t, e) => ({
                    top: v_(t, e),
                    left: t.left - e.width + k_.arrowHorizontalOffset,
                    name: "arrow_se"
                }),
                northEastArrowSouth: (t, e) => ({
                    top: v_(t, e),
                    left: t.right - e.width / 2,
                    name: "arrow_s"
                }),
                northEastArrowSouthEast: (t, e) => ({
                    top: v_(t, e),
                    left: t.right - e.width + k_.arrowHorizontalOffset,
                    name: "arrow_se"
                }),
                northEastArrowSouthWest: (t, e) => ({
                    top: v_(t, e),
                    left: t.right - k_.arrowHorizontalOffset,
                    name: "arrow_sw"
                }),
                southArrowNorth: (t, e) => ({
                    top: y_(t, e),
                    left: t.left + t.width / 2 - e.width / 2,
                    name: "arrow_n"
                }),
                southArrowNorthEast: (t, e) => ({
                    top: y_(t, e),
                    left: t.left + t.width / 2 - e.width + k_.arrowHorizontalOffset,
                    name: "arrow_ne"
                }),
                southArrowNorthWest: (t, e) => ({
                    top: y_(t, e),
                    left: t.left + t.width / 2 - k_.arrowHorizontalOffset,
                    name: "arrow_nw"
                }),
                southWestArrowNorth: (t, e) => ({
                    top: y_(t, e),
                    left: t.left - e.width / 2,
                    name: "arrow_n"
                }),
                southWestArrowNorthWest: (t, e) => ({
                    top: y_(t, e),
                    left: t.left - k_.arrowHorizontalOffset,
                    name: "arrow_nw"
                }),
                southWestArrowNorthEast: (t, e) => ({
                    top: y_(t, e),
                    left: t.left - e.width + k_.arrowHorizontalOffset,
                    name: "arrow_ne"
                }),
                southEastArrowNorth: (t, e) => ({
                    top: y_(t, e),
                    left: t.right - e.width / 2,
                    name: "arrow_n"
                }),
                southEastArrowNorthEast: (t, e) => ({
                    top: y_(t, e),
                    left: t.right - e.width + k_.arrowHorizontalOffset,
                    name: "arrow_ne"
                }),
                southEastArrowNorthWest: (t, e) => ({
                    top: y_(t, e),
                    left: t.right - k_.arrowHorizontalOffset,
                    name: "arrow_nw"
                })
            };
            function v_(t, e) {
                return t.top - e.height - k_.arrowVerticalOffset
            }
            function y_(t) {
                return t.bottom + k_.arrowVerticalOffset
            }
            var x_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 111.254 1.255L9.16 10l3.557 3.557a.888.888 0 11-1.254 1.255L7.26 10.61a.888.888 0 01.16-1.382l4.043-4.042z"/></svg>';
            var C_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 11-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 111.254-1.255L12.74 9.39a.888.888 0 01-.16 1.382l-4.043 4.042z"/></svg>';
            var A_ = n(56);
            var P_ = n(58);
            const T_ = Eb("px");
            class S_ extends Nw {
                static get pluginName() {
                    return "ContextualBalloon"
                }
                constructor(t) {
                    super(t);
                    this.positionLimiter = () => {
                        const t = this.editor.editing.view;
                        const e = t.document;
                        const n = e.selection.editableElement;
                        if (n) {
                            return t.domConverter.mapViewToDom(n.root)
                        }
                        return null
                    }
                        ;
                    this.set("visibleView", null);
                    this.view = new k_(t.locale);
                    t.ui.view.body.add(this.view);
                    t.ui.focusTracker.add(this.view.element);
                    this._viewToStack = new Map;
                    this._idToStack = new Map;
                    this.set("_numberOfStacks", 0);
                    this.set("_singleViewMode", false);
                    this._rotatorView = this._createRotatorView();
                    this._fakePanelsView = this._createFakePanelsView()
                }
                hasView(t) {
                    return Array.from(this._viewToStack.keys()).includes(t)
                }
                add(t) {
                    if (this.hasView(t.view)) {
                        throw new rr["b"]("contextualballoon-add-view-exist: Cannot add configuration of the same view twice.", [this, t])
                    }
                    const e = t.stackId || "main";
                    if (!this._idToStack.has(e)) {
                        this._idToStack.set(e, new Map([[t.view, t]]));
                        this._viewToStack.set(t.view, this._idToStack.get(e));
                        this._numberOfStacks = this._idToStack.size;
                        if (!this._visibleStack || t.singleViewMode) {
                            this.showStack(e)
                        }
                        return
                    }
                    const n = this._idToStack.get(e);
                    if (t.singleViewMode) {
                        this.showStack(e)
                    }
                    n.set(t.view, t);
                    this._viewToStack.set(t.view, n);
                    if (n === this._visibleStack) {
                        this._showView(t)
                    }
                }
                remove(t) {
                    if (!this.hasView(t)) {
                        throw new rr["b"]("contextualballoon-remove-view-not-exist: Cannot remove the configuration of a non-existent view.", [this, t])
                    }
                    const e = this._viewToStack.get(t);
                    if (this._singleViewMode && this.visibleView === t) {
                        this._singleViewMode = false
                    }
                    if (this.visibleView === t) {
                        if (e.size === 1) {
                            if (this._idToStack.size > 1) {
                                this._showNextStack()
                            } else {
                                this.view.hide();
                                this.visibleView = null;
                                this._rotatorView.hideView()
                            }
                        } else {
                            this._showView(Array.from(e.values())[e.size - 2])
                        }
                    }
                    if (e.size === 1) {
                        this._idToStack.delete(this._getStackId(e));
                        this._numberOfStacks = this._idToStack.size
                    } else {
                        e.delete(t)
                    }
                    this._viewToStack.delete(t)
                }
                updatePosition(t) {
                    if (t) {
                        this._visibleStack.get(this.visibleView).position = t
                    }
                    this.view.pin(this._getBalloonPosition());
                    this._fakePanelsView.updatePosition()
                }
                showStack(t) {
                    this.visibleStack = t;
                    const e = this._idToStack.get(t);
                    if (!e) {
                        throw new rr["b"]("contextualballoon-showstack-stack-not-exist: Cannot show a stack that does not exist.", this)
                    }
                    if (this._visibleStack === e) {
                        return
                    }
                    this._showView(Array.from(e.values()).pop())
                }
                get _visibleStack() {
                    return this._viewToStack.get(this.visibleView)
                }
                _getStackId(t) {
                    const e = Array.from(this._idToStack.entries()).find(e => e[1] === t);
                    return e[0]
                }
                _showNextStack() {
                    const t = Array.from(this._idToStack.values());
                    let e = t.indexOf(this._visibleStack) + 1;
                    if (!t[e]) {
                        e = 0
                    }
                    this.showStack(this._getStackId(t[e]))
                }
                _showPrevStack() {
                    const t = Array.from(this._idToStack.values());
                    let e = t.indexOf(this._visibleStack) - 1;
                    if (!t[e]) {
                        e = t.length - 1
                    }
                    this.showStack(this._getStackId(t[e]))
                }
                _createRotatorView() {
                    const t = new E_(this.editor.locale);
                    const e = this.editor.locale.t;
                    this.view.content.add(t);
                    t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (t, e) => !e && t > 1);
                    t.on("change:isNavigationVisible", () => this.updatePosition(), {
                        priority: "low"
                    });
                    t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t, n) => {
                        if (n < 2) {
                            return ""
                        }
                        const i = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                        return e("bq", [i, n])
                    }
                    );
                    t.buttonNextView.on("execute", () => {
                        if (t.focusTracker.isFocused) {
                            this.editor.editing.view.focus()
                        }
                        this._showNextStack()
                    }
                    );
                    t.buttonPrevView.on("execute", () => {
                        if (t.focusTracker.isFocused) {
                            this.editor.editing.view.focus()
                        }
                        this._showPrevStack()
                    }
                    );
                    return t
                }
                _createFakePanelsView() {
                    const t = new R_(this.editor.locale, this.view);
                    t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, e) => {
                        const n = !e && t >= 2;
                        return n ? Math.min(t - 1, 2) : 0
                    }
                    );
                    t.listenTo(this.view, "change:top", () => t.updatePosition());
                    t.listenTo(this.view, "change:left", () => t.updatePosition());
                    this.editor.ui.view.body.add(t);
                    return t
                }
                _showView({ view: t, balloonClassName: e = "", withArrow: n = true, singleViewMode: i = false }) {
                    this.view.class = e;
                    this.view.withArrow = n;
                    this._rotatorView.showView(t);
                    this.visibleView = t;
                    this.view.pin(this._getBalloonPosition());
                    this._fakePanelsView.updatePosition();
                    if (i) {
                        this._singleViewMode = true
                    }
                }
                _getBalloonPosition() {
                    let t = Array.from(this._visibleStack.values()).pop().position;
                    if (t && !t.limiter) {
                        t = Object.assign({}, t, {
                            limiter: this.positionLimiter
                        })
                    }
                    return t
                }
            }
            class E_ extends mb {
                constructor(t) {
                    super(t);
                    const e = t.t;
                    const n = this.bindTemplate;
                    this.set("isNavigationVisible", true);
                    this.focusTracker = new Cm;
                    this.buttonPrevView = this._createButtonView(e("br"), x_);
                    this.buttonNextView = this._createButtonView(e("bs"), C_);
                    this.content = this.createCollection();
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-balloon-rotator"],
                            "z-index": "-1"
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", t => t ? "" : "ck-hidden")]
                            },
                            children: [this.buttonPrevView, {
                                tag: "span",
                                attributes: {
                                    class: ["ck-balloon-rotator__counter"]
                                },
                                children: [{
                                    text: n.to("counter")
                                }]
                            }, this.buttonNextView]
                        }, {
                            tag: "div",
                            attributes: {
                                class: "ck-balloon-rotator__content"
                            },
                            children: this.content
                        }]
                    })
                }
                render() {
                    super.render();
                    this.focusTracker.add(this.element)
                }
                showView(t) {
                    this.hideView();
                    this.content.add(t)
                }
                hideView() {
                    this.content.clear()
                }
                _createButtonView(t, e) {
                    const n = new Zb(this.locale);
                    n.set({
                        label: t,
                        icon: e,
                        tooltip: true
                    });
                    return n
                }
            }
            class R_ extends mb {
                constructor(t, e) {
                    super(t);
                    const n = this.bindTemplate;
                    this.set("top", 0);
                    this.set("left", 0);
                    this.set("height", 0);
                    this.set("width", 0);
                    this.set("numberOfPanels", 0);
                    this.content = this.createCollection();
                    this._balloonPanelView = e;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck-fake-panel", n.to("numberOfPanels", t => t ? "" : "ck-hidden")],
                            style: {
                                top: n.to("top", T_),
                                left: n.to("left", T_),
                                width: n.to("width", T_),
                                height: n.to("height", T_)
                            }
                        },
                        children: this.content
                    });
                    this.on("change:numberOfPanels", (t, e, n, i) => {
                        if (n > i) {
                            this._addPanels(n - i)
                        } else {
                            this._removePanels(i - n)
                        }
                        this.updatePosition()
                    }
                    )
                }
                _addPanels(t) {
                    while (t--) {
                        const t = new mb;
                        t.setTemplate({
                            tag: "div"
                        });
                        this.content.add(t);
                        this.registerChild(t)
                    }
                }
                _removePanels(t) {
                    while (t--) {
                        const t = this.content.last;
                        this.content.remove(t);
                        this.deregisterChild(t);
                        t.destroy()
                    }
                }
                updatePosition() {
                    if (this.numberOfPanels) {
                        const { top: t, left: e } = this._balloonPanelView;
                        const { width: n, height: i } = new yh(this._balloonPanelView.element);
                        Object.assign(this, {
                            top: t,
                            left: e,
                            width: n,
                            height: i
                        })
                    }
                }
            }
            var O_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22L2.943 4.078a.75.75 0 111.06-1.06l2.592 2.59A11.094 11.094 0 0110 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 01-.09 1.138.488.488 0 01-.15.084.75.75 0 01-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 00-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 01-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 00-.124.2c-.043.077-.08.158-.108.241a.534.534 0 00-.028.133.29.29 0 00.008.072.927.927 0 00.082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 011.108 5.992l.345.344.046-.018a9.313 9.313 0 002-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 00.036-.12.29.29 0 00.008-.072.492.492 0 00-.028-.133.999.999 0 00-.036-.096 2.165 2.165 0 00-.071-.145 2.917 2.917 0 00-.125-.2 3.592 3.592 0 00-.263-.335 5.444 5.444 0 00-.53-.523 7.955 7.955 0 00-1.054-.768 9.766 9.766 0 00-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 00-.254.097.496.496 0 00-.104.679.498.498 0 00.326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 012.017 1.513c.024.061.043.125.069.185a.494.494 0 00.45.287h.008a.496.496 0 00.35-.158.482.482 0 00.13-.335.638.638 0 00-.048-.219 3.379 3.379 0 00-.36-.723 3.438 3.438 0 00-2.791-1.543l-.028-.001h-.013z"/></svg>';
            function M_(t) {
                const e = t.plugins.get("ContextualBalloon");
                if (zk(t.editing.view.document.selection)) {
                    const n = N_(t);
                    e.updatePosition(n)
                }
            }
            function N_(t) {
                const e = t.editing.view;
                const n = k_.defaultPositions;
                return {
                    target: e.domConverter.viewToDom(e.document.selection.getSelectedElement()),
                    positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast]
                }
            }
            class I_ extends Nw {
                static get requires() {
                    return [S_]
                }
                static get pluginName() {
                    return "ImageTextAlternativeUI"
                }
                init() {
                    this._createButton();
                    this._createForm()
                }
                destroy() {
                    super.destroy();
                    this._form.destroy()
                }
                _createButton() {
                    const t = this.editor;
                    const e = t.t;
                    t.ui.componentFactory.add("imageTextAlternative", n => {
                        const i = t.commands.get("imageTextAlternative");
                        const o = new Zb(n);
                        o.set({
                            label: e("bd"),
                            icon: O_,
                            tooltip: true
                        });
                        o.bind("isEnabled").to(i, "isEnabled");
                        this.listenTo(o, "execute", () => {
                            this._showForm()
                        }
                        );
                        return o
                    }
                    )
                }
                _createForm() {
                    const t = this.editor;
                    const e = t.editing.view;
                    const n = e.document;
                    this._balloon = this.editor.plugins.get("ContextualBalloon");
                    this._form = new g_(t.locale);
                    this._form.render();
                    this.listenTo(this._form, "submit", () => {
                        t.execute("imageTextAlternative", {
                            newValue: this._form.labeledInput.inputView.element.value
                        });
                        this._hideForm(true)
                    }
                    );
                    this.listenTo(this._form, "cancel", () => {
                        this._hideForm(true)
                    }
                    );
                    this._form.keystrokes.set("Esc", (t, e) => {
                        this._hideForm(true);
                        e()
                    }
                    );
                    this.listenTo(t.ui, "update", () => {
                        if (!zk(n.selection)) {
                            this._hideForm(true)
                        } else if (this._isVisible) {
                            M_(t)
                        }
                    }
                    );
                    cw({
                        emitter: this._form,
                        activator: () => this._isVisible,
                        contextElements: [this._balloon.view.element],
                        callback: () => this._hideForm()
                    })
                }
                _showForm() {
                    if (this._isVisible) {
                        return
                    }
                    const t = this.editor;
                    const e = t.commands.get("imageTextAlternative");
                    const n = this._form.labeledInput;
                    if (!this._isInBalloon) {
                        this._balloon.add({
                            view: this._form,
                            position: N_(t)
                        })
                    }
                    n.value = n.inputView.element.value = e.value || "";
                    this._form.labeledInput.select()
                }
                _hideForm(t) {
                    if (!this._isInBalloon) {
                        return
                    }
                    if (this._form.focusTracker.isFocused) {
                        this._form.saveButtonView.focus()
                    }
                    this._balloon.remove(this._form);
                    if (t) {
                        this.editor.editing.view.focus()
                    }
                }
                get _isVisible() {
                    return this._balloon.visibleView === this._form
                }
                get _isInBalloon() {
                    return this._balloon.hasView(this._form)
                }
            }
            class V_ extends Nw {
                static get requires() {
                    return [r_, I_]
                }
                static get pluginName() {
                    return "ImageTextAlternative"
                }
            }
            var B_ = n(60);
            class F_ extends Nw {
                static get requires() {
                    return [Kk, Zk, V_]
                }
                static get pluginName() {
                    return "Image"
                }
            }
            class D_ extends mb {
                constructor(t) {
                    super(t);
                    this.buttonView = new Zb(t);
                    this._fileInputView = new z_(t);
                    this._fileInputView.bind("acceptedType").to(this);
                    this._fileInputView.bind("allowMultipleFiles").to(this);
                    this._fileInputView.delegate("done").to(this);
                    this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: "ck-file-dialog-button"
                        },
                        children: [this.buttonView, this._fileInputView]
                    });
                    this.buttonView.on("execute", () => {
                        this._fileInputView.open()
                    }
                    )
                }
                focus() {
                    this.buttonView.focus()
                }
            }
            class z_ extends mb {
                constructor(t) {
                    super(t);
                    this.set("acceptedType");
                    this.set("allowMultipleFiles", false);
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            class: ["ck-hidden"],
                            type: "file",
                            tabindex: "-1",
                            accept: e.to("acceptedType"),
                            multiple: e.to("allowMultipleFiles")
                        },
                        on: {
                            change: e.to(() => {
                                if (this.element && this.element.files && this.element.files.length) {
                                    this.fire("done", this.element.files)
                                }
                                this.element.value = ""
                            }
                            )
                        }
                    })
                }
                open() {
                    this.element.click()
                }
            }
            var L_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 01.87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 113.4-1.96 1.96 1.96 0 01-3.4 1.96z"/></svg>';
            function j_(t) {
                const e = t.map(t => t.replace("+", "\\+"));
                return new RegExp(`^image\\/(${e.join("|")})$`)
            }
            function H_(t) {
                return new Promise((e, n) => {
                    const i = t.getAttribute("src");
                    fetch(i).then(t => t.blob()).then(t => {
                        const o = W_(t, i);
                        const s = o.replace("image/", "");
                        const r = `image.${s}`;
                        const a = U_(t, r, o);
                        a ? e(a) : n()
                    }
                    ).catch(n)
                }
                )
            }
            function q_(t) {
                if (!t.is("element", "img") || !t.getAttribute("src")) {
                    return false
                }
                return t.getAttribute("src").match(/^data:image\/\w+;base64,/g) || t.getAttribute("src").match(/^blob:/g)
            }
            function W_(t, e) {
                if (t.type) {
                    return t.type
                } else if (e.match(/data:(image\/\w+);base64/)) {
                    return e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
                } else {
                    return "image/jpeg"
                }
            }
            function U_(t, e, n) {
                try {
                    return new File([t], e, {
                        type: n
                    })
                } catch (t) {
                    return null
                }
            }
            class $_ extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.t;
                    t.ui.componentFactory.add("imageUpload", n => {
                        const i = new D_(n);
                        const o = t.commands.get("imageUpload");
                        const s = t.config.get("image.upload.types");
                        const r = j_(s);
                        i.set({
                            acceptedType: s.map(t => `image/${t}`).join(","),
                            allowMultipleFiles: true
                        });
                        i.buttonView.set({
                            label: e("al"),
                            icon: L_,
                            tooltip: true
                        });
                        i.buttonView.bind("isEnabled").to(o);
                        i.on("done", (e, n) => {
                            const i = Array.from(n).filter(t => r.test(t.type));
                            if (i.length) {
                                t.execute("imageUpload", {
                                    file: i
                                })
                            }
                        }
                        );
                        return i
                    }
                    )
                }
            }
            class G_ {
                constructor(t) {
                    this.context = t
                }
                destroy() {
                    this.stopListening()
                }
                static get isContextPlugin() {
                    return true
                }
            }
            vr(G_, Jc);
            class K_ extends G_ {
                static get pluginName() {
                    return "PendingActions"
                }
                init() {
                    this.set("hasAny", false);
                    this._actions = new yr({
                        idProperty: "_id"
                    });
                    this._actions.delegate("add", "remove").to(this)
                }
                add(t) {
                    if (typeof t !== "string") {
                        throw new rr["b"]("pendingactions-add-invalid-message: The message must be a string.", this)
                    }
                    const e = Object.create(Jc);
                    e.set("message", t);
                    this._actions.add(e);
                    this.hasAny = true;
                    return e
                }
                remove(t) {
                    this._actions.remove(t);
                    this.hasAny = !!this._actions.length
                }
                get first() {
                    return this._actions.get(0)
                }
                [Symbol.iterator]() {
                    return this._actions[Symbol.iterator]()
                }
            }
            class J_ {
                constructor() {
                    const t = new window.FileReader;
                    this._reader = t;
                    this._data = undefined;
                    this.set("loaded", 0);
                    t.onprogress = t => {
                        this.loaded = t.loaded
                    }
                }
                get error() {
                    return this._reader.error
                }
                get data() {
                    return this._data
                }
                read(t) {
                    const e = this._reader;
                    this.total = t.size;
                    return new Promise((n, i) => {
                        e.onload = () => {
                            const t = e.result;
                            this._data = t;
                            n(t)
                        }
                            ;
                        e.onerror = () => {
                            i("error")
                        }
                            ;
                        e.onabort = () => {
                            i("aborted")
                        }
                            ;
                        this._reader.readAsDataURL(t)
                    }
                    )
                }
                abort() {
                    this._reader.abort()
                }
            }
            vr(J_, Jc);
            class Q_ extends Nw {
                static get pluginName() {
                    return "FileRepository"
                }
                static get requires() {
                    return [K_]
                }
                init() {
                    this.loaders = new yr;
                    this.loaders.on("add", () => this._updatePendingAction());
                    this.loaders.on("remove", () => this._updatePendingAction());
                    this._loadersMap = new Map;
                    this._pendingAction = null;
                    this.set("uploaded", 0);
                    this.set("uploadTotal", null);
                    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t, e) => e ? t / e * 100 : 0)
                }
                getLoader(t) {
                    return this._loadersMap.get(t) || null
                }
                createLoader(t) {
                    if (!this.createUploadAdapter) {
                        console.warn(Object(rr["a"])("filerepository-no-upload-adapter: Upload adapter is not defined."));
                        return null
                    }
                    const e = new Y_(Promise.resolve(t), this.createUploadAdapter);
                    this.loaders.add(e);
                    this._loadersMap.set(t, e);
                    if (t instanceof Promise) {
                        e.file.then(t => {
                            this._loadersMap.set(t, e)
                        }
                        ).catch(() => { }
                        )
                    }
                    e.on("change:uploaded", () => {
                        let t = 0;
                        for (const e of this.loaders) {
                            t += e.uploaded
                        }
                        this.uploaded = t
                    }
                    );
                    e.on("change:uploadTotal", () => {
                        let t = 0;
                        for (const e of this.loaders) {
                            if (e.uploadTotal) {
                                t += e.uploadTotal
                            }
                        }
                        this.uploadTotal = t
                    }
                    );
                    return e
                }
                destroyLoader(t) {
                    const e = t instanceof Y_ ? t : this.getLoader(t);
                    e._destroy();
                    this.loaders.remove(e);
                    this._loadersMap.forEach((t, n) => {
                        if (t === e) {
                            this._loadersMap.delete(n)
                        }
                    }
                    )
                }
                _updatePendingAction() {
                    const t = this.editor.plugins.get(K_);
                    if (this.loaders.length) {
                        if (!this._pendingAction) {
                            const e = this.editor.t;
                            const n = t => `${e("an")} ${parseInt(t)}%.`;
                            this._pendingAction = t.add(n(this.uploadedPercent));
                            this._pendingAction.bind("message").to(this, "uploadedPercent", n)
                        }
                    } else {
                        t.remove(this._pendingAction);
                        this._pendingAction = null
                    }
                }
            }
            vr(Q_, Jc);
            class Y_ {
                constructor(t, e) {
                    this.id = nr();
                    this._filePromiseWrapper = this._createFilePromiseWrapper(t);
                    this._adapter = e(this);
                    this._reader = new J_;
                    this.set("status", "idle");
                    this.set("uploaded", 0);
                    this.set("uploadTotal", null);
                    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t, e) => e ? t / e * 100 : 0);
                    this.set("uploadResponse", null)
                }
                get file() {
                    if (!this._filePromiseWrapper) {
                        return Promise.resolve(null)
                    } else {
                        return this._filePromiseWrapper.promise.then(t => this._filePromiseWrapper ? t : null)
                    }
                }
                get data() {
                    return this._reader.data
                }
                read() {
                    if (this.status != "idle") {
                        throw new rr["b"]("filerepository-read-wrong-status: You cannot call read if the status is different than idle.", this)
                    }
                    this.status = "reading";
                    return this.file.then(t => this._reader.read(t)).then(t => {
                        this.status = "idle";
                        return t
                    }
                    ).catch(t => {
                        if (t === "aborted") {
                            this.status = "aborted";
                            throw "aborted"
                        }
                        this.status = "error";
                        throw this._reader.error ? this._reader.error : t
                    }
                    )
                }
                upload() {
                    if (this.status != "idle") {
                        throw new rr["b"]("filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.", this)
                    }
                    this.status = "uploading";
                    return this.file.then(() => this._adapter.upload()).then(t => {
                        this.uploadResponse = t;
                        this.status = "idle";
                        return t
                    }
                    ).catch(t => {
                        if (this.status === "aborted") {
                            throw "aborted"
                        }
                        this.status = "error";
                        throw t
                    }
                    )
                }
                abort() {
                    const t = this.status;
                    this.status = "aborted";
                    if (!this._filePromiseWrapper.isFulfilled) {
                        this._filePromiseWrapper.promise.catch(() => { }
                        );
                        this._filePromiseWrapper.rejecter("aborted")
                    } else if (t == "reading") {
                        this._reader.abort()
                    } else if (t == "uploading" && this._adapter.abort) {
                        this._adapter.abort()
                    }
                    this._destroy()
                }
                _destroy() {
                    this._filePromiseWrapper = undefined;
                    this._reader = undefined;
                    this._adapter = undefined;
                    this.uploadResponse = undefined
                }
                _createFilePromiseWrapper(t) {
                    const e = {};
                    e.promise = new Promise((n, i) => {
                        e.rejecter = i;
                        e.isFulfilled = false;
                        t.then(t => {
                            e.isFulfilled = true;
                            n(t)
                        }
                        ).catch(t => {
                            e.isFulfilled = true;
                            i(t)
                        }
                        )
                    }
                    );
                    return e
                }
            }
            vr(Y_, Jc);
            var X_ = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>';
            var Z_ = n(62);
            var tv = n(64);
            var ev = n(66);
            class nv extends Nw {
                constructor(t) {
                    super(t);
                    this.placeholder = "data:image/svg+xml;utf8," + encodeURIComponent(X_)
                }
                init() {
                    const t = this.editor;
                    t.editing.downcastDispatcher.on("attribute:uploadStatus:image", (...t) => this.uploadStatusChange(...t))
                }
                uploadStatusChange(t, e, n) {
                    const i = this.editor;
                    const o = e.item;
                    const s = o.getAttribute("uploadId");
                    if (!n.consumable.consume(e.item, t.name)) {
                        return
                    }
                    const r = i.plugins.get(Q_);
                    const a = s ? e.attributeNewValue : null;
                    const c = this.placeholder;
                    const l = i.editing.mapper.toViewElement(o);
                    const d = n.writer;
                    if (a == "reading") {
                        iv(l, d);
                        sv(c, l, d);
                        return
                    }
                    if (a == "uploading") {
                        const t = r.loaders.get(s);
                        iv(l, d);
                        if (!t) {
                            sv(c, l, d)
                        } else {
                            rv(l, d);
                            av(l, d, t, i.editing.view);
                            pv(l, d, t)
                        }
                        return
                    }
                    if (a == "complete" && r.loaders.get(s) && !Pl.isEdge) {
                        lv(l, d, i.editing.view)
                    }
                    cv(l, d);
                    rv(l, d);
                    ov(l, d)
                }
            }
            function iv(t, e) {
                if (!t.hasClass("ck-appear")) {
                    e.addClass("ck-appear", t)
                }
            }
            function ov(t, e) {
                e.removeClass("ck-appear", t)
            }
            function sv(t, e, n) {
                if (!e.hasClass("ck-image-upload-placeholder")) {
                    n.addClass("ck-image-upload-placeholder", e)
                }
                const i = e.getChild(0);
                if (i.getAttribute("src") !== t) {
                    n.setAttribute("src", t, i)
                }
                if (!hv(e, "placeholder")) {
                    n.insert(n.createPositionAfter(i), uv(n))
                }
            }
            function rv(t, e) {
                if (t.hasClass("ck-image-upload-placeholder")) {
                    e.removeClass("ck-image-upload-placeholder", t)
                }
                fv(t, e, "placeholder")
            }
            function av(t, e, n, i) {
                const o = dv(e);
                e.insert(e.createPositionAt(t, "end"), o);
                n.on("change:uploadedPercent", (t, e, n) => {
                    i.change(t => {
                        t.setStyle("width", n + "%", o)
                    }
                    )
                }
                )
            }
            function cv(t, e) {
                fv(t, e, "progressBar")
            }
            function lv(t, e, n) {
                const i = e.createUIElement("div", {
                    class: "ck-image-upload-complete-icon"
                });
                e.insert(e.createPositionAt(t, "end"), i);
                setTimeout(() => {
                    n.change(t => t.remove(t.createRangeOn(i)))
                }
                    , 3e3)
            }
            function dv(t) {
                const e = t.createUIElement("div", {
                    class: "ck-progress-bar"
                });
                t.setCustomProperty("progressBar", true, e);
                return e
            }
            function uv(t) {
                const e = t.createUIElement("div", {
                    class: "ck-upload-placeholder-loader"
                });
                t.setCustomProperty("placeholder", true, e);
                return e
            }
            function hv(t, e) {
                for (const n of t.getChildren()) {
                    if (n.getCustomProperty(e)) {
                        return n
                    }
                }
            }
            function fv(t, e, n) {
                const i = hv(t, n);
                if (i) {
                    e.remove(e.createRangeOn(i))
                }
            }
            function pv(t, e, n) {
                if (n.data) {
                    const i = t.getChild(0);
                    e.setAttribute("src", n.data, i)
                }
            }
            class gv extends G_ {
                static get pluginName() {
                    return "Notification"
                }
                init() {
                    this.on("show:warning", (t, e) => {
                        window.alert(e.message)
                    }
                        , {
                            priority: "lowest"
                        })
                }
                showSuccess(t, e = {}) {
                    this._showNotification({
                        message: t,
                        type: "success",
                        namespace: e.namespace,
                        title: e.title
                    })
                }
                showInfo(t, e = {}) {
                    this._showNotification({
                        message: t,
                        type: "info",
                        namespace: e.namespace,
                        title: e.title
                    })
                }
                showWarning(t, e = {}) {
                    this._showNotification({
                        message: t,
                        type: "warning",
                        namespace: e.namespace,
                        title: e.title
                    })
                }
                _showNotification(t) {
                    const e = `show:${t.type}` + (t.namespace ? `:${t.namespace}` : "");
                    this.fire(e, {
                        message: t.message,
                        type: t.type,
                        title: t.title || ""
                    })
                }
            }
            class mv {
                constructor(t) {
                    this.files = bv(t);
                    this._native = t
                }
                get types() {
                    return this._native.types
                }
                getData(t) {
                    return this._native.getData(t)
                }
                setData(t, e) {
                    this._native.setData(t, e)
                }
            }
            function bv(t) {
                const e = t.files ? Array.from(t.files) : [];
                const n = t.items ? Array.from(t.items) : [];
                if (e.length) {
                    return e
                }
                return n.filter(t => t.kind === "file").map(t => t.getAsFile())
            }
            class wv extends Qu {
                constructor(t) {
                    super(t);
                    const e = this.document;
                    this.domEventType = ["paste", "copy", "cut", "drop", "dragover"];
                    this.listenTo(e, "paste", n, {
                        priority: "low"
                    });
                    this.listenTo(e, "drop", n, {
                        priority: "low"
                    });
                    function n(t, n) {
                        n.preventDefault();
                        const i = n.dropRange ? [n.dropRange] : Array.from(e.selection.getRanges());
                        const o = new tr(e, "clipboardInput");
                        e.fire(o, {
                            dataTransfer: n.dataTransfer,
                            targetRanges: i
                        });
                        if (o.stop.called) {
                            n.stopPropagation()
                        }
                    }
                }
                onDomEvent(t) {
                    const e = {
                        dataTransfer: new mv(t.clipboardData ? t.clipboardData : t.dataTransfer)
                    };
                    if (t.type == "drop") {
                        e.dropRange = kv(this.view, t)
                    }
                    this.fire(t.type, t, e)
                }
            }
            function kv(t, e) {
                const n = e.target.ownerDocument;
                const i = e.clientX;
                const o = e.clientY;
                let s;
                if (n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)) {
                    s = n.caretRangeFromPoint(i, o)
                } else if (e.rangeParent) {
                    s = n.createRange();
                    s.setStart(e.rangeParent, e.rangeOffset);
                    s.collapse(true)
                }
                if (s) {
                    return t.domConverter.domRangeToView(s)
                } else {
                    return t.document.selection.getFirstRange()
                }
            }
            function _v(t) {
                t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "</p><p>").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
                if (t.indexOf("</p><p>") > -1) {
                    t = `<p>${t}</p>`
                }
                return t
            }
            function vv(t) {
                return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) => {
                    if (e.length == 1) {
                        return " "
                    }
                    return e
                }
                )
            }
            const yv = ["figcaption", "li"];
            function xv(t) {
                let e = "";
                if (t.is("text") || t.is("textProxy")) {
                    e = t.data
                } else if (t.is("img") && t.hasAttribute("alt")) {
                    e = t.getAttribute("alt")
                } else {
                    let n = null;
                    for (const i of t.getChildren()) {
                        const t = xv(i);
                        if (n && (n.is("containerElement") || i.is("containerElement"))) {
                            if (yv.includes(n.name) || yv.includes(i.name)) {
                                e += "\n"
                            } else {
                                e += "\n\n"
                            }
                        }
                        e += t;
                        n = i
                    }
                }
                return e
            }
            class Cv extends Nw {
                static get pluginName() {
                    return "Clipboard"
                }
                init() {
                    const t = this.editor;
                    const e = t.model.document;
                    const n = t.editing.view;
                    const i = n.document;
                    this._htmlDataProcessor = new vm;
                    n.addObserver(wv);
                    this.listenTo(i, "clipboardInput", e => {
                        if (t.isReadOnly) {
                            e.stop()
                        }
                    }
                        , {
                            priority: "highest"
                        });
                    this.listenTo(i, "clipboardInput", (t, e) => {
                        const i = e.dataTransfer;
                        let o = "";
                        if (i.getData("text/html")) {
                            o = vv(i.getData("text/html"))
                        } else if (i.getData("text/plain")) {
                            o = _v(i.getData("text/plain"))
                        }
                        o = this._htmlDataProcessor.toView(o);
                        this.fire("inputTransformation", {
                            content: o,
                            dataTransfer: i
                        });
                        n.scrollToTheSelection()
                    }
                        , {
                            priority: "low"
                        });
                    this.listenTo(this, "inputTransformation", (t, e) => {
                        if (!e.content.isEmpty) {
                            const t = this.editor.data;
                            const n = this.editor.model;
                            const i = t.toModel(e.content, "$clipboardHolder");
                            if (i.childCount == 0) {
                                return
                            }
                            n.insertContent(i)
                        }
                    }
                        , {
                            priority: "low"
                        });
                    function o(n, o) {
                        const s = o.dataTransfer;
                        o.preventDefault();
                        const r = t.data.toView(t.model.getSelectedContent(e.selection));
                        i.fire("clipboardOutput", {
                            dataTransfer: s,
                            content: r,
                            method: n.name
                        })
                    }
                    this.listenTo(i, "copy", o, {
                        priority: "low"
                    });
                    this.listenTo(i, "cut", (e, n) => {
                        if (t.isReadOnly) {
                            n.preventDefault()
                        } else {
                            o(e, n)
                        }
                    }
                        , {
                            priority: "low"
                        });
                    this.listenTo(i, "clipboardOutput", (n, i) => {
                        if (!i.content.isEmpty) {
                            i.dataTransfer.setData("text/html", this._htmlDataProcessor.toData(i.content));
                            i.dataTransfer.setData("text/plain", xv(i.content))
                        }
                        if (i.method == "cut") {
                            t.model.deleteContent(e.selection)
                        }
                    }
                        , {
                            priority: "low"
                        })
                }
            }
            class Av {
                createDocumentFragment(t) {
                    return new Ul(t)
                }
                createElement(t, e, n) {
                    return new Fc(t, e, n)
                }
                createText(t) {
                    return new Dr(t)
                }
                clone(t, e = false) {
                    return t._clone(e)
                }
                appendChild(t, e) {
                    return e._appendChild(t)
                }
                insertChild(t, e, n) {
                    return n._insertChild(t, e)
                }
                removeChildren(t, e, n) {
                    return n._removeChildren(t, e)
                }
                remove(t) {
                    const e = t.parent;
                    if (e) {
                        return this.removeChildren(e.getChildIndex(t), 1, e)
                    }
                    return []
                }
                replace(t, e) {
                    const n = t.parent;
                    if (n) {
                        const i = n.getChildIndex(t);
                        this.removeChildren(i, 1, n);
                        this.insertChild(i, e, n);
                        return true
                    }
                    return false
                }
                unwrapElement(t) {
                    const e = t.parent;
                    if (e) {
                        const n = e.getChildIndex(t);
                        this.remove(t);
                        this.insertChild(n, t.getChildren(), e)
                    }
                }
                rename(t, e) {
                    const n = new Fc(t, e.getAttributes(), e.getChildren());
                    return this.replace(e, n) ? n : null
                }
                setAttribute(t, e, n) {
                    n._setAttribute(t, e)
                }
                removeAttribute(t, e) {
                    e._removeAttribute(t)
                }
                addClass(t, e) {
                    e._addClass(t)
                }
                removeClass(t, e) {
                    e._removeClass(t)
                }
                setStyle(t, e, n) {
                    if (I(t) && n === undefined) {
                        n = e
                    }
                    n._setStyle(t, e)
                }
                removeStyle(t, e) {
                    e._removeStyle(t)
                }
                setCustomProperty(t, e, n) {
                    n._setCustomProperty(t, e)
                }
                removeCustomProperty(t, e) {
                    return e._removeCustomProperty(t)
                }
                createPositionAt(t, e) {
                    return ul._createAt(t, e)
                }
                createPositionAfter(t) {
                    return ul._createAfter(t)
                }
                createPositionBefore(t) {
                    return ul._createBefore(t)
                }
                createRange(t, e) {
                    return new hl(t, e)
                }
                createRangeOn(t) {
                    return hl._createOn(t)
                }
                createRangeIn(t) {
                    return hl._createIn(t)
                }
                createSelection(t, e, n) {
                    return new gl(t, e, n)
                }
            }
            class Pv extends Fw {
                refresh() {
                    this.isEnabled = Hk(this.editor.model)
                }
                execute(t) {
                    const e = this.editor;
                    const n = e.model;
                    const i = e.plugins.get(Q_);
                    n.change(e => {
                        const o = Array.isArray(t.file) ? t.file : [t.file];
                        for (const t of o) {
                            Tv(e, n, i, t)
                        }
                    }
                    )
                }
            }
            function Tv(t, e, n, i) {
                const o = n.createLoader(i);
                if (!o) {
                    return
                }
                jk(t, e, {
                    uploadId: o.id
                })
            }
            class Sv extends Nw {
                static get requires() {
                    return [Q_, gv, Cv]
                }
                static get pluginName() {
                    return "ImageUploadEditing"
                }
                constructor(t) {
                    super(t);
                    t.config.define("image", {
                        upload: {
                            types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
                        }
                    })
                }
                init() {
                    const t = this.editor;
                    const e = t.model.document;
                    const n = t.model.schema;
                    const i = t.conversion;
                    const o = t.plugins.get(Q_);
                    const s = j_(t.config.get("image.upload.types"));
                    n.extend("image", {
                        allowAttributes: ["uploadId", "uploadStatus"]
                    });
                    t.commands.add("imageUpload", new Pv(t));
                    i.for("upcast").attributeToAttribute({
                        view: {
                            name: "img",
                            key: "uploadId"
                        },
                        model: "uploadId"
                    });
                    this.listenTo(t.editing.view.document, "clipboardInput", (e, n) => {
                        if (Ev(n.dataTransfer)) {
                            return
                        }
                        const i = Array.from(n.dataTransfer.files).filter(t => {
                            if (!t) {
                                return false
                            }
                            return s.test(t.type)
                        }
                        );
                        const o = n.targetRanges.map(e => t.editing.mapper.toModelRange(e));
                        t.model.change(n => {
                            n.setSelection(o);
                            if (i.length) {
                                e.stop();
                                t.model.enqueueChange("default", () => {
                                    t.execute("imageUpload", {
                                        file: i
                                    })
                                }
                                )
                            }
                        }
                        )
                    }
                    );
                    this.listenTo(t.plugins.get(Cv), "inputTransformation", (e, n) => {
                        const i = Array.from(t.editing.view.createRangeIn(n.content)).filter(t => q_(t.item) && !t.item.getAttribute("uploadProcessed")).map(t => ({
                            promise: H_(t.item),
                            imageElement: t.item
                        }));
                        if (!i.length) {
                            return
                        }
                        const s = new Av;
                        for (const t of i) {
                            s.setAttribute("uploadProcessed", true, t.imageElement);
                            const e = o.createLoader(t.promise);
                            if (e) {
                                s.setAttribute("src", "", t.imageElement);
                                s.setAttribute("uploadId", e.id, t.imageElement)
                            }
                        }
                    }
                    );
                    t.editing.view.document.on("dragover", (t, e) => {
                        e.preventDefault()
                    }
                    );
                    e.on("change", () => {
                        const n = e.differ.getChanges({
                            includeChangesInGraveyard: true
                        });
                        for (const e of n) {
                            if (e.type == "insert" && e.name != "$text") {
                                const n = e.position.nodeAfter;
                                const i = e.position.root.rootName == "$graveyard";
                                for (const e of Rv(t, n)) {
                                    const t = e.getAttribute("uploadId");
                                    if (!t) {
                                        continue
                                    }
                                    const n = o.loaders.get(t);
                                    if (!n) {
                                        continue
                                    }
                                    if (i) {
                                        n.abort()
                                    } else if (n.status == "idle") {
                                        this._readAndUpload(n, e)
                                    }
                                }
                            }
                        }
                    }
                    )
                }
                _readAndUpload(t, e) {
                    const n = this.editor;
                    const i = n.model;
                    const o = n.locale.t;
                    const s = n.plugins.get(Q_);
                    const r = n.plugins.get(gv);
                    i.enqueueChange("transparent", t => {
                        t.setAttribute("uploadStatus", "reading", e)
                    }
                    );
                    return t.read().then(() => {
                        const o = t.upload();
                        if (Pl.isSafari) {
                            const t = n.editing.mapper.toViewElement(e);
                            const i = t.getChild(0);
                            n.editing.view.once("render", () => {
                                if (!i.parent) {
                                    return
                                }
                                const t = n.editing.view.domConverter.mapViewToDom(i.parent);
                                if (!t) {
                                    return
                                }
                                const e = t.style.display;
                                t.style.display = "none";
                                t._ckHack = t.offsetHeight;
                                t.style.display = e
                            }
                            )
                        }
                        i.enqueueChange("transparent", t => {
                            t.setAttribute("uploadStatus", "uploading", e)
                        }
                        );
                        return o
                    }
                    ).then(t => {
                        i.enqueueChange("transparent", n => {
                            n.setAttributes({
                                uploadStatus: "complete",
                                src: t.default
                            }, e);
                            this._parseAndSetSrcsetAttributeOnImage(t, e, n)
                        }
                        );
                        a()
                    }
                    ).catch(n => {
                        if (t.status !== "error" && t.status !== "aborted") {
                            throw n
                        }
                        if (t.status == "error" && n) {
                            r.showWarning(n, {
                                title: o("am"),
                                namespace: "upload"
                            })
                        }
                        a();
                        i.enqueueChange("transparent", t => {
                            t.remove(e)
                        }
                        )
                    }
                    );
                    function a() {
                        i.enqueueChange("transparent", t => {
                            t.removeAttribute("uploadId", e);
                            t.removeAttribute("uploadStatus", e)
                        }
                        );
                        s.destroyLoader(t)
                    }
                }
                _parseAndSetSrcsetAttributeOnImage(t, e, n) {
                    let i = 0;
                    const o = Object.keys(t).filter(t => {
                        const e = parseInt(t, 10);
                        if (!isNaN(e)) {
                            i = Math.max(i, e);
                            return true
                        }
                    }
                    ).map(e => `${t[e]} ${e}w`).join(", ");
                    if (o != "") {
                        n.setAttribute("srcset", {
                            data: o,
                            width: i
                        }, e)
                    }
                }
            }
            function Ev(t) {
                return Array.from(t.types).includes("text/html") && t.getData("text/html") !== ""
            }
            function Rv(t, e) {
                return Array.from(t.model.createRangeOn(e)).filter(t => t.item.is("image")).map(t => t.item)
            }
            class Ov extends Nw {
                static get pluginName() {
                    return "ImageUpload"
                }
                static get requires() {
                    return [Sv, $_, nv]
                }
            }
            const Mv = "italic";
            class Nv extends Nw {
                static get pluginName() {
                    return "ItalicEditing"
                }
                init() {
                    const t = this.editor;
                    t.model.schema.extend("$text", {
                        allowAttributes: Mv
                    });
                    t.model.schema.setAttributeProperties(Mv, {
                        isFormatting: true,
                        copyOnEnter: true
                    });
                    t.conversion.attributeToElement({
                        model: Mv,
                        view: "i",
                        upcastAlso: ["em", {
                            styles: {
                                "font-style": "italic"
                            }
                        }]
                    });
                    t.commands.add(Mv, new Jw(t, Mv));
                    t.keystrokes.set("CTRL+I", Mv)
                }
            }
            var Iv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.586 14.633l.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 110 1.2H5.304a.6.6 0 010-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 00-.281-.823 1.12 1.12 0 00-.442-.296H8.15a.6.6 0 010-1.2h6.443a.6.6 0 110 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
            const Vv = "italic";
            class Bv extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.t;
                    t.ui.componentFactory.add(Vv, n => {
                        const i = t.commands.get(Vv);
                        const o = new Zb(n);
                        o.set({
                            label: e("aj"),
                            icon: Iv,
                            keystroke: "CTRL+I",
                            tooltip: true,
                            isToggleable: true
                        });
                        o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                        this.listenTo(o, "execute", () => {
                            t.execute(Vv);
                            t.editing.view.focus()
                        }
                        );
                        return o
                    }
                    )
                }
            }
            class Fv extends Nw {
                static get requires() {
                    return [Nv, Bv]
                }
                static get pluginName() {
                    return "Italic"
                }
            }
            function Dv(t, e, n) {
                return n.createRange(zv(t, e, true, n), zv(t, e, false, n))
            }
            function zv(t, e, n, i) {
                let o = t.textNode || (n ? t.nodeBefore : t.nodeAfter);
                let s = null;
                while (o && o.getAttribute("linkHref") == e) {
                    s = o;
                    o = n ? o.previousSibling : o.nextSibling
                }
                return s ? i.createPositionAt(s, n ? "before" : "after") : t
            }
            class Lv extends Fw {
                constructor(t) {
                    super(t);
                    this.manualDecorators = new yr
                }
                restoreManualDecoratorStates() {
                    for (const t of this.manualDecorators) {
                        t.value = this._getDecoratorStateFromModel(t.id)
                    }
                }
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    this.value = e.selection.getAttribute("linkHref");
                    for (const t of this.manualDecorators) {
                        t.value = this._getDecoratorStateFromModel(t.id)
                    }
                    this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "linkHref")
                }
                execute(t, e = {}) {
                    const n = this.editor.model;
                    const i = n.document.selection;
                    const o = [];
                    const s = [];
                    for (const t in e) {
                        if (e[t]) {
                            o.push(t)
                        } else {
                            s.push(t)
                        }
                    }
                    n.change(e => {
                        if (i.isCollapsed) {
                            const r = i.getFirstPosition();
                            if (i.hasAttribute("linkHref")) {
                                const a = Dv(r, i.getAttribute("linkHref"), n);
                                e.setAttribute("linkHref", t, a);
                                o.forEach(t => {
                                    e.setAttribute(t, true, a)
                                }
                                );
                                s.forEach(t => {
                                    e.removeAttribute(t, a)
                                }
                                );
                                e.setSelection(a)
                            } else if (t !== "") {
                                const s = Hr(i.getAttributes());
                                s.set("linkHref", t);
                                o.forEach(t => {
                                    s.set(t, true)
                                }
                                );
                                const a = e.createText(t, s);
                                n.insertContent(a, r);
                                e.setSelection(e.createRangeOn(a))
                            }
                        } else {
                            const r = n.schema.getValidRanges(i.getRanges(), "linkHref");
                            for (const n of r) {
                                e.setAttribute("linkHref", t, n);
                                o.forEach(t => {
                                    e.setAttribute(t, true, n)
                                }
                                );
                                s.forEach(t => {
                                    e.removeAttribute(t, n)
                                }
                                )
                            }
                        }
                    }
                    )
                }
                _getDecoratorStateFromModel(t) {
                    const e = this.editor.model.document;
                    return e.selection.getAttribute(t) || false
                }
            }
            class jv extends Fw {
                refresh() {
                    this.isEnabled = this.editor.model.document.selection.hasAttribute("linkHref")
                }
                execute() {
                    const t = this.editor;
                    const e = this.editor.model;
                    const n = e.document.selection;
                    const i = t.commands.get("link");
                    e.change(t => {
                        const o = n.isCollapsed ? [Dv(n.getFirstPosition(), n.getAttribute("linkHref"), e)] : n.getRanges();
                        for (const e of o) {
                            t.removeAttribute("linkHref", e);
                            if (i) {
                                for (const n of i.manualDecorators) {
                                    t.removeAttribute(n.id, e)
                                }
                            }
                        }
                    }
                    )
                }
            }
            function Hv(t, e, n) {
                var i = t.length;
                n = n === undefined ? i : n;
                return !e && n >= i ? t : Oa(t, e, n)
            }
            var qv = Hv;
            var Wv = "\\ud800-\\udfff"
                , Uv = "\\u0300-\\u036f"
                , $v = "\\ufe20-\\ufe2f"
                , Gv = "\\u20d0-\\u20ff"
                , Kv = Uv + $v + Gv
                , Jv = "\\ufe0e\\ufe0f";
            var Qv = "\\u200d";
            var Yv = RegExp("[" + Qv + Wv + Kv + Jv + "]");
            function Xv(t) {
                return Yv.test(t)
            }
            var Zv = Xv;
            function ty(t) {
                return t.split("")
            }
            var ey = ty;
            var ny = "\\ud800-\\udfff"
                , iy = "\\u0300-\\u036f"
                , oy = "\\ufe20-\\ufe2f"
                , sy = "\\u20d0-\\u20ff"
                , ry = iy + oy + sy
                , ay = "\\ufe0e\\ufe0f";
            var cy = "[" + ny + "]"
                , ly = "[" + ry + "]"
                , dy = "\\ud83c[\\udffb-\\udfff]"
                , uy = "(?:" + ly + "|" + dy + ")"
                , hy = "[^" + ny + "]"
                , fy = "(?:\\ud83c[\\udde6-\\uddff]){2}"
                , py = "[\\ud800-\\udbff][\\udc00-\\udfff]"
                , gy = "\\u200d";
            var my = uy + "?"
                , by = "[" + ay + "]?"
                , wy = "(?:" + gy + "(?:" + [hy, fy, py].join("|") + ")" + by + my + ")*"
                , ky = by + my + wy
                , _y = "(?:" + [hy + ly + "?", ly, fy, py, cy].join("|") + ")";
            var vy = RegExp(dy + "(?=" + dy + ")|" + _y + ky, "g");
            function yy(t) {
                return t.match(vy) || []
            }
            var xy = yy;
            function Cy(t) {
                return Zv(t) ? xy(t) : ey(t)
            }
            var Ay = Cy;
            function Py(t) {
                return function (e) {
                    e = _a(e);
                    var n = Zv(e) ? Ay(e) : undefined;
                    var i = n ? n[0] : e.charAt(0);
                    var o = n ? qv(n, 1).join("") : e.slice(1);
                    return i[t]() + o
                }
            }
            var Ty = Py;
            var Sy = Ty("toUpperCase");
            var Ey = Sy;
            const Ry = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
            const Oy = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
            function My(t) {
                return t.is("attributeElement") && !!t.getCustomProperty("link")
            }
            function Ny(t, e) {
                const n = e.createAttributeElement("a", {
                    href: t
                }, {
                    priority: 5
                });
                e.setCustomProperty("link", true, n);
                return n
            }
            function Iy(t) {
                t = String(t);
                return Vy(t) ? t : "#"
            }
            function Vy(t) {
                const e = t.replace(Ry, "");
                return e.match(Oy)
            }
            function By(t, e) {
                const n = {
                    "Open in a new tab": t("be"),
                    Downloadable: t("bf")
                };
                e.forEach(t => {
                    if (t.label && n[t.label]) {
                        t.label = n[t.label]
                    }
                    return t
                }
                );
                return e
            }
            function Fy(t) {
                const e = [];
                if (t) {
                    for (const [n, i] of Object.entries(t)) {
                        const t = Object.assign({}, i, {
                            id: `link${Ey(n)}`
                        });
                        e.push(t)
                    }
                }
                return e
            }
            class Dy {
                constructor() {
                    this._definitions = new Set
                }
                get length() {
                    return this._definitions.size
                }
                add(t) {
                    if (Array.isArray(t)) {
                        t.forEach(t => this._definitions.add(t))
                    } else {
                        this._definitions.add(t)
                    }
                }
                getDispatcher() {
                    return t => {
                        t.on("attribute:linkHref", (t, e, n) => {
                            if (!n.consumable.test(e.item, "attribute:linkHref")) {
                                return
                            }
                            const i = n.writer;
                            const o = i.document.selection;
                            for (const t of this._definitions) {
                                const s = i.createAttributeElement("a", t.attributes, {
                                    priority: 5
                                });
                                i.setCustomProperty("link", true, s);
                                if (t.callback(e.attributeNewValue)) {
                                    if (e.item.is("selection")) {
                                        i.wrap(o.getFirstRange(), s)
                                    } else {
                                        i.wrap(n.mapper.toViewRange(e.range), s)
                                    }
                                } else {
                                    i.unwrap(n.mapper.toViewRange(e.range), s)
                                }
                            }
                        }
                            , {
                                priority: "high"
                            })
                    }
                }
            }
            class zy {
                constructor({ id: t, label: e, attributes: n }) {
                    this.id = t;
                    this.set("value");
                    this.label = e;
                    this.attributes = n
                }
            }
            vr(zy, Jc);
            function Ly({ view: t, model: e, emitter: n, attribute: i, locale: o }) {
                const s = new jy(e, n, i);
                const r = e.document.selection;
                n.listenTo(t.document, "keydown", (t, e) => {
                    if (!r.isCollapsed) {
                        return
                    }
                    if (e.shiftKey || e.altKey || e.ctrlKey) {
                        return
                    }
                    const n = e.keyCode == Vl.arrowright;
                    const i = e.keyCode == Vl.arrowleft;
                    if (!n && !i) {
                        return
                    }
                    const a = r.getFirstPosition();
                    const c = o.contentLanguageDirection;
                    let l;
                    if (c === "ltr" && n || c === "rtl" && i) {
                        l = s.handleForwardMovement(a, e)
                    } else {
                        l = s.handleBackwardMovement(a, e)
                    }
                    if (l) {
                        t.stop()
                    }
                }
                    , {
                        priority: or.get("high") + 1
                    })
            }
            class jy {
                constructor(t, e, n) {
                    this.model = t;
                    this.attribute = n;
                    this._modelSelection = t.document.selection;
                    this._overrideUid = null;
                    this._isNextGravityRestorationSkipped = false;
                    e.listenTo(this._modelSelection, "change:range", (t, e) => {
                        if (this._isNextGravityRestorationSkipped) {
                            this._isNextGravityRestorationSkipped = false;
                            return
                        }
                        if (!this._isGravityOverridden) {
                            return
                        }
                        if (!e.directChange && Hy(this._modelSelection.getFirstPosition(), n)) {
                            return
                        }
                        this._restoreGravity()
                    }
                    )
                }
                handleForwardMovement(t, e) {
                    const n = this.attribute;
                    if (this._isGravityOverridden) {
                        return
                    }
                    if (t.isAtStart && this._hasSelectionAttribute) {
                        return
                    }
                    if (Uy(t, n) && this._hasSelectionAttribute) {
                        this._preventCaretMovement(e);
                        this._removeSelectionAttribute();
                        return true
                    }
                    if (qy(t, n)) {
                        this._preventCaretMovement(e);
                        this._overrideGravity();
                        return true
                    }
                    if (Wy(t, n) && this._hasSelectionAttribute) {
                        this._preventCaretMovement(e);
                        this._overrideGravity();
                        return true
                    }
                }
                handleBackwardMovement(t, e) {
                    const n = this.attribute;
                    if (this._isGravityOverridden) {
                        if (Uy(t, n) && this._hasSelectionAttribute) {
                            this._preventCaretMovement(e);
                            this._restoreGravity();
                            this._removeSelectionAttribute();
                            return true
                        } else {
                            this._preventCaretMovement(e);
                            this._restoreGravity();
                            if (t.isAtStart) {
                                this._removeSelectionAttribute()
                            }
                            return true
                        }
                    } else {
                        if (Uy(t, n) && !this._hasSelectionAttribute) {
                            this._preventCaretMovement(e);
                            this._setSelectionAttributeFromTheNodeBefore(t);
                            return true
                        }
                        if (t.isAtEnd && Wy(t, n)) {
                            if (this._hasSelectionAttribute) {
                                if ($y(t, n)) {
                                    this._skipNextAutomaticGravityRestoration();
                                    this._overrideGravity()
                                }
                                return
                            } else {
                                this._preventCaretMovement(e);
                                this._setSelectionAttributeFromTheNodeBefore(t);
                                return true
                            }
                        }
                        if (t.isAtStart) {
                            if (this._hasSelectionAttribute) {
                                this._removeSelectionAttribute();
                                this._preventCaretMovement(e);
                                return true
                            }
                            return
                        }
                        if ($y(t, n)) {
                            this._skipNextAutomaticGravityRestoration();
                            this._overrideGravity()
                        }
                    }
                }
                get _isGravityOverridden() {
                    return !!this._overrideUid
                }
                get _hasSelectionAttribute() {
                    return this._modelSelection.hasAttribute(this.attribute)
                }
                _overrideGravity() {
                    this._overrideUid = this.model.change(t => t.overrideSelectionGravity())
                }
                _restoreGravity() {
                    this.model.change(t => {
                        t.restoreSelectionGravity(this._overrideUid);
                        this._overrideUid = null
                    }
                    )
                }
                _preventCaretMovement(t) {
                    t.preventDefault()
                }
                _removeSelectionAttribute() {
                    this.model.change(t => {
                        t.removeSelectionAttribute(this.attribute)
                    }
                    )
                }
                _setSelectionAttributeFromTheNodeBefore(t) {
                    const e = this.attribute;
                    this.model.change(n => {
                        n.setSelectionAttribute(this.attribute, t.nodeBefore.getAttribute(e))
                    }
                    )
                }
                _skipNextAutomaticGravityRestoration() {
                    this._isNextGravityRestorationSkipped = true
                }
            }
            function Hy(t, e) {
                return qy(t, e) || Wy(t, e)
            }
            function qy(t, e) {
                const { nodeBefore: n, nodeAfter: i } = t;
                const o = n ? n.hasAttribute(e) : false;
                const s = i ? i.hasAttribute(e) : false;
                return s && (!o || n.getAttribute(e) !== i.getAttribute(e))
            }
            function Wy(t, e) {
                const { nodeBefore: n, nodeAfter: i } = t;
                const o = n ? n.hasAttribute(e) : false;
                const s = i ? i.hasAttribute(e) : false;
                return o && (!s || n.getAttribute(e) !== i.getAttribute(e))
            }
            function Uy(t, e) {
                const { nodeBefore: n, nodeAfter: i } = t;
                const o = n ? n.hasAttribute(e) : false;
                const s = i ? i.hasAttribute(e) : false;
                if (!s || !o) {
                    return
                }
                return i.getAttribute(e) !== n.getAttribute(e)
            }
            function $y(t, e) {
                return Hy(t.getShiftedBy(-1), e)
            }
            var Gy = n(68);
            const Ky = "ck-link_selected";
            const Jy = "automatic";
            const Qy = "manual";
            const Yy = /^(https?:)?\/\//;
            class Xy extends Nw {
                static get pluginName() {
                    return "LinkEditing"
                }
                constructor(t) {
                    super(t);
                    t.config.define("link", {
                        addTargetToExternalLinks: false
                    })
                }
                init() {
                    const t = this.editor;
                    const e = t.locale;
                    t.model.schema.extend("$text", {
                        allowAttributes: "linkHref"
                    });
                    t.conversion.for("dataDowncast").attributeToElement({
                        model: "linkHref",
                        view: Ny
                    });
                    t.conversion.for("editingDowncast").attributeToElement({
                        model: "linkHref",
                        view: (t, e) => Ny(Iy(t), e)
                    });
                    t.conversion.for("upcast").elementToAttribute({
                        view: {
                            name: "a",
                            attributes: {
                                href: true
                            }
                        },
                        model: {
                            key: "linkHref",
                            value: t => t.getAttribute("href")
                        }
                    });
                    t.commands.add("link", new Lv(t));
                    t.commands.add("unlink", new jv(t));
                    const n = By(t.t, Fy(t.config.get("link.decorators")));
                    this._enableAutomaticDecorators(n.filter(t => t.mode === Jy));
                    this._enableManualDecorators(n.filter(t => t.mode === Qy));
                    Ly({
                        view: t.editing.view,
                        model: t.model,
                        emitter: this,
                        attribute: "linkHref",
                        locale: e
                    });
                    this._setupLinkHighlight()
                }
                _enableAutomaticDecorators(t) {
                    const e = this.editor;
                    const n = new Dy;
                    if (e.config.get("link.addTargetToExternalLinks")) {
                        n.add({
                            id: "linkIsExternal",
                            mode: Jy,
                            callback: t => Yy.test(t),
                            attributes: {
                                target: "_blank",
                                rel: "noopener noreferrer"
                            }
                        })
                    }
                    n.add(t);
                    if (n.length) {
                        e.conversion.for("downcast").add(n.getDispatcher())
                    }
                }
                _enableManualDecorators(t) {
                    if (!t.length) {
                        return
                    }
                    const e = this.editor;
                    const n = e.commands.get("link");
                    const i = n.manualDecorators;
                    t.forEach(t => {
                        e.model.schema.extend("$text", {
                            allowAttributes: t.id
                        });
                        i.add(new zy(t));
                        e.conversion.for("downcast").attributeToElement({
                            model: t.id,
                            view: (e, n) => {
                                if (e) {
                                    const e = i.get(t.id).attributes;
                                    const o = n.createAttributeElement("a", e, {
                                        priority: 5
                                    });
                                    n.setCustomProperty("link", true, o);
                                    return o
                                }
                            }
                        });
                        e.conversion.for("upcast").elementToAttribute({
                            view: {
                                name: "a",
                                attributes: i.get(t.id).attributes
                            },
                            model: {
                                key: t.id
                            }
                        })
                    }
                    )
                }
                _setupLinkHighlight() {
                    const t = this.editor;
                    const e = t.editing.view;
                    const n = new Set;
                    e.document.registerPostFixer(e => {
                        const i = t.model.document.selection;
                        let o = false;
                        if (i.hasAttribute("linkHref")) {
                            const s = Dv(i.getFirstPosition(), i.getAttribute("linkHref"), t.model);
                            const r = t.editing.mapper.toViewRange(s);
                            for (const t of r.getItems()) {
                                if (t.is("a") && !t.hasClass(Ky)) {
                                    e.addClass(Ky, t);
                                    n.add(t);
                                    o = true
                                }
                            }
                        }
                        return o
                    }
                    );
                    t.conversion.for("editingDowncast").add(t => {
                        t.on("insert", i, {
                            priority: "highest"
                        });
                        t.on("remove", i, {
                            priority: "highest"
                        });
                        t.on("attribute", i, {
                            priority: "highest"
                        });
                        t.on("selection", i, {
                            priority: "highest"
                        });
                        function i() {
                            e.change(t => {
                                for (const e of n.values()) {
                                    t.removeClass(Ky, e);
                                    n.delete(e)
                                }
                            }
                            )
                        }
                    }
                    )
                }
            }
            class Zy extends Qu {
                constructor(t) {
                    super(t);
                    this.domEventType = "click"
                }
                onDomEvent(t) {
                    this.fire(t.type, t)
                }
            }
            var tx = n(70);
            class ex extends mb {
                constructor(t, e = []) {
                    super(t);
                    const n = t.t;
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this.urlInputView = this._createUrlInput();
                    this.saveButtonView = this._createButton(n("bt"), h_, "ck-button-save");
                    this.saveButtonView.type = "submit";
                    this.cancelButtonView = this._createButton(n("bu"), f_, "ck-button-cancel", "cancel");
                    this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e);
                    this.children = this._createFormChildren(e);
                    this._focusables = new Lm;
                    this._focusCycler = new Nb({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    });
                    const i = ["ck", "ck-link-form"];
                    if (e.length) {
                        i.push("ck-link-form_layout-vertical")
                    }
                    this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: i,
                            tabindex: "-1"
                        },
                        children: this.children
                    })
                }
                getDecoratorSwitchesState() {
                    return Array.from(this._manualDecoratorSwitches).reduce((t, e) => {
                        t[e.name] = e.isOn;
                        return t
                    }
                        , {})
                }
                render() {
                    super.render();
                    u_({
                        view: this
                    });
                    const t = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView];
                    t.forEach(t => {
                        this._focusables.add(t);
                        this.focusTracker.add(t.element)
                    }
                    );
                    this.keystrokes.listenTo(this.element)
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                _createUrlInput() {
                    const t = this.locale.t;
                    const e = new c_(this.locale, d_);
                    e.label = t("cp");
                    e.inputView.placeholder = "https://example.com";
                    return e
                }
                _createButton(t, e, n, i) {
                    const o = new Zb(this.locale);
                    o.set({
                        label: t,
                        icon: e,
                        tooltip: true
                    });
                    o.extendTemplate({
                        attributes: {
                            class: n
                        }
                    });
                    if (i) {
                        o.delegate("execute").to(this, i)
                    }
                    return o
                }
                _createManualDecoratorSwitches(t) {
                    const e = this.createCollection();
                    for (const n of t) {
                        const t = new aw(this.locale);
                        t.set({
                            name: n.id,
                            label: n.label,
                            withText: true
                        });
                        t.bind("isOn").to(n, "value");
                        t.on("execute", () => {
                            n.set("value", !t.isOn)
                        }
                        );
                        e.add(t)
                    }
                    return e
                }
                _createFormChildren(t) {
                    const e = this.createCollection();
                    e.add(this.urlInputView);
                    if (t.length) {
                        const t = new mb;
                        t.setTemplate({
                            tag: "ul",
                            children: this._manualDecoratorSwitches.map(t => ({
                                tag: "li",
                                children: [t],
                                attributes: {
                                    class: ["ck", "ck-list__item"]
                                }
                            })),
                            attributes: {
                                class: ["ck", "ck-reset", "ck-list"]
                            }
                        });
                        e.add(t)
                    }
                    e.add(this.saveButtonView);
                    e.add(this.cancelButtonView);
                    return e
                }
            }
            var nx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 111.229.86l-1.148 1.64a.748.748 0 01-.217.206 5.251 5.251 0 01-8.503-5.955.741.741 0 01.12-.274l1.147-1.639a.75.75 0 111.228.86L4.933 10.7l.006.003a3.75 3.75 0 006.132 4.294l.006.004zm5.494-5.335a.748.748 0 01-.12.274l-1.147 1.639a.75.75 0 11-1.228-.86l.86-1.23a3.75 3.75 0 00-6.144-4.301l-.86 1.229a.75.75 0 01-1.229-.86l1.148-1.64a.748.748 0 01.217-.206 5.251 5.251 0 018.503 5.955zm-4.563-2.532a.75.75 0 01.184 1.045l-3.155 4.505a.75.75 0 11-1.229-.86l3.155-4.506a.75.75 0 011.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 11-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 011.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 011.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 01-1.06 1.06l-1.415-1.414z"/></svg>';
            var ix = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.3 17.37l-.061.088a1.518 1.518 0 01-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 01.187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z"/></svg>';
            var ox = n(72);
            class sx extends mb {
                constructor(t) {
                    super(t);
                    const e = t.t;
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this.previewButtonView = this._createPreviewButton();
                    this.unlinkButtonView = this._createButton(e("cl"), nx, "unlink");
                    this.editButtonView = this._createButton(e("cm"), ix, "edit");
                    this.set("href");
                    this._focusables = new Lm;
                    this._focusCycler = new Nb({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    });
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-link-actions"],
                            tabindex: "-1"
                        },
                        children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                    })
                }
                render() {
                    super.render();
                    const t = [this.previewButtonView, this.editButtonView, this.unlinkButtonView];
                    t.forEach(t => {
                        this._focusables.add(t);
                        this.focusTracker.add(t.element)
                    }
                    );
                    this.keystrokes.listenTo(this.element)
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                _createButton(t, e, n) {
                    const i = new Zb(this.locale);
                    i.set({
                        label: t,
                        icon: e,
                        tooltip: true
                    });
                    i.delegate("execute").to(this, n);
                    return i
                }
                _createPreviewButton() {
                    const t = new Zb(this.locale);
                    const e = this.bindTemplate;
                    const n = this.t;
                    t.set({
                        withText: true,
                        tooltip: n("cn")
                    });
                    t.extendTemplate({
                        attributes: {
                            class: ["ck", "ck-link-actions__preview"],
                            href: e.to("href", t => t && Iy(t)),
                            target: "_blank",
                            rel: "noopener noreferrer"
                        }
                    });
                    t.bind("label").to(this, "href", t => t || n("co"));
                    t.bind("isEnabled").to(this, "href", t => !!t);
                    t.template.tag = "a";
                    t.template.eventListeners = {};
                    return t
                }
            }
            var rx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 111.229.86l-1.148 1.64a.748.748 0 01-.217.206 5.251 5.251 0 01-8.503-5.955.741.741 0 01.12-.274l1.147-1.639a.75.75 0 111.228.86L4.933 10.7l.006.003a3.75 3.75 0 006.132 4.294l.006.004zm5.494-5.335a.748.748 0 01-.12.274l-1.147 1.639a.75.75 0 11-1.228-.86l.86-1.23a3.75 3.75 0 00-6.144-4.301l-.86 1.229a.75.75 0 01-1.229-.86l1.148-1.64a.748.748 0 01.217-.206 5.251 5.251 0 018.503 5.955zm-4.563-2.532a.75.75 0 01.184 1.045l-3.155 4.505a.75.75 0 11-1.229-.86l3.155-4.506a.75.75 0 011.045-.184z"/></svg>';
            const ax = "Ctrl+K";
            class cx extends Nw {
                static get requires() {
                    return [S_]
                }
                static get pluginName() {
                    return "LinkUI"
                }
                init() {
                    const t = this.editor;
                    t.editing.view.addObserver(Zy);
                    this.actionsView = this._createActionsView();
                    this.formView = this._createFormView();
                    this._balloon = t.plugins.get(S_);
                    this._createToolbarLinkButton();
                    this._enableUserBalloonInteractions()
                }
                destroy() {
                    super.destroy();
                    this.formView.destroy()
                }
                _createActionsView() {
                    const t = this.editor;
                    const e = new sx(t.locale);
                    const n = t.commands.get("link");
                    const i = t.commands.get("unlink");
                    e.bind("href").to(n, "value");
                    e.editButtonView.bind("isEnabled").to(n);
                    e.unlinkButtonView.bind("isEnabled").to(i);
                    this.listenTo(e, "edit", () => {
                        this._addFormView()
                    }
                    );
                    this.listenTo(e, "unlink", () => {
                        t.execute("unlink");
                        this._hideUI()
                    }
                    );
                    e.keystrokes.set("Esc", (t, e) => {
                        this._hideUI();
                        e()
                    }
                    );
                    e.keystrokes.set(ax, (t, e) => {
                        this._addFormView();
                        e()
                    }
                    );
                    return e
                }
                _createFormView() {
                    const t = this.editor;
                    const e = t.commands.get("link");
                    const n = new ex(t.locale, e.manualDecorators);
                    n.urlInputView.bind("value").to(e, "value");
                    n.urlInputView.bind("isReadOnly").to(e, "isEnabled", t => !t);
                    n.saveButtonView.bind("isEnabled").to(e);
                    this.listenTo(n, "submit", () => {
                        t.execute("link", n.urlInputView.inputView.element.value, n.getDecoratorSwitchesState());
                        this._closeFormView()
                    }
                    );
                    this.listenTo(n, "cancel", () => {
                        this._closeFormView()
                    }
                    );
                    n.keystrokes.set("Esc", (t, e) => {
                        this._closeFormView();
                        e()
                    }
                    );
                    return n
                }
                _createToolbarLinkButton() {
                    const t = this.editor;
                    const e = t.commands.get("link");
                    const n = t.t;
                    t.keystrokes.set(ax, (t, e) => {
                        e();
                        this._showUI(true)
                    }
                    );
                    t.ui.componentFactory.add("link", t => {
                        const i = new Zb(t);
                        i.isEnabled = true;
                        i.label = n("g");
                        i.icon = rx;
                        i.keystroke = ax;
                        i.tooltip = true;
                        i.isToggleable = true;
                        i.bind("isEnabled").to(e, "isEnabled");
                        i.bind("isOn").to(e, "value", t => !!t);
                        this.listenTo(i, "execute", () => this._showUI(true));
                        return i
                    }
                    )
                }
                _enableUserBalloonInteractions() {
                    const t = this.editor.editing.view.document;
                    this.listenTo(t, "click", () => {
                        const t = this._getSelectedLinkElement();
                        if (t) {
                            this._showUI()
                        }
                    }
                    );
                    this.editor.keystrokes.set("Tab", (t, e) => {
                        if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                            this.actionsView.focus();
                            e()
                        }
                    }
                        , {
                            priority: "high"
                        });
                    this.editor.keystrokes.set("Esc", (t, e) => {
                        if (this._isUIVisible) {
                            this._hideUI();
                            e()
                        }
                    }
                    );
                    cw({
                        emitter: this.formView,
                        activator: () => this._isUIInPanel,
                        contextElements: [this._balloon.view.element],
                        callback: () => this._hideUI()
                    })
                }
                _addActionsView() {
                    if (this._areActionsInPanel) {
                        return
                    }
                    this._balloon.add({
                        view: this.actionsView,
                        position: this._getBalloonPositionData()
                    })
                }
                _addFormView() {
                    if (this._isFormInPanel) {
                        return
                    }
                    const t = this.editor;
                    const e = t.commands.get("link");
                    this._balloon.add({
                        view: this.formView,
                        position: this._getBalloonPositionData()
                    });
                    if (this._balloon.visibleView === this.formView) {
                        this.formView.urlInputView.select()
                    }
                    this.formView.urlInputView.inputView.element.value = e.value || ""
                }
                _closeFormView() {
                    const t = this.editor.commands.get("link");
                    t.restoreManualDecoratorStates();
                    if (t.value !== undefined) {
                        this._removeFormView()
                    } else {
                        this._hideUI()
                    }
                }
                _removeFormView() {
                    if (this._isFormInPanel) {
                        this.formView.saveButtonView.focus();
                        this._balloon.remove(this.formView);
                        this.editor.editing.view.focus()
                    }
                }
                _showUI(t = false) {
                    if (!this._getSelectedLinkElement()) {
                        this._addActionsView();
                        if (t) {
                            this._balloon.showStack("main")
                        }
                        this._addFormView()
                    } else {
                        if (this._areActionsVisible) {
                            this._addFormView()
                        } else {
                            this._addActionsView()
                        }
                        if (t) {
                            this._balloon.showStack("main")
                        }
                    }
                    this._startUpdatingUI()
                }
                _hideUI() {
                    if (!this._isUIInPanel) {
                        return
                    }
                    const t = this.editor;
                    this.stopListening(t.ui, "update");
                    this.stopListening(this._balloon, "change:visibleView");
                    t.editing.view.focus();
                    this._removeFormView();
                    this._balloon.remove(this.actionsView)
                }
                _startUpdatingUI() {
                    const t = this.editor;
                    const e = t.editing.view.document;
                    let n = this._getSelectedLinkElement();
                    let i = s();
                    const o = () => {
                        const t = this._getSelectedLinkElement();
                        const e = s();
                        if (n && !t || !n && e !== i) {
                            this._hideUI()
                        } else if (this._isUIVisible) {
                            this._balloon.updatePosition(this._getBalloonPositionData())
                        }
                        n = t;
                        i = e
                    }
                        ;
                    function s() {
                        return e.selection.focus.getAncestors().reverse().find(t => t.is("element"))
                    }
                    this.listenTo(t.ui, "update", o);
                    this.listenTo(this._balloon, "change:visibleView", o)
                }
                get _isFormInPanel() {
                    return this._balloon.hasView(this.formView)
                }
                get _areActionsInPanel() {
                    return this._balloon.hasView(this.actionsView)
                }
                get _areActionsVisible() {
                    return this._balloon.visibleView === this.actionsView
                }
                get _isUIInPanel() {
                    return this._isFormInPanel || this._areActionsInPanel
                }
                get _isUIVisible() {
                    const t = this._balloon.visibleView;
                    return t == this.formView || this._areActionsVisible
                }
                _getBalloonPositionData() {
                    const t = this.editor.editing.view;
                    const e = t.document;
                    const n = this._getSelectedLinkElement();
                    const i = n ? t.domConverter.mapViewToDom(n) : t.domConverter.viewRangeToDom(e.selection.getFirstRange());
                    return {
                        target: i
                    }
                }
                _getSelectedLinkElement() {
                    const t = this.editor.editing.view;
                    const e = t.document.selection;
                    if (e.isCollapsed) {
                        return lx(e.getFirstPosition())
                    } else {
                        const n = e.getFirstRange().getTrimmed();
                        const i = lx(n.start);
                        const o = lx(n.end);
                        if (!i || i != o) {
                            return null
                        }
                        if (t.createRangeIn(i).getTrimmed().isEqual(n)) {
                            return i
                        } else {
                            return null
                        }
                    }
                }
            }
            function lx(t) {
                return t.getAncestors().find(t => My(t))
            }
            class dx extends Nw {
                static get requires() {
                    return [Xy, cx]
                }
                static get pluginName() {
                    return "Link"
                }
            }
            function ux(t, e) {
                let n = e.parent;
                while (n) {
                    if (n.name === t) {
                        return n
                    }
                    n = n.parent
                }
            }
            function hx(t, e, n, i, o = 1) {
                if (e > o) {
                    i.setAttribute(t, e, n)
                } else {
                    i.removeAttribute(t, n)
                }
            }
            function fx(t, e, n = {}) {
                const i = t.createElement("tableCell", n);
                t.insertElement("paragraph", i);
                t.insert(i, e)
            }
            function px(t) {
                if (!t || !ct(t)) {
                    return t
                }
                const { top: e, right: n, bottom: i, left: o } = t;
                if (e == n && n == i && i == o) {
                    return e
                }
            }
            function gx(t, e) {
                const n = parseFloat(t);
                if (Number.isNaN(n)) {
                    return t
                }
                if (String(n) !== String(t)) {
                    return t
                }
                return `${n}${e}`
            }
            function mx() {
                return t => {
                    t.on("element:table", (t, e, n) => {
                        const i = e.viewItem;
                        if (!n.consumable.test(i, {
                            name: true
                        })) {
                            return
                        }
                        const { rows: o, headingRows: s, headingColumns: r } = wx(i);
                        const a = {};
                        if (r) {
                            a.headingColumns = r
                        }
                        if (s) {
                            a.headingRows = s
                        }
                        const c = n.writer.createElement("table", a);
                        const l = n.splitToAllowedParent(c, e.modelCursor);
                        if (!l) {
                            return
                        }
                        n.writer.insert(c, l.position);
                        n.consumable.consume(i, {
                            name: true
                        });
                        if (o.length) {
                            o.forEach(t => n.convertItem(t, n.writer.createPositionAt(c, "end")))
                        } else {
                            const t = n.writer.createElement("tableRow");
                            n.writer.insert(t, n.writer.createPositionAt(c, "end"));
                            fx(n.writer, n.writer.createPositionAt(t, "end"))
                        }
                        e.modelRange = n.writer.createRange(n.writer.createPositionBefore(c), n.writer.createPositionAfter(c));
                        if (l.cursorParent) {
                            e.modelCursor = n.writer.createPositionAt(l.cursorParent, 0)
                        } else {
                            e.modelCursor = e.modelRange.end
                        }
                    }
                    )
                }
            }
            function bx(t) {
                return e => {
                    e.on(`element:${t}`, (t, e, n) => {
                        const i = e.viewItem;
                        if (!n.consumable.test(i, {
                            name: true
                        })) {
                            return
                        }
                        const o = n.writer.createElement("tableCell");
                        const s = n.splitToAllowedParent(o, e.modelCursor);
                        if (!s) {
                            return
                        }
                        n.writer.insert(o, s.position);
                        n.consumable.consume(i, {
                            name: true
                        });
                        const r = n.writer.createPositionAt(o, 0);
                        n.convertChildren(i, r);
                        if (!o.childCount) {
                            n.writer.insertElement("paragraph", r)
                        }
                        e.modelRange = n.writer.createRange(n.writer.createPositionBefore(o), n.writer.createPositionAfter(o));
                        e.modelCursor = e.modelRange.end
                    }
                    )
                }
            }
            function wx(t) {
                const e = {
                    headingRows: 0,
                    headingColumns: 0
                };
                const n = [];
                const i = [];
                let o;
                for (const s of Array.from(t.getChildren())) {
                    if (s.name === "tbody" || s.name === "thead" || s.name === "tfoot") {
                        if (s.name === "thead" && !o) {
                            o = s
                        }
                        const t = Array.from(s.getChildren()).filter(t => t.is("element", "tr"));
                        for (const s of t) {
                            if (s.parent.name === "thead" && s.parent === o) {
                                e.headingRows++;
                                n.push(s)
                            } else {
                                i.push(s);
                                const t = kx(s, e, o);
                                if (t > e.headingColumns) {
                                    e.headingColumns = t
                                }
                            }
                        }
                    }
                }
                e.rows = [...n, ...i];
                return e
            }
            function kx(t) {
                let e = 0;
                let n = 0;
                const i = Array.from(t.getChildren()).filter(t => t.name === "th" || t.name === "td");
                while (n < i.length && i[n].name === "th") {
                    const t = i[n];
                    const o = parseInt(t.getAttribute("colspan") || 1);
                    e = e + o;
                    n++
                }
                return e
            }
            class _x {
                constructor(t, e = {}) {
                    this.table = t;
                    this.startRow = e.startRow || 0;
                    this.endRow = typeof e.endRow == "number" ? e.endRow : undefined;
                    this.includeSpanned = !!e.includeSpanned;
                    this.column = typeof e.column == "number" ? e.column : undefined;
                    this._skipRows = new Set;
                    this._row = 0;
                    this._column = 0;
                    this._cellIndex = 0;
                    this._spannedCells = new Map;
                    this._nextCellAtColumn = -1
                }
                [Symbol.iterator]() {
                    return this
                }
                next() {
                    const t = this.table.getChild(this._row);
                    if (!t || this._isOverEndRow()) {
                        return {
                            done: true
                        }
                    }
                    let e, n, i;
                    if (this._isSpanned(this._row, this._column)) {
                        e = this._getSpanned(this._row, this._column);
                        n = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn();
                        i = this._formatOutValue(e, this._column, true)
                    } else {
                        e = t.getChild(this._cellIndex);
                        if (!e) {
                            this._row++;
                            this._column = 0;
                            this._cellIndex = 0;
                            this._nextCellAtColumn = -1;
                            return this.next()
                        }
                        const o = parseInt(e.getAttribute("colspan") || 1);
                        const s = parseInt(e.getAttribute("rowspan") || 1);
                        if (o > 1 || s > 1) {
                            this._recordSpans(this._row, this._column, s, o, e)
                        }
                        this._nextCellAtColumn = this._column + o;
                        n = this._shouldSkipRow() || this._shouldSkipColumn();
                        i = this._formatOutValue(e, this._column, false, s, o)
                    }
                    this._column++;
                    if (this._column == this._nextCellAtColumn) {
                        this._cellIndex++
                    }
                    return n ? this.next() : i
                }
                skipRow(t) {
                    this._skipRows.add(t)
                }
                _isOverEndRow() {
                    return this.endRow !== undefined && this._row > this.endRow
                }
                _formatOutValue(t, e, n, i = 1, o = 1) {
                    return {
                        done: false,
                        value: {
                            cell: t,
                            row: this._row,
                            column: e,
                            isSpanned: n,
                            rowspan: i,
                            colspan: o,
                            cellIndex: this._cellIndex
                        }
                    }
                }
                _shouldSkipRow() {
                    const t = this._row < this.startRow;
                    const e = this._skipRows.has(this._row);
                    return t || e
                }
                _shouldSkipColumn() {
                    if (this.column === undefined) {
                        return false
                    }
                    return this.column != this._column
                }
                _isSpanned(t, e) {
                    if (!this._spannedCells.has(t)) {
                        return false
                    }
                    const n = this._spannedCells.get(t);
                    return n.has(e)
                }
                _getSpanned(t, e) {
                    return this._spannedCells.get(t).get(e)
                }
                _recordSpans(t, e, n, i, o) {
                    for (let n = e + 1; n <= e + i - 1; n++) {
                        this._markSpannedCell(t, n, o)
                    }
                    for (let s = t + 1; s < t + n; s++) {
                        for (let t = e; t <= e + i - 1; t++) {
                            this._markSpannedCell(s, t, o)
                        }
                    }
                }
                _markSpannedCell(t, e, n) {
                    if (!this._spannedCells.has(t)) {
                        this._spannedCells.set(t, new Map)
                    }
                    const i = this._spannedCells.get(t);
                    i.set(e, n)
                }
            }
            function vx(t, e) {
                e.setCustomProperty("table", true, t);
                return Sk(t, e, {
                    hasSelectionHandle: true
                })
            }
            function yx(t) {
                return !!t.getCustomProperty("table") && Tk(t)
            }
            function xx(t) {
                const e = t.getSelectedElement();
                if (e && yx(e)) {
                    return e
                }
                return null
            }
            function Cx(t) {
                const e = ux("table", t.getFirstPosition());
                if (e && yx(e.parent)) {
                    return e.parent
                }
                return null
            }
            function Ax(t = {}) {
                return e => e.on("insert:table", (e, n, i) => {
                    const o = n.item;
                    if (!i.consumable.consume(o, "insert")) {
                        return
                    }
                    i.consumable.consume(o, "attribute:headingRows:table");
                    i.consumable.consume(o, "attribute:headingColumns:table");
                    const s = t && t.asWidget;
                    const r = i.writer.createContainerElement("figure", {
                        class: "table"
                    });
                    const a = i.writer.createContainerElement("table");
                    i.writer.insert(i.writer.createPositionAt(r, 0), a);
                    let c;
                    if (s) {
                        c = vx(r, i.writer)
                    }
                    const l = new _x(o);
                    const d = {
                        headingRows: o.getAttribute("headingRows") || 0,
                        headingColumns: o.getAttribute("headingColumns") || 0
                    };
                    const u = new Map;
                    for (const e of l) {
                        const { row: n, cell: s } = e;
                        const r = Fx(Bx(n, d), a, i);
                        const c = o.getChild(n);
                        const l = u.get(n) || Ix(c, n, r, i);
                        u.set(n, l);
                        i.consumable.consume(s, "insert");
                        const h = i.writer.createPositionAt(l, "end");
                        Nx(e, d, h, i, t)
                    }
                    const h = i.mapper.toViewPosition(n.range.start);
                    i.mapper.bindElements(o, s ? c : r);
                    i.writer.insert(h, s ? c : r)
                }
                )
            }
            function Px(t = {}) {
                return e => e.on("insert:tableRow", (e, n, i) => {
                    const o = n.item;
                    if (!i.consumable.consume(o, "insert")) {
                        return
                    }
                    const s = o.parent;
                    const r = i.mapper.toViewElement(s);
                    const a = Hx(r);
                    const c = s.getChildIndex(o);
                    const l = new _x(s, {
                        startRow: c,
                        endRow: c
                    });
                    const d = {
                        headingRows: s.getAttribute("headingRows") || 0,
                        headingColumns: s.getAttribute("headingColumns") || 0
                    };
                    const u = new Map;
                    for (const e of l) {
                        const n = Fx(Bx(c, d), a, i);
                        const s = u.get(c) || Ix(o, c, n, i);
                        u.set(c, s);
                        i.consumable.consume(e.cell, "insert");
                        const r = i.writer.createPositionAt(s, "end");
                        Nx(e, d, r, i, t)
                    }
                }
                )
            }
            function Tx(t = {}) {
                return e => e.on("insert:tableCell", (e, n, i) => {
                    const o = n.item;
                    if (!i.consumable.consume(o, "insert")) {
                        return
                    }
                    const s = o.parent;
                    const r = s.parent;
                    const a = r.getChildIndex(s);
                    const c = new _x(r, {
                        startRow: a,
                        endRow: a
                    });
                    const l = {
                        headingRows: r.getAttribute("headingRows") || 0,
                        headingColumns: r.getAttribute("headingColumns") || 0
                    };
                    for (const e of c) {
                        if (e.cell === o) {
                            const n = i.mapper.toViewElement(s);
                            const r = i.writer.createPositionAt(n, s.getChildIndex(o));
                            Nx(e, l, r, i, t);
                            return
                        }
                    }
                }
                )
            }
            function Sx(t = {}) {
                const e = !!t.asWidget;
                return t => t.on("attribute:headingRows:table", (t, n, i) => {
                    const o = n.item;
                    if (!i.consumable.consume(n.item, t.name)) {
                        return
                    }
                    const s = i.mapper.toViewElement(o);
                    const r = Hx(s);
                    const a = n.attributeOldValue;
                    const c = n.attributeNewValue;
                    if (c > a) {
                        const t = Array.from(o.getChildren()).filter(({ index: t }) => l(t, a - 1, c));
                        const n = Fx("thead", r, i);
                        jx(t, n, i, "end");
                        for (const n of t) {
                            for (const t of n.getChildren()) {
                                Ox(t, "th", i, e)
                            }
                        }
                        Lx("tbody", r, i)
                    } else {
                        const t = Array.from(o.getChildren()).filter(({ index: t }) => l(t, c - 1, a)).reverse();
                        const n = Fx("tbody", r, i);
                        jx(t, n, i, 0);
                        const s = new _x(o, {
                            startRow: c ? c - 1 : c,
                            endRow: a - 1
                        });
                        const d = {
                            headingRows: o.getAttribute("headingRows") || 0,
                            headingColumns: o.getAttribute("headingColumns") || 0
                        };
                        for (const t of s) {
                            Mx(t, d, i, e)
                        }
                        Lx("thead", r, i)
                    }
                    function l(t, e, n) {
                        return t > e && t < n
                    }
                }
                )
            }
            function Ex(t = {}) {
                const e = !!t.asWidget;
                return t => t.on("attribute:headingColumns:table", (t, n, i) => {
                    const o = n.item;
                    if (!i.consumable.consume(n.item, t.name)) {
                        return
                    }
                    const s = {
                        headingRows: o.getAttribute("headingRows") || 0,
                        headingColumns: o.getAttribute("headingColumns") || 0
                    };
                    const r = n.attributeOldValue;
                    const a = n.attributeNewValue;
                    const c = (r > a ? r : a) - 1;
                    for (const t of new _x(o)) {
                        if (t.column > c) {
                            continue
                        }
                        Mx(t, s, i, e)
                    }
                }
                )
            }
            function Rx() {
                return t => t.on("remove:tableRow", (t, e, n) => {
                    t.stop();
                    const i = n.writer;
                    const o = n.mapper;
                    const s = o.toViewPosition(e.position).getLastMatchingPosition(t => !t.item.is("tr"));
                    const r = s.nodeAfter;
                    const a = r.parent;
                    const c = i.createRangeOn(r);
                    const l = i.remove(c);
                    for (const t of i.createRangeIn(l).getItems()) {
                        o.unbindViewElement(t)
                    }
                    if (!a.childCount) {
                        i.remove(i.createRangeOn(a))
                    }
                }
                    , {
                        priority: "higher"
                    })
            }
            function Ox(t, e, n, i) {
                const o = n.writer;
                const s = n.mapper.toViewElement(t);
                if (!s) {
                    return
                }
                let r;
                if (i) {
                    const t = o.createEditableElement(e, s.getAttributes());
                    r = Mk(t, o);
                    o.insert(o.createPositionAfter(s), r);
                    o.move(o.createRangeIn(s), o.createPositionAt(r, 0));
                    o.remove(o.createRangeOn(s))
                } else {
                    r = o.rename(e, s)
                }
                n.mapper.unbindViewElement(s);
                n.mapper.bindElements(t, r)
            }
            function Mx(t, e, n, i) {
                const { cell: o } = t;
                const s = Vx(t, e);
                const r = n.mapper.toViewElement(o);
                if (r && r.name !== s) {
                    Ox(o, s, n, i)
                }
            }
            function Nx(t, e, n, i, o) {
                const s = o && o.asWidget;
                const r = Vx(t, e);
                const a = s ? Mk(i.writer.createEditableElement(r), i.writer) : i.writer.createContainerElement(r);
                const c = t.cell;
                const l = c.getChild(0);
                const d = c.childCount === 1 && l.name === "paragraph";
                i.writer.insert(n, a);
                if (d && !qx(l)) {
                    const t = c.getChild(0);
                    const e = i.writer.createPositionAt(a, "end");
                    i.consumable.consume(t, "insert");
                    if (o.asWidget) {
                        const n = i.writer.createContainerElement("span", {
                            style: "display:inline-block"
                        });
                        i.mapper.bindElements(t, n);
                        i.writer.insert(e, n);
                        i.mapper.bindElements(c, a)
                    } else {
                        i.mapper.bindElements(c, a);
                        i.mapper.bindElements(t, a)
                    }
                } else {
                    i.mapper.bindElements(c, a)
                }
            }
            function Ix(t, e, n, i) {
                i.consumable.consume(t, "insert");
                const o = i.writer.createContainerElement("tr");
                i.mapper.bindElements(t, o);
                const s = t.parent.getAttribute("headingRows") || 0;
                const r = s > 0 && e >= s ? e - s : e;
                const a = i.writer.createPositionAt(n, r);
                i.writer.insert(a, o);
                return o
            }
            function Vx(t, e) {
                const { row: n, column: i } = t;
                const { headingColumns: o, headingRows: s } = e;
                const r = s && s > n;
                if (r) {
                    return "th"
                }
                const a = o && o > i;
                return a ? "th" : "td"
            }
            function Bx(t, e) {
                return t < e.headingRows ? "thead" : "tbody"
            }
            function Fx(t, e, n) {
                const i = Dx(t, e);
                return i ? i : zx(t, e, n)
            }
            function Dx(t, e) {
                for (const n of e.getChildren()) {
                    if (n.name == t) {
                        return n
                    }
                }
            }
            function zx(t, e, n) {
                const i = n.writer.createContainerElement(t);
                const o = n.writer.createPositionAt(e, t == "tbody" ? "end" : 0);
                n.writer.insert(o, i);
                return i
            }
            function Lx(t, e, n) {
                const i = Dx(t, e);
                if (i && i.childCount === 0) {
                    n.writer.remove(n.writer.createRangeOn(i))
                }
            }
            function jx(t, e, n, i) {
                for (const o of t) {
                    const t = n.mapper.toViewElement(o);
                    if (t) {
                        n.writer.move(n.writer.createRangeOn(t), n.writer.createPositionAt(e, i))
                    }
                }
            }
            function Hx(t) {
                for (const e of t.getChildren()) {
                    if (e.name === "table") {
                        return e
                    }
                }
            }
            function qx(t) {
                return !![...t.getAttributeKeys()].length
            }
            class Wx extends Fw {
                refresh() {
                    const t = this.editor.model;
                    const e = t.document.selection;
                    const n = t.schema;
                    const i = Ux(e.getFirstPosition());
                    this.isEnabled = n.checkChild(i, "table")
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document.selection;
                    const i = this.editor.plugins.get("TableUtils");
                    const o = parseInt(t.rows) || 2;
                    const s = parseInt(t.columns) || 2;
                    const r = Nk(n, e);
                    e.change(t => {
                        const n = i.createTable(t, o, s);
                        e.insertContent(n, r);
                        t.setSelection(t.createPositionAt(n.getNodeByPath([0, 0, 0]), 0))
                    }
                    )
                }
            }
            function Ux(t) {
                const e = t.parent;
                return e === e.root ? e : e.parent
            }
            class $x extends Fw {
                constructor(t, e = {}) {
                    super(t);
                    this.order = e.order || "below"
                }
                refresh() {
                    const t = this.editor.model.document.selection;
                    const e = ux("table", t.getFirstPosition());
                    this.isEnabled = !!e
                }
                execute() {
                    const t = this.editor;
                    const e = t.model.document.selection;
                    const n = t.plugins.get("TableUtils");
                    const i = ux("tableCell", e.getFirstPosition());
                    const o = i.parent;
                    const s = o.parent;
                    const r = s.getChildIndex(o);
                    const a = this.order === "below" ? r + 1 : r;
                    n.insertRows(s, {
                        rows: 1,
                        at: a
                    })
                }
            }
            class Gx extends Fw {
                constructor(t, e = {}) {
                    super(t);
                    this.order = e.order || "right"
                }
                refresh() {
                    const t = this.editor.model.document.selection;
                    const e = ux("table", t.getFirstPosition());
                    this.isEnabled = !!e
                }
                execute() {
                    const t = this.editor;
                    const e = t.model.document.selection;
                    const n = t.plugins.get("TableUtils");
                    const i = e.getFirstPosition();
                    const o = ux("tableCell", i);
                    const s = o.parent.parent;
                    const { column: r } = n.getCellLocation(o);
                    const a = this.order === "right" ? r + 1 : r;
                    n.insertColumns(s, {
                        columns: 1,
                        at: a
                    })
                }
            }
            class Kx extends Fw {
                constructor(t, e = {}) {
                    super(t);
                    this.direction = e.direction || "horizontally"
                }
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = ux("tableCell", e.selection.getFirstPosition());
                    this.isEnabled = !!n
                }
                execute() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = e.selection;
                    const i = n.getFirstPosition();
                    const o = ux("tableCell", i);
                    const s = this.direction === "horizontally";
                    const r = this.editor.plugins.get("TableUtils");
                    if (s) {
                        r.splitCellHorizontally(o, 2)
                    } else {
                        r.splitCellVertically(o, 2)
                    }
                }
            }
            class Jx extends Fw {
                constructor(t, e) {
                    super(t);
                    this.direction = e.direction;
                    this.isHorizontal = this.direction == "right" || this.direction == "left"
                }
                refresh() {
                    const t = this._getMergeableCell();
                    this.value = t;
                    this.isEnabled = !!t
                }
                execute() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = ux("tableCell", e.selection.getFirstPosition());
                    const i = this.value;
                    const o = this.direction;
                    t.change(t => {
                        const e = o == "right" || o == "down";
                        const s = e ? n : i;
                        const r = e ? i : n;
                        const a = r.parent;
                        Zx(r, s, t);
                        const c = this.isHorizontal ? "colspan" : "rowspan";
                        const l = parseInt(n.getAttribute(c) || 1);
                        const d = parseInt(i.getAttribute(c) || 1);
                        t.setAttribute(c, l + d, s);
                        t.setSelection(t.createRangeIn(s));
                        if (!a.childCount) {
                            Xx(a, t)
                        }
                    }
                    )
                }
                _getMergeableCell() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = ux("tableCell", e.selection.getFirstPosition());
                    if (!n) {
                        return
                    }
                    const i = this.editor.plugins.get("TableUtils");
                    const o = this.isHorizontal ? Qx(n, this.direction, i) : Yx(n, this.direction);
                    if (!o) {
                        return
                    }
                    const s = this.isHorizontal ? "rowspan" : "colspan";
                    const r = parseInt(n.getAttribute(s) || 1);
                    const a = parseInt(o.getAttribute(s) || 1);
                    if (a === r) {
                        return o
                    }
                }
            }
            function Qx(t, e, n) {
                const i = t.parent;
                const o = i.parent;
                const s = e == "right" ? t.nextSibling : t.previousSibling;
                const r = o.getAttribute("headingColumns") || 0;
                if (!s) {
                    return
                }
                const a = e == "right" ? t : s;
                const c = e == "right" ? s : t;
                const { column: l } = n.getCellLocation(a);
                const { column: d } = n.getCellLocation(c);
                const u = parseInt(a.getAttribute("colspan") || 1);
                const h = parseInt(c.getAttribute("colspan") || 1);
                const f = e == "right" && d + h > r;
                const p = e == "left" && l + u > r - 1;
                if (r && (f || p)) {
                    return
                }
                const g = l + u === d;
                return g ? s : undefined
            }
            function Yx(t, e) {
                const n = t.parent;
                const i = n.parent;
                const o = i.getChildIndex(n);
                if (e == "down" && o === i.childCount - 1 || e == "up" && o === 0) {
                    return
                }
                const s = parseInt(t.getAttribute("rowspan") || 1);
                const r = i.getAttribute("headingRows") || 0;
                const a = e == "down" && o + s === r;
                const c = e == "up" && o === r;
                if (r && (a || c)) {
                    return
                }
                const l = parseInt(t.getAttribute("rowspan") || 1);
                const d = e == "down" ? o + l : o;
                const u = [...new _x(i, {
                    endRow: d
                })];
                const h = u.find(e => e.cell === t);
                const f = h.column;
                const p = u.find(({ row: t, rowspan: n, column: i }) => {
                    if (i !== f) {
                        return false
                    }
                    if (e == "down") {
                        return t === d
                    } else {
                        return d === t + n
                    }
                }
                );
                return p && p.cell
            }
            function Xx(t, e) {
                const n = t.parent;
                const i = n.getChildIndex(t);
                for (const { cell: t, row: o, rowspan: s } of new _x(n, {
                    endRow: i
                })) {
                    const n = o + s - 1 >= i;
                    if (n) {
                        hx("rowspan", s - 1, t, e)
                    }
                }
                e.remove(t)
            }
            function Zx(t, e, n) {
                if (!tC(t)) {
                    if (tC(e)) {
                        n.remove(n.createRangeIn(e))
                    }
                    n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))
                }
                n.remove(t)
            }
            function tC(t) {
                return t.childCount == 1 && t.getChild(0).is("paragraph") && t.getChild(0).isEmpty
            }
            class eC extends Fw {
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = ux("tableCell", e.selection.getFirstPosition());
                    this.isEnabled = !!n && n.parent.parent.childCount > 1
                }
                execute() {
                    const t = this.editor.model;
                    const e = t.document.selection;
                    const n = e.getFirstPosition();
                    const i = ux("tableCell", n);
                    const o = i.parent;
                    const s = o.parent;
                    const r = s.getChildIndex(o);
                    const a = s.getAttribute("headingRows") || 0;
                    t.change(t => {
                        if (a && r <= a) {
                            hx("headingRows", a - 1, s, t, 0)
                        }
                        const e = [...new _x(s, {
                            endRow: r
                        })];
                        const n = new Map;
                        e.filter(({ row: t, rowspan: e }) => t === r && e > 1).forEach(({ column: t, cell: e, rowspan: i }) => n.set(t, {
                            cell: e,
                            rowspanToSet: i - 1
                        }));
                        e.filter(({ row: t, rowspan: e }) => t <= r - 1 && t + e > r).forEach(({ cell: e, rowspan: n }) => hx("rowspan", n - 1, e, t));
                        const i = r + 1;
                        const c = new _x(s, {
                            includeSpanned: true,
                            startRow: i,
                            endRow: i
                        });
                        let l;
                        for (const { row: e, column: i, cell: o } of [...c]) {
                            if (n.has(i)) {
                                const { cell: o, rowspanToSet: r } = n.get(i);
                                const a = l ? t.createPositionAfter(l) : t.createPositionAt(s.getChild(e), 0);
                                t.move(t.createRangeOn(o), a);
                                hx("rowspan", r, o, t);
                                l = o
                            } else {
                                l = o
                            }
                        }
                        t.remove(o)
                    }
                    )
                }
            }
            class nC extends Fw {
                refresh() {
                    const t = this.editor;
                    const e = t.model.document.selection;
                    const n = t.plugins.get("TableUtils");
                    const i = ux("tableCell", e.getFirstPosition());
                    this.isEnabled = !!i && n.getColumns(i.parent.parent) > 1
                }
                execute() {
                    const t = this.editor.model;
                    const e = t.document.selection;
                    const n = e.getFirstPosition();
                    const i = ux("tableCell", n);
                    const o = i.parent;
                    const s = o.parent;
                    const r = s.getAttribute("headingColumns") || 0;
                    const a = s.getChildIndex(o);
                    const c = [...new _x(s)];
                    const l = c.find(t => t.cell === i);
                    const d = l.column;
                    t.change(t => {
                        if (r && a <= r) {
                            t.setAttribute("headingColumns", r - 1, s)
                        }
                        for (const { cell: e, column: n, colspan: i } of c) {
                            if (n <= d && i > 1 && n + i > d) {
                                hx("colspan", i - 1, e, t)
                            } else if (n === d) {
                                t.remove(e)
                            }
                        }
                    }
                    )
                }
            }
            class iC extends Fw {
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = e.selection;
                    const i = n.getFirstPosition();
                    const o = ux("tableCell", i);
                    const s = !!o;
                    this.isEnabled = s;
                    this.value = s && this._isInHeading(o, o.parent.parent)
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document;
                    const i = n.selection;
                    const o = i.getFirstPosition();
                    const s = ux("tableCell", o);
                    const r = s.parent;
                    const a = r.parent;
                    const c = a.getAttribute("headingRows") || 0;
                    const l = r.index;
                    if (t.forceValue === this.value) {
                        return
                    }
                    const d = this.value ? l : l + 1;
                    e.change(t => {
                        if (d) {
                            const e = oC(a, d, c);
                            for (const n of e) {
                                sC(n, d, t)
                            }
                        }
                        hx("headingRows", d, a, t, 0)
                    }
                    )
                }
                _isInHeading(t, e) {
                    const n = parseInt(e.getAttribute("headingRows") || 0);
                    return !!n && t.parent.index < n
                }
            }
            function oC(t, e, n) {
                const i = [];
                const o = e > n ? n : 0;
                const s = e - 1;
                const r = new _x(t, {
                    startRow: o,
                    endRow: s
                });
                for (const { row: t, rowspan: n, cell: o } of r) {
                    if (n > 1 && t + n > e) {
                        i.push(o)
                    }
                }
                return i
            }
            function sC(t, e, n) {
                const i = t.parent;
                const o = i.parent;
                const s = i.index;
                const r = parseInt(t.getAttribute("rowspan"));
                const a = e - s;
                const c = {};
                const l = r - a;
                if (l > 1) {
                    c.rowspan = l
                }
                const d = parseInt(t.getAttribute("colspan") || 1);
                if (d > 1) {
                    c.colspan = d
                }
                const u = o.getChildIndex(i);
                const h = u + a;
                const f = [...new _x(o, {
                    startRow: u,
                    endRow: h,
                    includeSpanned: true
                })];
                let p;
                for (const { row: e, column: i, cell: s, cellIndex: r } of f) {
                    if (s === t && p === undefined) {
                        p = i
                    }
                    if (p !== undefined && p === i && e === h) {
                        const t = o.getChild(e);
                        const i = n.createPositionAt(t, r);
                        fx(n, i, c)
                    }
                }
                hx("rowspan", a, t, n)
            }
            class rC extends Fw {
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    const n = e.selection;
                    const i = n.getFirstPosition();
                    const o = ux("tableCell", i);
                    const s = !!o;
                    this.isEnabled = s;
                    this.value = s && this._isInHeading(o, o.parent.parent)
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document;
                    const i = n.selection;
                    const o = this.editor.plugins.get("TableUtils");
                    const s = i.getFirstPosition();
                    const r = ux("tableCell", s);
                    const a = r.parent;
                    const c = a.parent;
                    const { column: l } = o.getCellLocation(r);
                    if (t.forceValue === this.value) {
                        return
                    }
                    const d = this.value ? l : l + 1;
                    e.change(t => {
                        hx("headingColumns", d, c, t, 0)
                    }
                    )
                }
                _isInHeading(t, e) {
                    const n = parseInt(e.getAttribute("headingColumns") || 0);
                    const i = this.editor.plugins.get("TableUtils");
                    const { column: o } = i.getCellLocation(t);
                    return !!n && o < n
                }
            }
            class aC extends Nw {
                static get pluginName() {
                    return "TableUtils"
                }
                getCellLocation(t) {
                    const e = t.parent;
                    const n = e.parent;
                    const i = n.getChildIndex(e);
                    const o = new _x(n, {
                        startRow: i,
                        endRow: i
                    });
                    for (const { cell: e, row: n, column: i } of o) {
                        if (e === t) {
                            return {
                                row: n,
                                column: i
                            }
                        }
                    }
                }
                createTable(t, e, n) {
                    const i = t.createElement("table");
                    cC(t, i, 0, e, n);
                    return i
                }
                insertRows(t, e = {}) {
                    const n = this.editor.model;
                    const i = e.at || 0;
                    const o = e.rows || 1;
                    n.change(e => {
                        const n = t.getAttribute("headingRows") || 0;
                        if (n > i) {
                            e.setAttribute("headingRows", n + o, t)
                        }
                        if (i === 0 || i === t.childCount) {
                            cC(e, t, i, o, this.getColumns(t));
                            return
                        }
                        const s = new _x(t, {
                            endRow: i
                        });
                        let r = 0;
                        for (const { row: t, rowspan: n, colspan: a, cell: c } of s) {
                            const s = t < i;
                            const l = t + n > i;
                            if (s && l) {
                                e.setAttribute("rowspan", n + o, c)
                            }
                            if (t === i) {
                                r += a
                            }
                        }
                        cC(e, t, i, o, r)
                    }
                    )
                }
                insertColumns(t, e = {}) {
                    const n = this.editor.model;
                    const i = e.at || 0;
                    const o = e.columns || 1;
                    n.change(e => {
                        const n = t.getAttribute("headingColumns");
                        if (i < n) {
                            e.setAttribute("headingColumns", n + o, t)
                        }
                        const s = this.getColumns(t);
                        if (i === 0 || s === i) {
                            for (const n of t.getChildren()) {
                                lC(o, e, e.createPositionAt(n, i ? "end" : 0))
                            }
                            return
                        }
                        const r = new _x(t, {
                            column: i,
                            includeSpanned: true
                        });
                        for (const { row: n, cell: s, cellIndex: a } of r) {
                            const c = parseInt(s.getAttribute("rowspan") || 1);
                            const l = parseInt(s.getAttribute("colspan") || 1);
                            if (s.index !== i && l > 1) {
                                e.setAttribute("colspan", l + o, s);
                                r.skipRow(n);
                                if (c > 1) {
                                    for (let t = n + 1; t < n + c; t++) {
                                        r.skipRow(t)
                                    }
                                }
                            } else {
                                const i = e.createPositionAt(t.getChild(n), a);
                                lC(o, e, i)
                            }
                        }
                    }
                    )
                }
                splitCellVertically(t, e = 2) {
                    const n = this.editor.model;
                    const i = t.parent;
                    const o = i.parent;
                    const s = parseInt(t.getAttribute("rowspan") || 1);
                    const r = parseInt(t.getAttribute("colspan") || 1);
                    n.change(n => {
                        if (r > 1) {
                            const { newCellsSpan: i, updatedSpan: o } = dC(r, e);
                            hx("colspan", o, t, n);
                            const a = {};
                            if (i > 1) {
                                a.colspan = i
                            }
                            if (s > 1) {
                                a.rowspan = s
                            }
                            const c = r > e ? e - 1 : r - 1;
                            lC(c, n, n.createPositionAfter(t), a)
                        }
                        if (r < e) {
                            const i = e - r;
                            const a = [...new _x(o)];
                            const { column: c } = a.find(({ cell: e }) => e === t);
                            const l = a.filter(({ cell: e, colspan: n, column: i }) => {
                                const o = e !== t && i === c;
                                const s = i < c && i + n > c;
                                return o || s
                            }
                            );
                            for (const { cell: t, colspan: e } of l) {
                                n.setAttribute("colspan", e + i, t)
                            }
                            const d = {};
                            if (s > 1) {
                                d.rowspan = s
                            }
                            lC(i, n, n.createPositionAfter(t), d);
                            const u = o.getAttribute("headingColumns") || 0;
                            if (u > c) {
                                hx("headingColumns", u + i, o, n)
                            }
                        }
                    }
                    )
                }
                splitCellHorizontally(t, e = 2) {
                    const n = this.editor.model;
                    const i = t.parent;
                    const o = i.parent;
                    const s = o.getChildIndex(i);
                    const r = parseInt(t.getAttribute("rowspan") || 1);
                    const a = parseInt(t.getAttribute("colspan") || 1);
                    n.change(n => {
                        if (r > 1) {
                            const i = [...new _x(o, {
                                startRow: s,
                                endRow: s + r - 1,
                                includeSpanned: true
                            })];
                            const { newCellsSpan: c, updatedSpan: l } = dC(r, e);
                            hx("rowspan", l, t, n);
                            const { column: d } = i.find(({ cell: e }) => e === t);
                            const u = {};
                            if (c > 1) {
                                u.rowspan = c
                            }
                            if (a > 1) {
                                u.colspan = a
                            }
                            for (const { column: t, row: e, cellIndex: r } of i) {
                                const i = e >= s + l;
                                const a = t === d;
                                const h = (e + s + l) % c === 0;
                                if (i && a && h) {
                                    const t = n.createPositionAt(o.getChild(e), r);
                                    lC(1, n, t, u)
                                }
                            }
                        }
                        if (r < e) {
                            const i = e - r;
                            const c = [...new _x(o, {
                                startRow: 0,
                                endRow: s
                            })];
                            for (const { cell: e, rowspan: o, row: r } of c) {
                                if (e !== t && r + o > s) {
                                    const t = o + i;
                                    n.setAttribute("rowspan", t, e)
                                }
                            }
                            const l = {};
                            if (a > 1) {
                                l.colspan = a
                            }
                            cC(n, o, s + 1, i, 1, l);
                            const d = o.getAttribute("headingRows") || 0;
                            if (d > s) {
                                hx("headingRows", d + i, o, n)
                            }
                        }
                    }
                    )
                }
                getColumns(t) {
                    const e = t.getChild(0);
                    return [...e.getChildren()].reduce((t, e) => {
                        const n = parseInt(e.getAttribute("colspan") || 1);
                        return t + n
                    }
                        , 0)
                }
            }
            function cC(t, e, n, i, o, s = {}) {
                for (let r = 0; r < i; r++) {
                    const i = t.createElement("tableRow");
                    t.insert(i, e, n);
                    lC(o, t, t.createPositionAt(i, "end"), s)
                }
            }
            function lC(t, e, n, i = {}) {
                for (let o = 0; o < t; o++) {
                    fx(e, n, i)
                }
            }
            function dC(t, e) {
                if (t < e) {
                    return {
                        newCellsSpan: 1,
                        updatedSpan: 1
                    }
                }
                const n = Math.floor(t / e);
                const i = t - n * e + n;
                return {
                    newCellsSpan: n,
                    updatedSpan: i
                }
            }
            function uC(t) {
                t.document.registerPostFixer(e => hC(e, t))
            }
            function hC(t, e) {
                const n = e.document.differ.getChanges();
                let i = false;
                const o = new Set;
                for (const e of n) {
                    let n;
                    if (e.name == "table" && e.type == "insert") {
                        n = e.position.nodeAfter
                    }
                    if (e.name == "tableRow" || e.name == "tableCell") {
                        n = ux("table", e.position)
                    }
                    if (bC(e)) {
                        n = ux("table", e.range.start)
                    }
                    if (n && !o.has(n)) {
                        i = fC(n, t) || i;
                        i = pC(n, t) || i;
                        o.add(n)
                    }
                }
                return i
            }
            function fC(t, e) {
                let n = false;
                const i = gC(t);
                if (i.length) {
                    n = true;
                    for (const t of i) {
                        hx("rowspan", t.rowspan, t.cell, e, 1)
                    }
                }
                return n
            }
            function pC(t, e) {
                let n = false;
                const i = mC(t);
                const o = i[0];
                const s = Object.values(i).every(t => t === o);
                if (!s) {
                    const o = Object.values(i).reduce((t, e) => e > t ? e : t, 0);
                    for (const [s, r] of Object.entries(i)) {
                        const i = o - r;
                        if (i) {
                            for (let n = 0; n < i; n++) {
                                fx(e, e.createPositionAt(t.getChild(s), "end"))
                            }
                            n = true
                        }
                    }
                }
                return n
            }
            function gC(t) {
                const e = parseInt(t.getAttribute("headingRows") || 0);
                const n = t.childCount;
                const i = [];
                for (const { row: o, rowspan: s, cell: r } of new _x(t)) {
                    if (s < 2) {
                        continue
                    }
                    const t = o < e;
                    const a = t ? e : n;
                    if (o + s > a) {
                        const t = a - o;
                        i.push({
                            cell: r,
                            rowspan: t
                        })
                    }
                }
                return i
            }
            function mC(t) {
                const e = {};
                for (const { row: n } of new _x(t, {
                    includeSpanned: true
                })) {
                    if (!e[n]) {
                        e[n] = 0
                    }
                    e[n] += 1
                }
                return e
            }
            function bC(t) {
                const e = t.type === "attribute";
                const n = t.attributeKey;
                return e && (n === "headingRows" || n === "colspan" || n === "rowspan")
            }
            function wC(t) {
                t.document.registerPostFixer(e => kC(e, t))
            }
            function kC(t, e) {
                const n = e.document.differ.getChanges();
                let i = false;
                for (const e of n) {
                    if (e.type == "insert" && e.name == "table") {
                        i = _C(e.position.nodeAfter, t) || i
                    }
                    if (e.type == "insert" && e.name == "tableRow") {
                        i = vC(e.position.nodeAfter, t) || i
                    }
                    if (e.type == "insert" && e.name == "tableCell") {
                        i = yC(e.position.nodeAfter, t) || i
                    }
                    if (xC(e)) {
                        i = yC(e.position.parent, t) || i
                    }
                }
                return i
            }
            function _C(t, e) {
                let n = false;
                for (const i of t.getChildren()) {
                    n = vC(i, e) || n
                }
                return n
            }
            function vC(t, e) {
                let n = false;
                for (const i of t.getChildren()) {
                    n = yC(i, e) || n
                }
                return n
            }
            function yC(t, e) {
                if (t.childCount == 0) {
                    e.insertElement("paragraph", t);
                    return true
                }
                const n = Array.from(t.getChildren()).filter(t => t.is("text"));
                for (const t of n) {
                    e.wrap(e.createRangeOn(t), "paragraph")
                }
                return !!n.length
            }
            function xC(t) {
                if (!t.position || !t.position.parent.is("tableCell")) {
                    return false
                }
                return t.type == "insert" && t.name == "$text" || t.type == "remove"
            }
            function CC(t) {
                t.document.registerPostFixer(() => AC(t))
            }
            function AC(t) {
                const e = t.document.differ;
                const n = new Set;
                for (const t of e.getChanges()) {
                    const e = t.type == "insert" || t.type == "remove" ? t.position.parent : t.range.start.parent;
                    if (e.is("tableCell") && PC(e, t.type)) {
                        n.add(e)
                    }
                }
                if (n.size) {
                    for (const t of n.values()) {
                        e.refreshItem(t)
                    }
                    return true
                }
                return false
            }
            function PC(t, e) {
                const n = Array.from(t.getChildren()).some(t => t.is("paragraph"));
                if (!n) {
                    return false
                }
                if (e == "attribute") {
                    const e = Array.from(t.getChild(0).getAttributeKeys()).length;
                    return t.childCount === 1 && e < 2
                }
                return t.childCount <= (e == "insert" ? 2 : 1)
            }
            var TC = n(74);
            class SC extends Nw {
                static get pluginName() {
                    return "TableEditing"
                }
                init() {
                    const t = this.editor;
                    const e = t.model;
                    const n = e.schema;
                    const i = t.conversion;
                    n.register("table", {
                        allowWhere: "$block",
                        allowAttributes: ["headingRows", "headingColumns"],
                        isLimit: true,
                        isObject: true,
                        isBlock: true
                    });
                    n.register("tableRow", {
                        allowIn: "table",
                        isLimit: true
                    });
                    n.register("tableCell", {
                        allowIn: "tableRow",
                        allowAttributes: ["colspan", "rowspan"],
                        isLimit: true
                    });
                    n.extend("$block", {
                        allowIn: "tableCell"
                    });
                    n.addChildCheck((t, e) => {
                        if (e.name == "table" && Array.from(t.getNames()).includes("table")) {
                            return false
                        }
                    }
                    );
                    i.for("upcast").add(mx());
                    i.for("editingDowncast").add(Ax({
                        asWidget: true
                    }));
                    i.for("dataDowncast").add(Ax());
                    i.for("upcast").elementToElement({
                        model: "tableRow",
                        view: "tr"
                    });
                    i.for("editingDowncast").add(Px({
                        asWidget: true
                    }));
                    i.for("dataDowncast").add(Px());
                    i.for("downcast").add(Rx());
                    i.for("upcast").add(bx("td"));
                    i.for("upcast").add(bx("th"));
                    i.for("editingDowncast").add(Tx({
                        asWidget: true
                    }));
                    i.for("dataDowncast").add(Tx());
                    i.attributeToAttribute({
                        model: "colspan",
                        view: "colspan"
                    });
                    i.attributeToAttribute({
                        model: "rowspan",
                        view: "rowspan"
                    });
                    i.for("editingDowncast").add(Ex({
                        asWidget: true
                    }));
                    i.for("dataDowncast").add(Ex());
                    i.for("editingDowncast").add(Sx({
                        asWidget: true
                    }));
                    i.for("dataDowncast").add(Sx());
                    t.commands.add("insertTable", new Wx(t));
                    t.commands.add("insertTableRowAbove", new $x(t, {
                        order: "above"
                    }));
                    t.commands.add("insertTableRowBelow", new $x(t, {
                        order: "below"
                    }));
                    t.commands.add("insertTableColumnLeft", new Gx(t, {
                        order: "left"
                    }));
                    t.commands.add("insertTableColumnRight", new Gx(t, {
                        order: "right"
                    }));
                    t.commands.add("removeTableRow", new eC(t));
                    t.commands.add("removeTableColumn", new nC(t));
                    t.commands.add("splitTableCellVertically", new Kx(t, {
                        direction: "vertically"
                    }));
                    t.commands.add("splitTableCellHorizontally", new Kx(t, {
                        direction: "horizontally"
                    }));
                    t.commands.add("mergeTableCellRight", new Jx(t, {
                        direction: "right"
                    }));
                    t.commands.add("mergeTableCellLeft", new Jx(t, {
                        direction: "left"
                    }));
                    t.commands.add("mergeTableCellDown", new Jx(t, {
                        direction: "down"
                    }));
                    t.commands.add("mergeTableCellUp", new Jx(t, {
                        direction: "up"
                    }));
                    t.commands.add("setTableColumnHeader", new rC(t));
                    t.commands.add("setTableRowHeader", new iC(t));
                    uC(e);
                    CC(e);
                    wC(e);
                    this.editor.keystrokes.set("Tab", (...t) => this._handleTabOnSelectedTable(...t), {
                        priority: "low"
                    });
                    this.editor.keystrokes.set("Tab", this._getTabHandler(true), {
                        priority: "low"
                    });
                    this.editor.keystrokes.set("Shift+Tab", this._getTabHandler(false), {
                        priority: "low"
                    })
                }
                static get requires() {
                    return [aC]
                }
                _handleTabOnSelectedTable(t, e) {
                    const n = this.editor;
                    const i = n.model.document.selection;
                    if (!i.isCollapsed && i.rangeCount === 1 && i.getFirstRange().isFlat) {
                        const t = i.getSelectedElement();
                        if (!t || !t.is("table")) {
                            return
                        }
                        e();
                        n.model.change(e => {
                            e.setSelection(e.createRangeIn(t.getChild(0).getChild(0)))
                        }
                        )
                    }
                }
                _getTabHandler(t) {
                    const e = this.editor;
                    return (n, i) => {
                        const o = e.model.document.selection;
                        const s = o.getFirstPosition();
                        const r = ux("tableCell", s);
                        if (!r) {
                            return
                        }
                        i();
                        const a = r.parent;
                        const c = a.parent;
                        const l = c.getChildIndex(a);
                        const d = a.getChildIndex(r);
                        const u = d === 0;
                        if (!t && u && l === 0) {
                            return
                        }
                        const h = d === a.childCount - 1;
                        const f = l === c.childCount - 1;
                        if (t && f && h) {
                            e.execute("insertTableRowBelow");
                            if (l === c.childCount - 1) {
                                return
                            }
                        }
                        let p;
                        if (t && h) {
                            const t = c.getChild(l + 1);
                            p = t.getChild(0)
                        } else if (!t && u) {
                            const t = c.getChild(l - 1);
                            p = t.getChild(t.childCount - 1)
                        } else {
                            p = a.getChild(d + (t ? 1 : -1))
                        }
                        e.model.change(t => {
                            t.setSelection(t.createRangeIn(p))
                        }
                        )
                    }
                }
            }
            var EC = n(76);
            class RC extends mb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.items = this.createCollection();
                    this.set("rows", 0);
                    this.set("columns", 0);
                    this.bind("label").to(this, "columns", this, "rows", (t, e) => `${e} × ${t}`);
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck"]
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck-insert-table-dropdown__grid"]
                            },
                            children: this.items
                        }, {
                            tag: "div",
                            attributes: {
                                class: ["ck-insert-table-dropdown__label"]
                            },
                            children: [{
                                text: e.to("label")
                            }]
                        }],
                        on: {
                            mousedown: e.to(t => {
                                t.preventDefault()
                            }
                            ),
                            click: e.to(() => {
                                this.fire("execute")
                            }
                            )
                        }
                    });
                    for (let t = 0; t < 100; t++) {
                        const e = new OC;
                        e.on("over", () => {
                            const e = Math.floor(t / 10);
                            const n = t % 10;
                            this.set("rows", e + 1);
                            this.set("columns", n + 1)
                        }
                        );
                        this.items.add(e)
                    }
                    this.on("change:columns", () => {
                        this._highlightGridBoxes()
                    }
                    );
                    this.on("change:rows", () => {
                        this._highlightGridBoxes()
                    }
                    )
                }
                focus() { }
                focusLast() { }
                _highlightGridBoxes() {
                    const t = this.rows;
                    const e = this.columns;
                    this.items.map((n, i) => {
                        const o = Math.floor(i / 10);
                        const s = i % 10;
                        const r = o < t && s < e;
                        n.set("isOn", r)
                    }
                    )
                }
            }
            class OC extends mb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("isOn", false);
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck-insert-table-dropdown-grid-box", e.if("isOn", "ck-on")]
                        },
                        on: {
                            mouseover: e.to("over")
                        }
                    })
                }
            }
            var MC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 01-1.5 1.5H3A1.5 1.5 0 011.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>';
            var NC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0119 2.5v15a1.5 1.5 0 01-1.5 1.5h-15A1.5 1.5 0 011 17.5v-15A1.5 1.5 0 012.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 01-1 1H7a1 1 0 01-1-1V1a1 1 0 011-1h6a1 1 0 011 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>';
            var IC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0119 2.5v15a1.5 1.5 0 01-1.5 1.5h-15A1.5 1.5 0 011 17.5v-15A1.5 1.5 0 012.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 011 1v6a1 1 0 01-1 1H1a1 1 0 01-1-1V7a1 1 0 011-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>';
            var VC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0119 2.5v15a1.5 1.5 0 01-1.5 1.5h-15A1.5 1.5 0 011 17.5v-15A1.5 1.5 0 012.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 011 1v11a1 1 0 01-1 1H7a1 1 0 01-1-1V8a1 1 0 011-1zm1 2v9h10V9H8z"/></svg>';
            class BC extends Nw {
                init() {
                    const t = this.editor;
                    const e = this.editor.t;
                    const n = t.locale.contentLanguageDirection;
                    const i = n === "ltr";
                    t.ui.componentFactory.add("insertTable", n => {
                        const i = t.commands.get("insertTable");
                        const o = uw(n);
                        o.bind("isEnabled").to(i);
                        o.buttonView.set({
                            icon: MC,
                            label: e("h"),
                            tooltip: true
                        });
                        let s;
                        o.on("change:isOpen", () => {
                            if (s) {
                                return
                            }
                            s = new RC(n);
                            o.panelView.children.add(s);
                            s.delegate("execute").to(o);
                            o.buttonView.on("open", () => {
                                s.rows = 0;
                                s.columns = 0
                            }
                            );
                            o.on("execute", () => {
                                t.execute("insertTable", {
                                    rows: s.rows,
                                    columns: s.columns
                                });
                                t.editing.view.focus()
                            }
                            )
                        }
                        );
                        return o
                    }
                    );
                    t.ui.componentFactory.add("tableColumn", t => {
                        const n = [{
                            type: "switchbutton",
                            model: {
                                commandName: "setTableColumnHeader",
                                label: e("i"),
                                bindIsOn: true
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: i ? "insertTableColumnLeft" : "insertTableColumnRight",
                                label: e("j")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: i ? "insertTableColumnRight" : "insertTableColumnLeft",
                                label: e("k")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "removeTableColumn",
                                label: e("l")
                            }
                        }];
                        return this._prepareDropdown(e("m"), NC, n, t)
                    }
                    );
                    t.ui.componentFactory.add("tableRow", t => {
                        const n = [{
                            type: "switchbutton",
                            model: {
                                commandName: "setTableRowHeader",
                                label: e("n"),
                                bindIsOn: true
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: "insertTableRowBelow",
                                label: e("o")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "insertTableRowAbove",
                                label: e("p")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "removeTableRow",
                                label: e("q")
                            }
                        }];
                        return this._prepareDropdown(e("r"), IC, n, t)
                    }
                    );
                    t.ui.componentFactory.add("mergeTableCells", t => {
                        const n = [{
                            type: "button",
                            model: {
                                commandName: "mergeTableCellUp",
                                label: e("s")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: i ? "mergeTableCellRight" : "mergeTableCellLeft",
                                label: e("t")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "mergeTableCellDown",
                                label: e("u")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: i ? "mergeTableCellLeft" : "mergeTableCellRight",
                                label: e("v")
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: "splitTableCellVertically",
                                label: e("w")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "splitTableCellHorizontally",
                                label: e("x")
                            }
                        }];
                        return this._prepareDropdown(e("y"), VC, n, t)
                    }
                    )
                }
                _prepareDropdown(t, e, n, i) {
                    const o = this.editor;
                    const s = uw(i);
                    const r = [];
                    const a = new yr;
                    for (const t of n) {
                        FC(t, o, r, a)
                    }
                    fw(s, a, o.ui.componentFactory);
                    s.buttonView.set({
                        label: t,
                        icon: e,
                        tooltip: true
                    });
                    s.bind("isEnabled").toMany(r, "isEnabled", (...t) => t.some(t => t));
                    this.listenTo(s, "execute", t => {
                        o.execute(t.source.commandName);
                        o.editing.view.focus()
                    }
                    );
                    return s
                }
            }
            function FC(t, e, n, i) {
                const o = t.model = new uk(t.model);
                const { commandName: s, bindIsOn: r } = t.model;
                if (t.type === "button" || t.type === "switchbutton") {
                    const t = e.commands.get(s);
                    n.push(t);
                    o.set({
                        commandName: s
                    });
                    o.bind("isEnabled").to(t);
                    if (r) {
                        o.bind("isOn").to(t, "value")
                    }
                }
                o.set({
                    withText: true
                });
                i.add(t)
            }
            var DC = n(78);
            class zC extends Nw {
                static get requires() {
                    return [SC, BC, Zk]
                }
                static get pluginName() {
                    return "Table"
                }
            }
            class LC extends Nw {
                static get requires() {
                    return [S_]
                }
                static get pluginName() {
                    return "WidgetToolbarRepository"
                }
                init() {
                    const t = this.editor;
                    if (t.plugins.has("BalloonToolbar")) {
                        const e = t.plugins.get("BalloonToolbar");
                        this.listenTo(e, "show", e => {
                            if (qC(t.editing.view.document.selection)) {
                                e.stop()
                            }
                        }
                            , {
                                priority: "high"
                            })
                    }
                    this._toolbarDefinitions = new Map;
                    this._balloon = this.editor.plugins.get("ContextualBalloon");
                    this.on("change:isEnabled", () => {
                        this._updateToolbarsVisibility()
                    }
                    );
                    this.listenTo(t.ui, "update", () => {
                        this._updateToolbarsVisibility()
                    }
                    );
                    this.listenTo(t.ui.focusTracker, "change:isFocused", () => {
                        this._updateToolbarsVisibility()
                    }
                        , {
                            priority: "low"
                        })
                }
                destroy() {
                    super.destroy();
                    for (const t of this._toolbarDefinitions.values()) {
                        t.view.destroy()
                    }
                }
                register(t, { ariaLabel: e, items: n, getRelatedElement: i, balloonClassName: o = "ck-toolbar-container" }) {
                    const s = this.editor;
                    const r = s.t;
                    const a = new _w(s.locale);
                    a.ariaLabel = e || r("av");
                    if (this._toolbarDefinitions.has(t)) {
                        throw new rr["b"]("widget-toolbar-duplicated: Toolbar with the given id was already added.", this, {
                            toolbarId: t
                        })
                    }
                    a.fillFromConfig(n, s.ui.componentFactory);
                    this._toolbarDefinitions.set(t, {
                        view: a,
                        getRelatedElement: i,
                        balloonClassName: o
                    })
                }
                _updateToolbarsVisibility() {
                    let t = 0;
                    let e = null;
                    let n = null;
                    for (const i of this._toolbarDefinitions.values()) {
                        const o = i.getRelatedElement(this.editor.editing.view.document.selection);
                        if (!this.isEnabled || !o) {
                            if (this._isToolbarInBalloon(i)) {
                                this._hideToolbar(i)
                            }
                        } else if (!this.editor.ui.focusTracker.isFocused) {
                            if (this._isToolbarVisible(i)) {
                                this._hideToolbar(i)
                            }
                        } else {
                            const s = o.getAncestors().length;
                            if (s > t) {
                                t = s;
                                e = o;
                                n = i
                            }
                        }
                    }
                    if (n) {
                        this._showToolbar(n, e)
                    }
                }
                _hideToolbar(t) {
                    this._balloon.remove(t.view);
                    this.stopListening(this._balloon, "change:visibleView")
                }
                _showToolbar(t, e) {
                    if (this._isToolbarVisible(t)) {
                        jC(this.editor, e)
                    } else if (!this._isToolbarInBalloon(t)) {
                        this._balloon.add({
                            view: t.view,
                            position: HC(this.editor, e),
                            balloonClassName: t.balloonClassName
                        });
                        this.listenTo(this._balloon, "change:visibleView", () => {
                            for (const t of this._toolbarDefinitions.values()) {
                                if (this._isToolbarVisible(t)) {
                                    const e = t.getRelatedElement(this.editor.editing.view.document.selection);
                                    jC(this.editor, e)
                                }
                            }
                        }
                        )
                    }
                }
                _isToolbarVisible(t) {
                    return this._balloon.visibleView === t.view
                }
                _isToolbarInBalloon(t) {
                    return this._balloon.hasView(t.view)
                }
            }
            function jC(t, e) {
                const n = t.plugins.get("ContextualBalloon");
                const i = HC(t, e);
                n.updatePosition(i)
            }
            function HC(t, e) {
                const n = t.editing.view;
                const i = k_.defaultPositions;
                return {
                    target: n.domConverter.mapViewToDom(e),
                    positions: [i.northArrowSouth, i.northArrowSouthWest, i.northArrowSouthEast, i.southArrowNorth, i.southArrowNorthWest, i.southArrowNorthEast]
                }
            }
            function qC(t) {
                const e = t.getSelectedElement();
                return !!(e && Tk(e))
            }
            class WC extends Nw {
                static get requires() {
                    return [LC]
                }
                static get pluginName() {
                    return "TableToolbar"
                }
                afterInit() {
                    const t = this.editor;
                    const e = t.t;
                    const n = t.plugins.get(LC);
                    const i = t.config.get("table.contentToolbar");
                    const o = t.config.get("table.tableToolbar");
                    if (i) {
                        n.register("tableContent", {
                            ariaLabel: e("a"),
                            items: i,
                            getRelatedElement: Cx
                        })
                    }
                    if (o) {
                        n.register("table", {
                            ariaLabel: e("a"),
                            items: o,
                            getRelatedElement: xx
                        })
                    }
                }
            }
            class UC {
                constructor(t) {
                    this.set("activeHandlePosition", null);
                    this.set("proposedWidthPercents", null);
                    this.set("proposedWidth", null);
                    this.set("proposedHeight", null);
                    this.set("proposedHandleHostWidth", null);
                    this.set("proposedHandleHostHeight", null);
                    this._options = t;
                    this._referenceCoordinates = null
                }
                begin(t, e, n) {
                    const i = new yh(e);
                    this.activeHandlePosition = JC(t);
                    this._referenceCoordinates = GC(e, QC(this.activeHandlePosition));
                    this.originalWidth = i.width;
                    this.originalHeight = i.height;
                    this.aspectRatio = i.width / i.height;
                    const o = n.style.width;
                    if (o && o.match(/^\d+\.?\d*%$/)) {
                        this.originalWidthPercents = parseFloat(o)
                    } else {
                        this.originalWidthPercents = $C(n, i)
                    }
                }
                update(t) {
                    this.proposedWidth = t.width;
                    this.proposedHeight = t.height;
                    this.proposedWidthPercents = t.widthPercents;
                    this.proposedHandleHostWidth = t.handleHostWidth;
                    this.proposedHandleHostHeight = t.handleHostHeight
                }
            }
            vr(UC, Jc);
            function $C(t, e) {
                const n = t.parentElement;
                const i = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width);
                return e.width / i * 100
            }
            function GC(t, e) {
                const n = new yh(t);
                const i = e.split("-");
                const o = {
                    x: i[1] == "right" ? n.right : n.left,
                    y: i[0] == "bottom" ? n.bottom : n.top
                };
                o.x += t.ownerDocument.defaultView.scrollX;
                o.y += t.ownerDocument.defaultView.scrollY;
                return o
            }
            function KC(t) {
                return `ck-widget__resizer__handle-${t}`
            }
            function JC(t) {
                const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                for (const n of e) {
                    if (t.classList.contains(KC(n))) {
                        return n
                    }
                }
            }
            function QC(t) {
                const e = t.split("-");
                const n = {
                    top: "bottom",
                    bottom: "top",
                    left: "right",
                    right: "left"
                };
                return `${n[e[0]]}-${n[e[1]]}`
            }
            class YC {
                constructor(t) {
                    this._options = t;
                    this._domResizerWrapper = null;
                    this._viewResizerWrapper = null;
                    this.set("isEnabled", true);
                    this.decorate("begin");
                    this.decorate("cancel");
                    this.decorate("commit");
                    this.decorate("updateSize");
                    this.on("commit", t => {
                        if (!this.state.proposedWidth) {
                            this._cleanup();
                            t.stop()
                        }
                    }
                        , {
                            priority: "high"
                        })
                }
                attach() {
                    const t = this;
                    const e = this._options.viewElement;
                    const n = this._options.editor.editing.view;
                    n.change(n => {
                        const i = n.createUIElement("div", {
                            class: "ck ck-reset_all ck-widget__resizer"
                        }, (function (e) {
                            const n = this.toDomElement(e);
                            t._appendHandles(n);
                            t._appendSizeUI(n);
                            t._domResizerWrapper = n;
                            t.on("change:isEnabled", (t, e, i) => {
                                n.style.display = i ? "" : "none"
                            }
                            );
                            n.style.display = t.isEnabled ? "" : "none";
                            return n
                        }
                        ));
                        n.insert(n.createPositionAt(e, "end"), i);
                        n.addClass("ck-widget_with-resizer", e);
                        this._viewResizerWrapper = i
                    }
                    )
                }
                begin(t) {
                    this.state = new UC(this._options);
                    this._sizeUI.bindToState(this._options, this.state);
                    this.state.begin(t, this._getHandleHost(), this._getResizeHost())
                }
                updateSize(t) {
                    const e = this._proposeNewSize(t);
                    const n = this._options.editor.editing.view;
                    n.change(t => {
                        const n = this._options.unit;
                        const i = (n === "%" ? e.widthPercents : e.width) + n;
                        t.setStyle("width", i, this._options.viewElement)
                    }
                    );
                    const i = this._getHandleHost();
                    const o = new yh(i);
                    e.handleHostWidth = Math.round(o.width);
                    e.handleHostHeight = Math.round(o.height);
                    const s = new yh(i);
                    e.width = Math.round(s.width);
                    e.height = Math.round(s.height);
                    this.redraw(o);
                    this.state.update(e)
                }
                commit() {
                    const t = this._options.unit;
                    const e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + this._options.unit;
                    this._options.onCommit(e);
                    this._cleanup()
                }
                cancel() {
                    this._cleanup()
                }
                destroy() {
                    this.cancel()
                }
                redraw(t) {
                    const e = this._domResizerWrapper;
                    if (n(e)) {
                        this._options.editor.editing.view.change(n => {
                            const i = e.parentElement;
                            const o = this._getHandleHost();
                            const s = t || new yh(o);
                            n.setStyle("width", s.width + "px", this._viewResizerWrapper);
                            n.setStyle("height", s.height + "px", this._viewResizerWrapper);
                            const r = {
                                left: o.offsetLeft,
                                top: o.offsetTop,
                                height: o.offsetHeight,
                                width: o.offsetWidth
                            };
                            if (!i.isSameNode(o)) {
                                n.setStyle("left", r.left + "px", this._viewResizerWrapper);
                                n.setStyle("top", r.top + "px", this._viewResizerWrapper);
                                n.setStyle("height", r.height + "px", this._viewResizerWrapper);
                                n.setStyle("width", r.width + "px", this._viewResizerWrapper)
                            }
                        }
                        )
                    }
                    function n(t) {
                        return t && t.ownerDocument && t.ownerDocument.contains(t)
                    }
                }
                containsHandle(t) {
                    return this._domResizerWrapper.contains(t)
                }
                static isResizeHandle(t) {
                    return t.classList.contains("ck-widget__resizer__handle")
                }
                _cleanup() {
                    this._sizeUI.dismiss();
                    this._sizeUI.isVisible = false
                }
                _proposeNewSize(t) {
                    const e = this.state;
                    const n = tA(t);
                    const i = this._options.isCentered ? this._options.isCentered(this) : true;
                    const o = {
                        x: e._referenceCoordinates.x - (n.x + e.originalWidth),
                        y: n.y - e.originalHeight - e._referenceCoordinates.y
                    };
                    if (i && e.activeHandlePosition.endsWith("-right")) {
                        o.x = n.x - (e._referenceCoordinates.x + e.originalWidth)
                    }
                    if (i) {
                        o.x *= 2
                    }
                    const s = {
                        width: Math.abs(e.originalWidth + o.x),
                        height: Math.abs(e.originalHeight + o.y)
                    };
                    s.dominant = s.width / e.aspectRatio > s.height ? "width" : "height";
                    s.max = s[s.dominant];
                    const r = {
                        width: s.width,
                        height: s.height
                    };
                    if (s.dominant == "width") {
                        r.height = r.width / e.aspectRatio
                    } else {
                        r.width = r.height * e.aspectRatio
                    }
                    return {
                        width: Math.round(r.width),
                        height: Math.round(r.height),
                        widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * r.width * 100) / 100, 100)
                    }
                }
                _getResizeHost() {
                    const t = this._domResizerWrapper.parentElement;
                    return this._options.getResizeHost(t)
                }
                _getHandleHost() {
                    const t = this._domResizerWrapper.parentElement;
                    return this._options.getHandleHost(t)
                }
                _appendHandles(t) {
                    const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                    for (const n of e) {
                        t.appendChild(new qm({
                            tag: "div",
                            attributes: {
                                class: `ck-widget__resizer__handle ${ZC(n)}`
                            }
                        }).render())
                    }
                }
                _appendSizeUI(t) {
                    const e = new XC;
                    e.render();
                    this._sizeUI = e;
                    t.appendChild(e.element)
                }
                _getHandlePosition(t) {
                    const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                    for (const n of e) {
                        if (t.classList.contains(ZC(n))) {
                            return n
                        }
                    }
                }
            }
            vr(YC, Jc);
            class XC extends mb {
                constructor() {
                    super();
                    const t = this.bindTemplate;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-size-view", t.to("activeHandlePosition", t => t ? `ck-orientation-${t}` : "")],
                            style: {
                                display: t.if("isVisible", "none", t => !t)
                            }
                        },
                        children: [{
                            text: t.to("label")
                        }]
                    })
                }
                bindToState(t, e) {
                    this.bind("isVisible").to(e, "proposedWidth", e, "proposedHeight", (t, e) => t !== null && e !== null);
                    this.bind("label").to(e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", e, "proposedWidthPercents", (e, n, i) => {
                        if (t.unit === "px") {
                            return `${e}×${n}`
                        } else {
                            return `${i}%`
                        }
                    }
                    );
                    this.bind("activeHandlePosition").to(e)
                }
                dismiss() {
                    this.unbind();
                    this.isVisible = false
                }
            }
            function ZC(t) {
                return `ck-widget__resizer__handle-${t}`
            }
            function tA(t) {
                return {
                    x: t.pageX,
                    y: t.pageY
                }
            }
            var eA = "Expected a function";
            function nA(t, e, n) {
                var i = true
                    , o = true;
                if (typeof t != "function") {
                    throw new TypeError(eA)
                }
                if (ct(n)) {
                    i = "leading" in n ? !!n.leading : i;
                    o = "trailing" in n ? !!n.trailing : o
                }
                return hh(t, e, {
                    leading: i,
                    maxWait: e,
                    trailing: o
                })
            }
            var iA = nA;
            var oA = n(80);
            class sA extends Nw {
                static get pluginName() {
                    return "WidgetResize"
                }
                init() {
                    this.set("_visibleResizer", null);
                    this.set("_activeResizer", null);
                    this._resizers = new Map;
                    const t = Nd.window.document;
                    this.editor.model.schema.setAttributeProperties("width", {
                        isFormatting: true
                    });
                    this._observer = Object.create(Ud);
                    this._observer.listenTo(t, "mousedown", (t, e) => {
                        if (!YC.isResizeHandle(e.target)) {
                            return
                        }
                        const n = e.target;
                        this._activeResizer = this._getResizerByHandle(n);
                        if (this._activeResizer) {
                            this._activeResizer.begin(n)
                        }
                    }
                    );
                    this._observer.listenTo(t, "mousemove", (t, e) => {
                        if (this._activeResizer) {
                            this._activeResizer.updateSize(e)
                        }
                    }
                    );
                    this._observer.listenTo(t, "mouseup", () => {
                        if (this._activeResizer) {
                            this._activeResizer.commit();
                            this._activeResizer = null
                        }
                    }
                    );
                    const e = () => {
                        if (this._visibleResizer) {
                            this._visibleResizer.redraw()
                        }
                    }
                        ;
                    const n = iA(e, 200);
                    this.on("change:_visibleResizer", e);
                    this.editor.ui.on("update", n);
                    this._observer.listenTo(Nd.window, "resize", n);
                    const i = this.editor.editing.view.document.selection;
                    i.on("change", () => {
                        const t = i.getSelectedElement();
                        this._visibleResizer = this._getResizerByViewElement(t) || null
                    }
                    )
                }
                destroy() {
                    this._observer.stopListening()
                }
                attachTo(t) {
                    const e = new YC(t);
                    const n = this.editor.plugins;
                    e.attach();
                    if (n.has("WidgetToolbarRepository")) {
                        const t = n.get("WidgetToolbarRepository");
                        e.on("begin", () => {
                            t.forceDisabled("resize")
                        }
                            , {
                                priority: "lowest"
                            });
                        e.on("cancel", () => {
                            t.clearForceDisabled("resize")
                        }
                            , {
                                priority: "highest"
                            });
                        e.on("commit", () => {
                            t.clearForceDisabled("resize")
                        }
                            , {
                                priority: "highest"
                            })
                    }
                    this._resizers.set(t.viewElement, e);
                    return e
                }
                _getResizerByHandle(t) {
                    for (const e of this._resizers.values()) {
                        if (e.containsHandle(t)) {
                            return e
                        }
                    }
                }
                _getResizerByViewElement(t) {
                    return this._resizers.get(t)
                }
            }
            vr(sA, Jc);
            class rA extends Fw {
                refresh() {
                    const t = this.editor.model.document.selection.getSelectedElement();
                    this.isEnabled = Lk(t);
                    if (!t || !t.hasAttribute("width")) {
                        this.value = null
                    } else {
                        this.value = {
                            width: t.getAttribute("width"),
                            height: null
                        }
                    }
                }
                execute(t) {
                    const e = this.editor.model;
                    const n = e.document.selection.getSelectedElement();
                    e.change(e => {
                        e.setAttribute("width", t.width, n)
                    }
                    )
                }
            }
            var aA = n(82);
            class cA extends Nw {
                static get requires() {
                    return [sA]
                }
                static get pluginName() {
                    return "ImageResize"
                }
                init() {
                    const t = this.editor;
                    const e = new rA(t);
                    this._registerSchema();
                    this._registerConverters();
                    t.commands.add("imageResize", e);
                    t.editing.downcastDispatcher.on("insert:image", (n, i, o) => {
                        const s = o.mapper.toViewElement(i.item);
                        const r = t.plugins.get(sA).attachTo({
                            unit: t.config.get("image.resizeUnit") || "%",
                            modelElement: i.item,
                            viewElement: s,
                            editor: t,
                            getHandleHost(t) {
                                return t.querySelector("img")
                            },
                            getResizeHost(t) {
                                return t
                            },
                            isCentered() {
                                const t = i.item.getAttribute("imageStyle");
                                return !t || t == "full" || t == "alignCenter"
                            },
                            onCommit(e) {
                                t.execute("imageResize", {
                                    width: e
                                })
                            }
                        });
                        r.on("updateSize", () => {
                            if (!s.hasClass("image_resized")) {
                                t.editing.view.change(t => {
                                    t.addClass("image_resized", s)
                                }
                                )
                            }
                        }
                        );
                        r.bind("isEnabled").to(e)
                    }
                        , {
                            priority: "low"
                        })
                }
                _registerSchema() {
                    this.editor.model.schema.extend("image", {
                        allowAttributes: "width"
                    })
                }
                _registerConverters() {
                    const t = this.editor;
                    t.conversion.for("downcast").add(t => t.on("attribute:width:image", (t, e, n) => {
                        if (!n.consumable.consume(e.item, t.name)) {
                            return
                        }
                        const i = n.writer;
                        const o = n.mapper.toViewElement(e.item);
                        if (e.attributeNewValue !== null) {
                            i.setStyle("width", e.attributeNewValue, o);
                            i.addClass("image_resized", o)
                        } else {
                            i.removeStyle("width", o);
                            i.removeClass("image_resized", o)
                        }
                    }
                    ));
                    t.conversion.for("upcast").attributeToAttribute({
                        view: {
                            name: "figure",
                            styles: {
                                width: /.+/
                            }
                        },
                        model: {
                            key: "width",
                            value: t => t.getStyle("width")
                        }
                    })
                }
            }
            class lA extends Nw {
                static get requires() {
                    return [Q_]
                }
                static get pluginName() {
                    return "SimpleUploadAdapter"
                }
                init() {
                    const t = this.editor.config.get("simpleUpload");
                    if (!t) {
                        return
                    }
                    if (!t.uploadUrl) {
                        console.warn(Object(rr["a"])('simple-upload-adapter-missing-uploadUrl: Missing the "uploadUrl" property in the "simpleUpload" editor configuration.'));
                        return
                    }
                    this.editor.plugins.get(Q_).createUploadAdapter = e => new dA(e, t)
                }
            }
            class dA {
                constructor(t, e) {
                    this.loader = t;
                    this.options = e
                }
                upload() {
                    return this.loader.file.then(t => new Promise((e, n) => {
                        this._initRequest();
                        this._initListeners(e, n, t);
                        this._sendRequest(t)
                    }
                    ))
                }
                abort() {
                    if (this.xhr) {
                        this.xhr.abort()
                    }
                }
                _initRequest() {
                    const t = this.xhr = new XMLHttpRequest;
                    t.open("POST", this.options.uploadUrl, true);
                    t.responseType = "json"
                }
                _initListeners(t, e, n) {
                    const i = this.xhr;
                    const o = this.loader;
                    const s = `Couldn't upload file: ${n.name}.`;
                    i.addEventListener("error", () => e(s));
                    i.addEventListener("abort", () => e());
                    i.addEventListener("load", () => {
                        const n = i.response;
                        if (!n || n.error) {
                            return e(n && n.error && n.error.message ? n.error.message : s)
                        }
                        t(n.url ? {
                            default: n.url
                        } : n.urls)
                    }
                    );
                    if (i.upload) {
                        i.upload.addEventListener("progress", t => {
                            if (t.lengthComputable) {
                                o.uploadTotal = t.total;
                                o.uploaded = t.loaded
                            }
                        }
                        )
                    }
                }
                _sendRequest(t) {
                    const e = this.options.headers || {};
                    for (const t of Object.keys(e)) {
                        this.xhr.setRequestHeader(t, e[t])
                    }
                    const n = new FormData;
                    n.append("upload", t);
                    this.xhr.send(n)
                }
            }
            function* uA(t, e) {
                for (const n of e) {
                    if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
                        yield n
                    }
                }
            }
            class hA extends Fw {
                execute() {
                    const t = this.editor.model;
                    const e = t.document;
                    t.change(n => {
                        pA(t, n, e.selection);
                        this.fire("afterExecute", {
                            writer: n
                        })
                    }
                    )
                }
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    this.isEnabled = fA(t.schema, e.selection)
                }
            }
            function fA(t, e) {
                if (e.rangeCount > 1) {
                    return false
                }
                const n = e.anchor;
                if (!n || !t.checkChild(n, "softBreak")) {
                    return false
                }
                const i = e.getFirstRange();
                const o = i.start.parent;
                const s = i.end.parent;
                if ((mA(o, t) || mA(s, t)) && o !== s) {
                    return false
                }
                return true
            }
            function pA(t, e, n) {
                const i = n.isCollapsed;
                const o = n.getFirstRange();
                const s = o.start.parent;
                const r = o.end.parent;
                const a = s == r;
                if (i) {
                    const i = uA(t.schema, n.getAttributes());
                    gA(t, e, o.end);
                    e.removeSelectionAttribute(n.getAttributeKeys());
                    e.setSelectionAttribute(i)
                } else {
                    const i = !(o.start.isAtStart && o.end.isAtEnd);
                    t.deleteContent(n, {
                        leaveUnmerged: i
                    });
                    if (a) {
                        gA(t, e, n.focus)
                    } else {
                        if (i) {
                            e.setSelection(r, 0)
                        }
                    }
                }
            }
            function gA(t, e, n) {
                const i = e.createElement("softBreak");
                t.insertContent(i, n);
                e.setSelection(i, "after")
            }
            function mA(t, e) {
                if (t.is("rootElement")) {
                    return false
                }
                return e.isLimit(t) || mA(t.parent, e)
            }
            class bA extends Kd {
                constructor(t) {
                    super(t);
                    const e = this.document;
                    e.on("keydown", (t, n) => {
                        if (this.isEnabled && n.keyCode == Vl.enter) {
                            let i;
                            e.once("enter", t => i = t, {
                                priority: "highest"
                            });
                            e.fire("enter", new Ju(e, n.domEvent, {
                                isSoft: n.shiftKey
                            }));
                            if (i && i.stop.called) {
                                t.stop()
                            }
                        }
                    }
                    )
                }
                observe() { }
            }
            class wA extends Nw {
                static get pluginName() {
                    return "ShiftEnter"
                }
                init() {
                    const t = this.editor;
                    const e = t.model.schema;
                    const n = t.conversion;
                    const i = t.editing.view;
                    const o = i.document;
                    e.register("softBreak", {
                        allowWhere: "$text",
                        isInline: true
                    });
                    n.for("upcast").elementToElement({
                        model: "softBreak",
                        view: "br"
                    });
                    n.for("downcast").elementToElement({
                        model: "softBreak",
                        view: (t, e) => e.createEmptyElement("br")
                    });
                    i.addObserver(bA);
                    t.commands.add("shiftEnter", new hA(t));
                    this.listenTo(o, "enter", (e, n) => {
                        n.preventDefault();
                        if (!n.isSoft) {
                            return
                        }
                        t.execute("shiftEnter");
                        i.scrollToTheSelection()
                    }
                        , {
                            priority: "low"
                        })
                }
            }
            function kA(t) {
                const e = t.t;
                const n = t.config.get("codeBlock.languages");
                for (const t of n) {
                    if (t.label === "Plain text") {
                        t.label = e("bp")
                    }
                    if (t.class === undefined) {
                        t.class = `language-${t.language}`
                    }
                }
                return n
            }
            function _A(t, e, n) {
                const i = {};
                for (const o of t) {
                    if (e === "class") {
                        i[o[e].split(" ").shift()] = o[n]
                    } else {
                        i[o[e]] = o[n]
                    }
                }
                return i
            }
            function vA(t) {
                return t.data.match(/^(\s*)/)[0]
            }
            function yA(t, e) {
                const n = t.createDocumentFragment();
                const i = e.split("\n").map(e => t.createText(e));
                const o = i[i.length - 1];
                for (const e of i) {
                    t.append(e, n);
                    if (e !== o) {
                        t.appendElement("softBreak", n)
                    }
                }
                return n
            }
            function xA(t) {
                const e = t.document.selection;
                const n = [];
                if (e.isCollapsed) {
                    n.push(e.anchor)
                } else {
                    const i = e.getFirstRange().getWalker({
                        ignoreElementEnd: true,
                        direction: "backward"
                    });
                    for (const { item: e } of i) {
                        if (e.is("textProxy") && e.parent.is("codeBlock")) {
                            const i = vA(e.textNode);
                            const { parent: o, startOffset: s } = e.textNode;
                            const r = t.createPositionAt(o, s + i.length);
                            n.push(r)
                        }
                    }
                }
                return n
            }
            function CA(t) {
                const e = zw(t.getSelectedBlocks());
                return e && e.is("codeBlock")
            }
            class AA extends Fw {
                refresh() {
                    this.value = this._getValue();
                    this.isEnabled = this._checkEnabled()
                }
                execute(t = {}) {
                    const e = this.editor;
                    const n = e.model;
                    const i = n.document.selection;
                    const o = kA(e);
                    const s = o[0];
                    const r = Array.from(i.getSelectedBlocks());
                    const a = t.forceValue === undefined ? !this.value : t.forceValue;
                    const c = t.language || s.language;
                    n.change(t => {
                        if (a) {
                            this._applyCodeBlock(t, r, c)
                        } else {
                            this._removeCodeBlock(t, r)
                        }
                    }
                    )
                }
                _getValue() {
                    const t = this.editor.model.document.selection;
                    const e = zw(t.getSelectedBlocks());
                    const n = !!(e && e.is("codeBlock"));
                    return n ? e.getAttribute("language") : false
                }
                _checkEnabled() {
                    if (this.value) {
                        return true
                    }
                    const t = this.editor.model.document.selection;
                    const e = this.editor.model.schema;
                    const n = zw(t.getSelectedBlocks());
                    if (!n) {
                        return false
                    }
                    return PA(e, n)
                }
                _applyCodeBlock(t, e, n) {
                    const i = this.editor.model.schema;
                    const o = e.filter(t => PA(i, t));
                    for (const e of o) {
                        t.rename(e, "codeBlock");
                        t.setAttribute("language", n, e);
                        i.removeDisallowedAttributes([e], t)
                    }
                    o.reverse().forEach((e, n) => {
                        const i = o[n + 1];
                        if (e.previousSibling === i) {
                            t.appendElement("softBreak", i);
                            t.merge(t.createPositionBefore(e))
                        }
                    }
                    )
                }
                _removeCodeBlock(t, e) {
                    const n = e.filter(t => t.is("codeBlock"));
                    for (const e of n) {
                        const n = t.createRangeOn(e);
                        for (const e of Array.from(n.getItems()).reverse()) {
                            if (e.is("softBreak") && e.parent.is("codeBlock")) {
                                const { position: n } = t.split(t.createPositionBefore(e));
                                t.rename(n.nodeAfter, "paragraph");
                                t.removeAttribute("language", n.nodeAfter);
                                t.remove(e)
                            }
                        }
                        t.rename(e, "paragraph");
                        t.removeAttribute("language", e)
                    }
                }
            }
            function PA(t, e) {
                if (e.is("rootElement") || t.isLimit(e)) {
                    return false
                }
                return t.checkChild(e.parent, "codeBlock")
            }
            class TA extends Fw {
                constructor(t) {
                    super(t);
                    this._indentSequence = t.config.get("codeBlock.indentSequence")
                }
                refresh() {
                    this.isEnabled = this._checkEnabled()
                }
                execute() {
                    const t = this.editor;
                    const e = t.model;
                    e.change(t => {
                        const n = xA(e);
                        for (const e of n) {
                            t.insertText(this._indentSequence, e)
                        }
                    }
                    )
                }
                _checkEnabled() {
                    if (!this._indentSequence) {
                        return false
                    }
                    return CA(this.editor.model.document.selection)
                }
            }
            class SA extends Fw {
                constructor(t) {
                    super(t);
                    this._indentSequence = t.config.get("codeBlock.indentSequence")
                }
                refresh() {
                    this.isEnabled = this._checkEnabled()
                }
                execute() {
                    const t = this.editor;
                    const e = t.model;
                    e.change(t => {
                        const n = xA(e);
                        for (const e of n) {
                            const n = EA(this.editor.model, e, this._indentSequence);
                            if (n) {
                                t.remove(n)
                            }
                        }
                    }
                    )
                }
                _checkEnabled() {
                    if (!this._indentSequence) {
                        return false
                    }
                    const t = this.editor.model;
                    if (!CA(t.document.selection)) {
                        return false
                    }
                    return xA(t).some(e => EA(t, e, this._indentSequence))
                }
            }
            function EA(t, e, n) {
                const i = RA(e);
                if (!i) {
                    return null
                }
                const o = vA(i);
                const s = o.lastIndexOf(n);
                if (s + n.length !== o.length) {
                    return null
                }
                if (s === -1) {
                    return null
                }
                const { parent: r, startOffset: a } = i;
                return t.createRange(t.createPositionAt(r, a + s), t.createPositionAt(r, a + s + n.length))
            }
            function RA(t) {
                let e = t.parent.getChild(t.index);
                if (!e || e.is("softBreak")) {
                    e = t.nodeBefore
                }
                if (!e || e.is("softBreak")) {
                    return null
                }
                return e
            }
            function OA(t, e, n = false) {
                const i = _A(e, "language", "class");
                const o = _A(e, "language", "label");
                return (e, s, r) => {
                    const { writer: a, mapper: c, consumable: l } = r;
                    if (!l.consume(s.item, "insert")) {
                        return
                    }
                    const d = s.item.getAttribute("language");
                    const u = c.toViewPosition(t.createPositionBefore(s.item));
                    const h = {};
                    if (n) {
                        h["data-language"] = o[d];
                        h.spellcheck = "false"
                    }
                    const f = a.createContainerElement("pre", h);
                    const p = a.createContainerElement("code", {
                        class: i[d] || null
                    });
                    a.insert(a.createPositionAt(f, 0), p);
                    a.insert(u, f);
                    c.bindElements(s.item, p)
                }
            }
            function MA(t) {
                return (e, n, i) => {
                    if (n.item.parent.name !== "codeBlock") {
                        return
                    }
                    const { writer: o, mapper: s, consumable: r } = i;
                    if (!r.consume(n.item, "insert")) {
                        return
                    }
                    const a = s.toViewPosition(t.createPositionBefore(n.item));
                    o.insert(a, o.createText("\n"))
                }
            }
            function NA(t, e) {
                const n = _A(e, "class", "language");
                const i = e[0].language;
                return (e, o, s) => {
                    const r = o.viewItem;
                    const a = r.getChild(0);
                    if (!a || !a.is("code")) {
                        return
                    }
                    const { consumable: c, writer: l } = s;
                    if (!c.test(r, {
                        name: true
                    }) || !c.test(a, {
                        name: true
                    })) {
                        return
                    }
                    const d = l.createElement("codeBlock");
                    const u = [...a.getClassNames()];
                    if (!u.length) {
                        u.push("")
                    }
                    for (const t of u) {
                        const e = n[t];
                        if (e) {
                            l.setAttribute("language", e, d);
                            break
                        }
                    }
                    if (!d.hasAttribute("language")) {
                        l.setAttribute("language", i, d)
                    }
                    const h = t.processor.toData(a);
                    const f = IA(h);
                    const p = yA(l, f);
                    l.append(p, d);
                    const g = s.splitToAllowedParent(d, o.modelCursor);
                    if (!g) {
                        return
                    }
                    l.insert(d, g.position);
                    c.consume(r, {
                        name: true
                    });
                    c.consume(a, {
                        name: true
                    });
                    const m = s.getSplitParts(d);
                    o.modelRange = l.createRange(s.writer.createPositionBefore(d), s.writer.createPositionAfter(m[m.length - 1]));
                    if (g.cursorParent) {
                        o.modelCursor = l.createPositionAt(g.cursorParent, 0)
                    } else {
                        o.modelCursor = o.modelRange.end
                    }
                }
            }
            function IA(t) {
                const e = new RegExp(/^<code[^>]*>([\S\s]*)<\/code>$/).exec(t)[1];
                return e.replace(/&lt;/g, "<").replace(/&gt;/g, ">")
            }
            const VA = "paragraph";
            class BA extends Nw {
                static get pluginName() {
                    return "CodeBlockEditing"
                }
                static get requires() {
                    return [wA]
                }
                constructor(t) {
                    super(t);
                    t.config.define("codeBlock", {
                        languages: [{
                            language: "plaintext",
                            label: "Plain text"
                        }, {
                            language: "c",
                            label: "C"
                        }, {
                            language: "cs",
                            label: "C#"
                        }, {
                            language: "cpp",
                            label: "C++"
                        }, {
                            language: "css",
                            label: "CSS"
                        }, {
                            language: "diff",
                            label: "Diff"
                        }, {
                            language: "xml",
                            label: "HTML/XML"
                        }, {
                            language: "java",
                            label: "Java"
                        }, {
                            language: "javascript",
                            label: "JavaScript"
                        }, {
                            language: "php",
                            label: "PHP"
                        }, {
                            language: "python",
                            label: "Python"
                        }, {
                            language: "ruby",
                            label: "Ruby"
                        }, {
                            language: "typescript",
                            label: "TypeScript"
                        }],
                        indentSequence: "\t"
                    })
                }
                init() {
                    const t = this.editor;
                    const e = t.model.schema;
                    const n = t.model;
                    const i = kA(t);
                    t.commands.add("codeBlock", new AA(t));
                    t.commands.add("indentCodeBlock", new TA(t));
                    t.commands.add("outdentCodeBlock", new SA(t));
                    const o = t => (e, n) => {
                        const i = this.editor.commands.get(t);
                        if (i.isEnabled) {
                            this.editor.execute(t);
                            n()
                        }
                    }
                        ;
                    t.keystrokes.set("Tab", o("indentCodeBlock"));
                    t.keystrokes.set("Shift+Tab", o("outdentCodeBlock"));
                    e.register("codeBlock", {
                        allowWhere: "$block",
                        isBlock: true,
                        allowAttributes: ["language"]
                    });
                    e.extend("$text", {
                        allowIn: "codeBlock"
                    });
                    e.addAttributeCheck(t => {
                        if (t.endsWith("codeBlock $text")) {
                            return false
                        }
                    }
                    );
                    t.editing.downcastDispatcher.on("insert:codeBlock", OA(n, i, true));
                    t.data.downcastDispatcher.on("insert:codeBlock", OA(n, i));
                    t.data.downcastDispatcher.on("insert:softBreak", MA(n), {
                        priority: "high"
                    });
                    t.data.upcastDispatcher.on("element:pre", NA(t.data, i));
                    this.listenTo(t.editing.view.document, "clipboardInput", (t, e) => {
                        const i = n.document.selection;
                        if (!i.anchor.parent.is("codeBlock")) {
                            return
                        }
                        const o = e.dataTransfer.getData("text/plain");
                        n.change(e => {
                            n.insertContent(yA(e, o), i);
                            t.stop()
                        }
                        )
                    }
                    );
                    this.listenTo(n, "getSelectedContent", (t, [i]) => {
                        const o = i.anchor;
                        if (i.isCollapsed || !o.parent.is("codeBlock") || !o.hasSameParentAs(i.focus)) {
                            return
                        }
                        n.change(n => {
                            const s = t.return;
                            if (s.childCount > 1 || i.containsEntireContent(o.parent)) {
                                const e = n.createElement("codeBlock", o.parent.getAttributes());
                                n.append(s, e);
                                const i = n.createDocumentFragment();
                                n.append(e, i);
                                t.return = i
                            } else {
                                const t = s.getChild(0);
                                if (e.checkAttribute(t, "code")) {
                                    n.setAttribute("code", true, t)
                                }
                            }
                        }
                        )
                    }
                    )
                }
                afterInit() {
                    const t = this.editor;
                    const e = t.commands;
                    const n = e.get("indent");
                    const i = e.get("outdent");
                    if (n) {
                        n.registerChildCommand(e.get("indentCodeBlock"))
                    }
                    if (i) {
                        i.registerChildCommand(e.get("outdentCodeBlock"))
                    }
                    this.listenTo(t.editing.view.document, "enter", (e, n) => {
                        const i = t.model.document.selection.getLastPosition().parent;
                        if (!i.is("codeBlock")) {
                            return
                        }
                        DA(t, n.isSoft) || zA(t, n.isSoft) || FA(t);
                        n.preventDefault();
                        e.stop()
                    }
                    )
                }
            }
            function FA(t) {
                const e = t.model;
                const n = e.document;
                const i = n.selection.getLastPosition();
                const o = i.nodeBefore || i.textNode;
                let s;
                if (o && o.is("text")) {
                    s = vA(o)
                }
                t.model.change(e => {
                    t.execute("shiftEnter");
                    if (s) {
                        e.insertText(s, n.selection.anchor)
                    }
                }
                )
            }
            function DA(t, e) {
                const n = t.model;
                const i = n.document;
                const o = t.editing.view;
                const s = i.selection.getLastPosition();
                const r = s.nodeAfter;
                if (e || !i.selection.isCollapsed || !s.isAtStart) {
                    return false
                }
                if (!r || !r.is("softBreak")) {
                    return false
                }
                t.model.change(e => {
                    t.execute("enter");
                    const n = i.selection.anchor.parent.previousSibling;
                    e.rename(n, VA);
                    e.setSelection(n, "in");
                    t.model.schema.removeDisallowedAttributes([n], e);
                    e.remove(r)
                }
                );
                o.scrollToTheSelection();
                return true
            }
            function zA(t, e) {
                const n = t.model;
                const i = n.document;
                const o = t.editing.view;
                const s = i.selection.getLastPosition();
                const r = s.nodeBefore;
                let a;
                if (e || !i.selection.isCollapsed || !s.isAtEnd || !r) {
                    return false
                }
                if (r.is("softBreak")) {
                    a = n.createRangeOn(r)
                } else if (r.is("text") && !r.data.match(/\S/) && r.previousSibling && r.previousSibling.is("softBreak")) {
                    a = n.createRange(n.createPositionBefore(r.previousSibling), n.createPositionAfter(r))
                } else {
                    return false
                }
                t.model.change(e => {
                    e.remove(a);
                    t.execute("enter");
                    const n = i.selection.anchor.parent;
                    e.rename(n, VA);
                    t.model.schema.removeDisallowedAttributes([n], e)
                }
                );
                o.scrollToTheSelection();
                return true
            }
            var LA = n(84);
            class jA extends mb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("icon");
                    this.set("isEnabled", true);
                    this.set("isOn", false);
                    this.set("isToggleable", false);
                    this.set("isVisible", true);
                    this.set("keystroke");
                    this.set("label");
                    this.set("tabindex", -1);
                    this.set("tooltip");
                    this.set("tooltipPosition", "s");
                    this.set("type", "button");
                    this.set("withText", false);
                    this.children = this.createCollection();
                    this.actionView = this._createActionView();
                    this.arrowView = this._createArrowView();
                    this.keystrokes = new um;
                    this.focusTracker = new Cm;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-splitbutton", e.if("isVisible", "ck-hidden", t => !t), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]
                        },
                        children: this.children
                    })
                }
                render() {
                    super.render();
                    this.children.add(this.actionView);
                    this.children.add(this.arrowView);
                    this.focusTracker.add(this.actionView.element);
                    this.focusTracker.add(this.arrowView.element);
                    this.keystrokes.listenTo(this.element);
                    this.keystrokes.set("arrowright", (t, e) => {
                        if (this.focusTracker.focusedElement === this.actionView.element) {
                            this.arrowView.focus();
                            e()
                        }
                    }
                    );
                    this.keystrokes.set("arrowleft", (t, e) => {
                        if (this.focusTracker.focusedElement === this.arrowView.element) {
                            this.actionView.focus();
                            e()
                        }
                    }
                    )
                }
                focus() {
                    this.actionView.focus()
                }
                _createActionView() {
                    const t = new Zb;
                    t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
                    t.extendTemplate({
                        attributes: {
                            class: "ck-splitbutton__action"
                        }
                    });
                    t.delegate("execute").to(this);
                    return t
                }
                _createArrowView() {
                    const t = new Zb;
                    const e = t.bindTemplate;
                    t.icon = tw;
                    t.extendTemplate({
                        attributes: {
                            class: "ck-splitbutton__arrow",
                            "aria-haspopup": true,
                            "aria-expanded": e.to("isOn", t => String(t))
                        }
                    });
                    t.bind("isEnabled").to(this);
                    t.delegate("execute").to(this, "open");
                    return t
                }
            }
            var HA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 01-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 01.237.95l-.057.095a.75.75 0 01-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 011.047.174zm2.795-.231l.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 01-.88-.151l-.07-.086-.058-.095a.75.75 0 01.15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 01.862-1.207zM16 0a2 2 0 012 2v9.354l-.663-.492-.837-.001V2a.5.5 0 00-.5-.5H2a.5.5 0 00-.5.5v15a.5.5 0 00.5.5h3.118L7.156 19H2a2 2 0 01-2-2V2a2 2 0 012-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2l-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>';
            var qA = n(86);
            class WA extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.t;
                    const n = t.ui.componentFactory;
                    const i = kA(t);
                    const o = i[0];
                    n.add("codeBlock", n => {
                        const s = t.commands.get("codeBlock");
                        const r = uw(n, jA);
                        const a = r.buttonView;
                        a.set({
                            label: e("z"),
                            tooltip: true,
                            icon: HA,
                            isToggleable: true
                        });
                        a.bind("isOn").to(s, "value", t => !!t);
                        a.on("execute", () => {
                            t.execute("codeBlock", {
                                language: o.language
                            });
                            t.editing.view.focus()
                        }
                        );
                        r.on("execute", e => {
                            t.execute("codeBlock", {
                                language: e.source._codeBlockLanguage,
                                forceValue: true
                            });
                            t.editing.view.focus()
                        }
                        );
                        r.class = "ck-code-block-dropdown";
                        r.bind("isEnabled").to(s);
                        fw(r, this._getLanguageListItemDefinitions(i));
                        return r
                    }
                    )
                }
                _getLanguageListItemDefinitions(t) {
                    const e = this.editor;
                    const n = e.commands.get("codeBlock");
                    const i = new yr;
                    for (const e of t) {
                        const t = {
                            type: "button",
                            model: new uk({
                                _codeBlockLanguage: e.language,
                                label: e.label,
                                withText: true
                            })
                        };
                        t.model.bind("isOn").to(n, "value", e => e === t.model._codeBlockLanguage);
                        i.add(t)
                    }
                    return i
                }
            }
            class UA extends Nw {
                static get requires() {
                    return [BA, WA]
                }
                static get pluginName() {
                    return "CodeBlock"
                }
            }
            class $A extends Fw {
                constructor(t, e) {
                    super(t);
                    this.attributeKey = e
                }
                refresh() {
                    const t = this.editor.model;
                    const e = t.document;
                    this.value = e.selection.getAttribute(this.attributeKey);
                    this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document;
                    const i = n.selection;
                    const o = t.value;
                    e.change(t => {
                        if (i.isCollapsed) {
                            if (o) {
                                t.setSelectionAttribute(this.attributeKey, o)
                            } else {
                                t.removeSelectionAttribute(this.attributeKey)
                            }
                        } else {
                            const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
                            for (const e of n) {
                                if (o) {
                                    t.setAttribute(this.attributeKey, o, e)
                                } else {
                                    t.removeAttribute(this.attributeKey, e)
                                }
                            }
                        }
                    }
                    )
                }
            }
            var GA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 010 2.829l-7.778 7.778a2 2 0 01-2.829 0L3.5 13.107a1.999 1.999 0 112.828-2.829l.707.707a1 1 0 001.414 0l5.658-5.657a2 2 0 012.828 0z"/><path d="M14.814 6.035L8.448 12.4a1 1 0 01-1.414 0l-1.413-1.415A1 1 0 104.207 12.4l2.829 2.829a1 1 0 001.414 0l7.778-7.778a1 1 0 10-1.414-1.415z"/></svg>';
            class KA extends Zb {
                constructor(t) {
                    super(t);
                    const e = this.bindTemplate;
                    this.set("color");
                    this.set("hasBorder");
                    this.icon = GA;
                    this.extendTemplate({
                        attributes: {
                            style: {
                                backgroundColor: e.to("color")
                            },
                            class: ["ck", "ck-color-grid__tile", e.if("hasBorder", "ck-color-table__color-tile_bordered")]
                        }
                    })
                }
                render() {
                    super.render();
                    this.iconView.fillColor = "hsl(0, 0%, 100%)"
                }
            }
            var JA = n(88);
            class QA extends mb {
                constructor(t, e) {
                    super(t);
                    const n = e && e.colorDefinitions || [];
                    const i = {};
                    if (e && e.columns) {
                        i.gridTemplateColumns = `repeat( ${e.columns}, 1fr)`
                    }
                    this.set("selectedColor");
                    this.items = this.createCollection();
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this._focusCycler = new Nb({
                        focusables: this.items,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "arrowleft",
                            focusNext: "arrowright"
                        }
                    });
                    this.items.on("add", (t, e) => {
                        e.isOn = e.color === this.selectedColor
                    }
                    );
                    n.forEach(t => {
                        const e = new KA;
                        e.set({
                            color: t.color,
                            label: t.label,
                            tooltip: true,
                            hasBorder: t.options.hasBorder
                        });
                        e.on("execute", () => {
                            this.fire("execute", {
                                value: t.color,
                                hasBorder: t.options.hasBorder,
                                label: t.label
                            })
                        }
                        );
                        this.items.add(e)
                    }
                    );
                    this.setTemplate({
                        tag: "div",
                        children: this.items,
                        attributes: {
                            class: ["ck", "ck-color-grid"],
                            style: i
                        }
                    });
                    this.on("change:selectedColor", (t, e, n) => {
                        for (const t of this.items) {
                            t.isOn = t.color === n
                        }
                    }
                    )
                }
                focus() {
                    if (this.items.length) {
                        this.items.first.focus()
                    }
                }
                focusLast() {
                    if (this.items.length) {
                        this.items.last.focus()
                    }
                }
                render() {
                    super.render();
                    for (const t of this.items) {
                        this.focusTracker.add(t.element)
                    }
                    this.items.on("add", (t, e) => {
                        this.focusTracker.add(e.element)
                    }
                    );
                    this.items.on("remove", (t, e) => {
                        this.focusTracker.remove(e.element)
                    }
                    );
                    this.keystrokes.listenTo(this.element)
                }
            }
            class YA extends yr {
                constructor(t) {
                    super(t);
                    this.set("isEmpty", true)
                }
                add(t, e) {
                    if (this.find(e => e.color === t.color)) {
                        return
                    }
                    super.add(t, e);
                    this.set("isEmpty", false)
                }
                remove(t) {
                    const e = super.remove(t);
                    if (this.length === 0) {
                        this.set("isEmpty", true)
                    }
                    return e
                }
                hasColor(t) {
                    return !!this.find(e => e.color === t)
                }
            }
            vr(YA, Jc);
            var XA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.636 9.531l-2.758 3.94a.5.5 0 00.122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 01-.491-2.786l6.673-9.53a2 2 0 012.785-.49l3.742 2.62a2 2 0 01.491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
            var ZA = n(90);
            class tP extends mb {
                constructor(t, { colors: e, columns: n, removeButtonLabel: i, documentColorsLabel: o, documentColorsCount: s }) {
                    super(t);
                    this.items = this.createCollection();
                    this.colorDefinitions = e;
                    this.focusTracker = new Cm;
                    this.keystrokes = new um;
                    this.set("selectedColor");
                    this.removeButtonLabel = i;
                    this.columns = n;
                    this.documentColors = new YA;
                    this.documentColorsCount = s;
                    this._focusCycler = new Nb({
                        focusables: this.items,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "arrowup",
                            focusNext: "arrowdown"
                        }
                    });
                    this._documentColorsLabel = o;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-color-table"]
                        },
                        children: this.items
                    });
                    this.items.add(this._removeColorButton())
                }
                updateDocumentColors(t, e) {
                    const n = t.document;
                    const i = this.documentColorsCount;
                    this.documentColors.clear();
                    for (const o of n.getRootNames()) {
                        const s = n.getRoot(o);
                        const r = t.createRangeIn(s);
                        for (const t of r.getItems()) {
                            if (t.is("textProxy") && t.hasAttribute(e)) {
                                this._addColorToDocumentColors(t.getAttribute(e));
                                if (this.documentColors.length >= i) {
                                    return
                                }
                            }
                        }
                    }
                }
                updateSelectedColors() {
                    const t = this.documentColorsGrid;
                    const e = this.staticColorsGrid;
                    const n = this.selectedColor;
                    e.selectedColor = n;
                    if (t) {
                        t.selectedColor = n
                    }
                }
                render() {
                    super.render();
                    for (const t of this.items) {
                        this.focusTracker.add(t.element)
                    }
                    this.keystrokes.listenTo(this.element)
                }
                appendGrids() {
                    if (this.staticColorsGrid) {
                        return
                    }
                    this.staticColorsGrid = this._createStaticColorsGrid();
                    this.items.add(this.staticColorsGrid);
                    if (this.documentColorsCount) {
                        const t = qm.bind(this.documentColors, this.documentColors);
                        const e = new Ab(this.locale);
                        e.text = this._documentColorsLabel;
                        e.extendTemplate({
                            attributes: {
                                class: ["ck", "ck-color-grid__label", t.if("isEmpty", "ck-hidden")]
                            }
                        });
                        this.items.add(e);
                        this.documentColorsGrid = this._createDocumentColorsGrid();
                        this.items.add(this.documentColorsGrid)
                    }
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                focusLast() {
                    this._focusCycler.focusLast()
                }
                _removeColorButton() {
                    const t = new Zb;
                    t.set({
                        withText: true,
                        icon: XA,
                        tooltip: true,
                        label: this.removeButtonLabel
                    });
                    t.class = "ck-color-table__remove-color";
                    t.on("execute", () => {
                        this.fire("execute", {
                            value: null
                        })
                    }
                    );
                    return t
                }
                _createStaticColorsGrid() {
                    const t = new QA(this.locale, {
                        colorDefinitions: this.colorDefinitions,
                        columns: this.columns
                    });
                    t.delegate("execute").to(this);
                    return t
                }
                _createDocumentColorsGrid() {
                    const t = qm.bind(this.documentColors, this.documentColors);
                    const e = new QA(this.locale, {
                        columns: this.columns
                    });
                    e.delegate("execute").to(this);
                    e.extendTemplate({
                        attributes: {
                            class: t.if("isEmpty", "ck-hidden")
                        }
                    });
                    e.items.bindTo(this.documentColors).using(t => {
                        const e = new KA;
                        e.set({
                            color: t.color,
                            hasBorder: t.options && t.options.hasBorder
                        });
                        if (t.label) {
                            e.set({
                                label: t.label,
                                tooltip: true
                            })
                        }
                        e.on("execute", () => {
                            this.fire("execute", {
                                value: t.color
                            })
                        }
                        );
                        return e
                    }
                    );
                    this.documentColors.on("change:isEmpty", (t, n, i) => {
                        if (i) {
                            e.selectedColor = null
                        }
                    }
                    );
                    return e
                }
                _addColorToDocumentColors(t) {
                    const e = this.colorDefinitions.find(e => e.color === t);
                    if (!e) {
                        this.documentColors.add({
                            color: t,
                            label: t,
                            options: {
                                hasBorder: false
                            }
                        })
                    } else {
                        this.documentColors.add(Object.assign({}, e))
                    }
                }
            }
            const eP = "fontSize";
            const nP = "fontFamily";
            const iP = "fontColor";
            const oP = "fontBackgroundColor";
            function sP(t, e) {
                const n = {
                    model: {
                        key: t,
                        values: []
                    },
                    view: {},
                    upcastAlso: {}
                };
                for (const t of e) {
                    n.model.values.push(t.model);
                    n.view[t.model] = t.view;
                    if (t.upcastAlso) {
                        n.upcastAlso[t.model] = t.upcastAlso
                    }
                }
                return n
            }
            function rP(t) {
                return e => lP(e.getStyle(t))
            }
            function aP(t) {
                return (e, n) => n.createAttributeElement("span", {
                    style: `${t}:${e}`
                }, {
                    priority: 7
                })
            }
            function cP({ dropdownView: t, colors: e, columns: n, removeButtonLabel: i, documentColorsLabel: o, documentColorsCount: s }) {
                const r = t.locale;
                const a = new tP(r, {
                    colors: e,
                    columns: n,
                    removeButtonLabel: i,
                    documentColorsLabel: o,
                    documentColorsCount: s
                });
                t.colorTableView = a;
                t.panelView.children.add(a);
                a.delegate("execute").to(t, "execute");
                return a
            }
            function lP(t) {
                return t.replace(/\s/g, "")
            }
            class dP extends $A {
                constructor(t) {
                    super(t, eP)
                }
            }
            function uP(t) {
                return t.map(fP).filter(t => !!t)
            }
            const hP = {
                tiny: {
                    title: "Tiny",
                    model: "tiny",
                    view: {
                        name: "span",
                        classes: "text-tiny",
                        priority: 7
                    }
                },
                small: {
                    title: "Small",
                    model: "small",
                    view: {
                        name: "span",
                        classes: "text-small",
                        priority: 7
                    }
                },
                big: {
                    title: "Big",
                    model: "big",
                    view: {
                        name: "span",
                        classes: "text-big",
                        priority: 7
                    }
                },
                huge: {
                    title: "Huge",
                    model: "huge",
                    view: {
                        name: "span",
                        classes: "text-huge",
                        priority: 7
                    }
                }
            };
            function fP(t) {
                if (typeof t === "object") {
                    return t
                }
                if (hP[t]) {
                    return hP[t]
                }
                if (t === "default") {
                    return {
                        model: undefined,
                        title: "Default"
                    }
                }
                const e = parseFloat(t);
                if (isNaN(e)) {
                    return
                }
                return pP(e)
            }
            function pP(t) {
                const e = String(t);
                return {
                    title: e,
                    model: t,
                    view: {
                        name: "span",
                        styles: {
                            "font-size": `${t}px`
                        },
                        priority: 7
                    }
                }
            }
            class gP extends Nw {
                static get pluginName() {
                    return "FontSizeEditing"
                }
                constructor(t) {
                    super(t);
                    t.config.define(eP, {
                        options: ["tiny", "small", "default", "big", "huge"]
                    });
                    const e = uP(this.editor.config.get("fontSize.options")).filter(t => t.model);
                    const n = sP(eP, e);
                    t.conversion.attributeToElement(n);
                    t.commands.add(eP, new dP(t))
                }
                init() {
                    const t = this.editor;
                    t.model.schema.extend("$text", {
                        allowAttributes: eP
                    });
                    t.model.schema.setAttributeProperties(eP, {
                        isFormatting: true,
                        copyOnEnter: true
                    })
                }
            }
            var mP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5L7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279l.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
            var bP = n(92);
            class wP extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.t;
                    const n = this._getLocalizedOptions();
                    const i = t.commands.get(eP);
                    t.ui.componentFactory.add(eP, o => {
                        const s = uw(o);
                        fw(s, kP(n, i));
                        s.buttonView.set({
                            label: e("ao"),
                            icon: mP,
                            tooltip: true
                        });
                        s.extendTemplate({
                            attributes: {
                                class: ["ck-font-size-dropdown"]
                            }
                        });
                        s.bind("isEnabled").to(i);
                        this.listenTo(s, "execute", e => {
                            t.execute(e.source.commandName, {
                                value: e.source.commandParam
                            });
                            t.editing.view.focus()
                        }
                        );
                        return s
                    }
                    )
                }
                _getLocalizedOptions() {
                    const t = this.editor;
                    const e = t.t;
                    const n = {
                        Default: e("ap"),
                        Tiny: e("aq"),
                        Small: e("ar"),
                        Big: e("as"),
                        Huge: e("at")
                    };
                    const i = uP(t.config.get(eP).options);
                    return i.map(t => {
                        const e = n[t.title];
                        if (e && e != t.title) {
                            t = Object.assign({}, t, {
                                title: e
                            })
                        }
                        return t
                    }
                    )
                }
            }
            function kP(t, e) {
                const n = new yr;
                for (const i of t) {
                    const t = {
                        type: "button",
                        model: new uk({
                            commandName: eP,
                            commandParam: i.model,
                            label: i.title,
                            class: "ck-fontsize-option",
                            withText: true
                        })
                    };
                    if (i.view && i.view.styles) {
                        t.model.set("labelStyle", `font-size:${i.view.styles["font-size"]}`)
                    }
                    if (i.view && i.view.classes) {
                        t.model.set("class", `${t.model.class} ${i.view.classes}`)
                    }
                    t.model.bind("isOn").to(e, "value", t => t === i.model);
                    n.add(t)
                }
                return n
            }
            class _P extends Nw {
                static get requires() {
                    return [gP, wP]
                }
                static get pluginName() {
                    return "FontSize"
                }
            }
            class vP extends $A {
                constructor(t) {
                    super(t, iP)
                }
            }
            class yP extends Nw {
                static get pluginName() {
                    return "FontColorEditing"
                }
                constructor(t) {
                    super(t);
                    t.config.define(iP, {
                        colors: [{
                            color: "hsl(0, 0%, 0%)",
                            label: "Black"
                        }, {
                            color: "hsl(0, 0%, 30%)",
                            label: "Dim grey"
                        }, {
                            color: "hsl(0, 0%, 60%)",
                            label: "Grey"
                        }, {
                            color: "hsl(0, 0%, 90%)",
                            label: "Light grey"
                        }, {
                            color: "hsl(0, 0%, 100%)",
                            label: "White",
                            hasBorder: true
                        }, {
                            color: "hsl(0, 75%, 60%)",
                            label: "Red"
                        }, {
                            color: "hsl(30, 75%, 60%)",
                            label: "Orange"
                        }, {
                            color: "hsl(60, 75%, 60%)",
                            label: "Yellow"
                        }, {
                            color: "hsl(90, 75%, 60%)",
                            label: "Light green"
                        }, {
                            color: "hsl(120, 75%, 60%)",
                            label: "Green"
                        }, {
                            color: "hsl(150, 75%, 60%)",
                            label: "Aquamarine"
                        }, {
                            color: "hsl(180, 75%, 60%)",
                            label: "Turquoise"
                        }, {
                            color: "hsl(210, 75%, 60%)",
                            label: "Light blue"
                        }, {
                            color: "hsl(240, 75%, 60%)",
                            label: "Blue"
                        }, {
                            color: "hsl(270, 75%, 60%)",
                            label: "Purple"
                        }],
                        columns: 5
                    });
                    t.conversion.for("upcast").elementToAttribute({
                        view: {
                            name: "span",
                            styles: {
                                color: /[\s\S]+/
                            }
                        },
                        model: {
                            key: iP,
                            value: rP("color")
                        }
                    });
                    t.conversion.for("downcast").attributeToElement({
                        model: iP,
                        view: aP("color")
                    });
                    t.commands.add(iP, new vP(t));
                    t.model.schema.extend("$text", {
                        allowAttributes: iP
                    });
                    t.model.schema.setAttributeProperties(iP, {
                        isFormatting: true,
                        copyOnEnter: true
                    })
                }
            }
            function xP(t, e) {
                const n = t.t;
                const i = {
                    Black: n("bw"),
                    "Dim grey": n("bx"),
                    Grey: n("by"),
                    "Light grey": n("bz"),
                    White: n("ca"),
                    Red: n("cb"),
                    Orange: n("cc"),
                    Yellow: n("cd"),
                    "Light green": n("ce"),
                    Green: n("cf"),
                    Aquamarine: n("cg"),
                    Turquoise: n("ch"),
                    "Light blue": n("ci"),
                    Blue: n("cj"),
                    Purple: n("ck")
                };
                return e.map(t => {
                    const e = i[t.label];
                    if (e && e != t.label) {
                        t.label = e
                    }
                    return t
                }
                )
            }
            function CP(t) {
                return t.map(AP).filter(t => !!t)
            }
            function AP(t) {
                if (typeof t === "string") {
                    return {
                        model: t.replace(/ /g, ""),
                        label: t,
                        hasBorder: false,
                        view: {
                            name: "span",
                            styles: {
                                color: t
                            }
                        }
                    }
                } else {
                    return {
                        model: t.color.replace(/ /g, ""),
                        label: t.label || t.color,
                        hasBorder: t.hasBorder === undefined ? false : t.hasBorder,
                        view: {
                            name: "span",
                            styles: {
                                color: `${t.color}`
                            }
                        }
                    }
                }
            }
            class PP extends Nw {
                constructor(t, { commandName: e, icon: n, componentName: i, dropdownLabel: o }) {
                    super(t);
                    this.commandName = e;
                    this.componentName = i;
                    this.icon = n;
                    this.dropdownLabel = o;
                    this.columns = t.config.get(`${this.componentName}.columns`);
                    this.colorTableView
                }
                init() {
                    const t = this.editor;
                    const e = t.locale;
                    const n = e.t;
                    const i = t.commands.get(this.commandName);
                    const o = CP(t.config.get(this.componentName).colors);
                    const s = xP(e, o);
                    const r = t.config.get(`${this.componentName}.documentColors`);
                    t.ui.componentFactory.add(this.componentName, e => {
                        const o = uw(e);
                        this.colorTableView = cP({
                            dropdownView: o,
                            colors: s.map(t => ({
                                label: t.label,
                                color: t.model,
                                options: {
                                    hasBorder: t.hasBorder
                                }
                            })),
                            columns: this.columns,
                            removeButtonLabel: n("bl"),
                            documentColorsLabel: r !== 0 ? n("bm") : undefined,
                            documentColorsCount: r === undefined ? this.columns : r
                        });
                        this.colorTableView.bind("selectedColor").to(i, "value");
                        o.buttonView.set({
                            label: this.dropdownLabel,
                            icon: this.icon,
                            tooltip: true
                        });
                        o.extendTemplate({
                            attributes: {
                                class: "ck-color-ui-dropdown"
                            }
                        });
                        o.bind("isEnabled").to(i);
                        o.on("execute", (e, n) => {
                            t.execute(this.commandName, n);
                            t.editing.view.focus()
                        }
                        );
                        o.on("change:isOpen", (e, n, i) => {
                            o.colorTableView.appendGrids();
                            if (i) {
                                if (r !== 0) {
                                    this.colorTableView.updateDocumentColors(t.model, this.componentName)
                                }
                                this.colorTableView.updateSelectedColors()
                            }
                        }
                        );
                        return o
                    }
                    )
                }
            }
            var TP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3L10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 010-2h12a1 1 0 010 2z"/></svg>';
            class SP extends PP {
                constructor(t) {
                    const e = t.locale.t;
                    super(t, {
                        commandName: iP,
                        componentName: iP,
                        icon: TP,
                        dropdownLabel: e("au")
                    })
                }
                static get pluginName() {
                    return "FontColorUI"
                }
            }
            class EP extends Nw {
                static get requires() {
                    return [yP, SP]
                }
                static get pluginName() {
                    return "FontColor"
                }
            }
            const RP = ["left", "right", "center", "justify"];
            function OP(t) {
                return RP.includes(t)
            }
            function MP(t, e) {
                if (e.contentLanguageDirection == "rtl") {
                    return t === "right"
                } else {
                    return t === "left"
                }
            }
            const NP = "alignment";
            class IP extends Fw {
                refresh() {
                    const t = this.editor;
                    const e = t.locale;
                    const n = zw(this.editor.model.document.selection.getSelectedBlocks());
                    this.isEnabled = !!n && this._canBeAligned(n);
                    if (this.isEnabled && n.hasAttribute("alignment")) {
                        this.value = n.getAttribute("alignment")
                    } else {
                        this.value = e.contentLanguageDirection === "rtl" ? "right" : "left"
                    }
                }
                execute(t = {}) {
                    const e = this.editor;
                    const n = e.locale;
                    const i = e.model;
                    const o = i.document;
                    const s = t.value;
                    i.change(t => {
                        const e = Array.from(o.selection.getSelectedBlocks()).filter(t => this._canBeAligned(t));
                        const i = e[0].getAttribute("alignment");
                        const r = MP(s, n) || i === s || !s;
                        if (r) {
                            VP(e, t)
                        } else {
                            BP(e, t, s)
                        }
                    }
                    )
                }
                _canBeAligned(t) {
                    return this.editor.model.schema.checkAttribute(t, NP)
                }
            }
            function VP(t, e) {
                for (const n of t) {
                    e.removeAttribute(NP, n)
                }
            }
            function BP(t, e, n) {
                for (const i of t) {
                    e.setAttribute(NP, n, i)
                }
            }
            class FP extends Nw {
                static get pluginName() {
                    return "AlignmentEditing"
                }
                constructor(t) {
                    super(t);
                    t.config.define("alignment", {
                        options: [...RP]
                    })
                }
                init() {
                    const t = this.editor;
                    const e = t.locale;
                    const n = t.model.schema;
                    const i = t.config.get("alignment.options").filter(OP);
                    n.extend("$block", {
                        allowAttributes: "alignment"
                    });
                    t.model.schema.setAttributeProperties("alignment", {
                        isFormatting: true
                    });
                    const o = DP(i.filter(t => !MP(t, e)));
                    t.conversion.attributeToAttribute(o);
                    t.commands.add("alignment", new IP(t))
                }
            }
            function DP(t) {
                const e = {
                    model: {
                        key: "alignment",
                        values: t.slice()
                    },
                    view: {}
                };
                for (const n of t) {
                    e.view[n] = {
                        key: "style",
                        value: {
                            "text-align": n
                        }
                    }
                }
                return e
            }
            var zP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75z"/></svg>';
            var LP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 01-.75.75H2.75a.75.75 0 110-1.5h14.5a.75.75 0 01.75.75zm0 8a.75.75 0 01-.75.75H2.75a.75.75 0 110-1.5h14.5a.75.75 0 01.75.75zm0 4a.75.75 0 01-.75.75H7.321a.75.75 0 110-1.5h9.929a.75.75 0 01.75.75zm0-8a.75.75 0 01-.75.75H7.321a.75.75 0 110-1.5h9.929a.75.75 0 01.75.75z"/></svg>';
            var jP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 100-1.5H5.036a.75.75 0 00-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 100-1.5H5.036a.75.75 0 00-.75.75z"/></svg>';
            var HP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75z"/></svg>';
            const qP = new Map([["left", zP], ["right", LP], ["center", jP], ["justify", HP]]);
            class WP extends Nw {
                get localizedOptionTitles() {
                    const t = this.editor.t;
                    return {
                        left: t("aa"),
                        right: t("ab"),
                        center: t("ac"),
                        justify: t("ad")
                    }
                }
                static get pluginName() {
                    return "AlignmentUI"
                }
                init() {
                    const t = this.editor;
                    const e = t.ui.componentFactory;
                    const n = t.t;
                    const i = t.config.get("alignment.options");
                    i.filter(OP).forEach(t => this._addButton(t));
                    e.add("alignment", t => {
                        const o = uw(t);
                        const s = i.map(t => e.create(`alignment:${t}`));
                        hw(o, s);
                        o.buttonView.set({
                            label: n("ae"),
                            tooltip: true
                        });
                        o.toolbarView.isVertical = true;
                        o.toolbarView.ariaLabel = n("af");
                        o.extendTemplate({
                            attributes: {
                                class: "ck-alignment-dropdown"
                            }
                        });
                        const r = t.contentLanguageDirection === "rtl" ? LP : zP;
                        o.buttonView.bind("icon").toMany(s, "isOn", (...t) => {
                            const e = t.findIndex(t => t);
                            if (e < 0) {
                                return r
                            }
                            return s[e].icon
                        }
                        );
                        o.bind("isEnabled").toMany(s, "isEnabled", (...t) => t.some(t => t));
                        return o
                    }
                    )
                }
                _addButton(t) {
                    const e = this.editor;
                    e.ui.componentFactory.add(`alignment:${t}`, n => {
                        const i = e.commands.get("alignment");
                        const o = new Zb(n);
                        o.set({
                            label: this.localizedOptionTitles[t],
                            icon: qP.get(t),
                            tooltip: true,
                            isToggleable: true
                        });
                        o.bind("isEnabled").to(i);
                        o.bind("isOn").to(i, "value", e => e === t);
                        this.listenTo(o, "execute", () => {
                            e.execute("alignment", {
                                value: t
                            });
                            e.editing.view.focus()
                        }
                        );
                        return o
                    }
                    )
                }
            }
            class UP extends Nw {
                static get requires() {
                    return [FP, WP]
                }
                static get pluginName() {
                    return "Alignment"
                }
            }
            class $P extends Fw {
                constructor(t) {
                    super(t);
                    this._childCommands = []
                }
                refresh() { }
                execute(...t) {
                    const e = this._getFirstEnabledCommand();
                    e.execute(t)
                }
                registerChildCommand(t) {
                    this._childCommands.push(t);
                    t.on("change:isEnabled", () => this._checkEnabled());
                    this._checkEnabled()
                }
                _checkEnabled() {
                    this.isEnabled = !!this._getFirstEnabledCommand()
                }
                _getFirstEnabledCommand() {
                    return this._childCommands.find(t => t.isEnabled)
                }
            }
            class GP extends Nw {
                static get pluginName() {
                    return "IndentEditing"
                }
                init() {
                    const t = this.editor;
                    t.commands.add("indent", new $P(t));
                    t.commands.add("outdent", new $P(t))
                }
            }
            var KP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 100-1.5h-9.5a.75.75 0 00-.75.75zM2.75 16.5h14.5a.75.75 0 100-1.5H2.75a.75.75 0 100 1.5zM1.632 6.95L5.02 9.358a.4.4 0 01-.013.661l-3.39 2.207A.4.4 0 011 11.892V7.275a.4.4 0 01.632-.326z"/></svg>';
            var JP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 100-1.5H2.75a.75.75 0 00-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 100-1.5h-9.5a.75.75 0 00-.75.75zM2.75 16.5h14.5a.75.75 0 100-1.5H2.75a.75.75 0 100 1.5zM4.368 6.95L.98 9.358a.4.4 0 00.013.661l3.39 2.207A.4.4 0 005 11.892V7.275a.4.4 0 00-.632-.326z"/></svg>';
            class QP extends Nw {
                static get pluginName() {
                    return "IndentUI"
                }
                init() {
                    const t = this.editor;
                    const e = t.locale;
                    const n = t.t;
                    const i = e.uiLanguageDirection == "ltr" ? KP : JP;
                    const o = e.uiLanguageDirection == "ltr" ? JP : KP;
                    this._defineButton("indent", n("ag"), i);
                    this._defineButton("outdent", n("ah"), o)
                }
                _defineButton(t, e, n) {
                    const i = this.editor;
                    i.ui.componentFactory.add(t, o => {
                        const s = i.commands.get(t);
                        const r = new Zb(o);
                        r.set({
                            label: e,
                            icon: n,
                            tooltip: true
                        });
                        r.bind("isOn", "isEnabled").to(s, "value", "isEnabled");
                        this.listenTo(r, "execute", () => {
                            i.execute(t);
                            i.editing.view.focus()
                        }
                        );
                        return r
                    }
                    )
                }
            }
            class YP extends Nw {
                static get pluginName() {
                    return "Indent"
                }
                static get requires() {
                    return [GP, QP]
                }
            }
            function XP(t) {
                if (t.is("text") || t.is("textProxy")) {
                    return t.data
                }
                let e = "";
                let n = null;
                for (const i of t.getChildren()) {
                    const t = XP(i);
                    if (n && n.is("element")) {
                        e += "\n"
                    }
                    e += t;
                    n = i
                }
                return e
            }
            class ZP extends Nw {
                constructor(t) {
                    super(t);
                    this.set("characters", 0);
                    this.set("words", 0);
                    Object.defineProperties(this, {
                        characters: {
                            get() {
                                return this.characters = this._getCharacters()
                            }
                        },
                        words: {
                            get() {
                                return this.words = this._getWords()
                            }
                        }
                    });
                    this.set("_wordsLabel");
                    this.set("_charactersLabel");
                    this._config = t.config.get("wordCount") || {};
                    this._outputView;
                    this._wordsMatchRegExp = Pl.features.isRegExpUnicodePropertySupported ? new RegExp("[\\p{L}\\p{N}\\p{M}\\p{Pd}\\p{Pc}]+", "gu") : /[_\-a-zA-Z0-9À-ž]+/gu
                }
                static get pluginName() {
                    return "WordCount"
                }
                init() {
                    const t = this.editor;
                    t.model.document.on("change:data", iA(this._refreshStats.bind(this), 250));
                    if (typeof this._config.onUpdate == "function") {
                        this.on("update", (t, e) => {
                            this._config.onUpdate(e)
                        }
                        )
                    }
                    if (Ks(this._config.container)) {
                        this._config.container.appendChild(this.wordCountContainer)
                    }
                }
                destroy() {
                    if (this._outputView) {
                        this._outputView.element.remove();
                        this._outputView.destroy()
                    }
                    super.destroy()
                }
                get wordCountContainer() {
                    const t = this.editor;
                    const e = t.t;
                    const n = t.config.get("wordCount.displayWords");
                    const i = t.config.get("wordCount.displayCharacters");
                    const o = qm.bind(this, this);
                    const s = [];
                    if (!this._outputView) {
                        this._outputView = new mb;
                        if (n || n === undefined) {
                            this.bind("_wordsLabel").to(this, "words", t => e("b", [t]));
                            s.push({
                                tag: "div",
                                children: [{
                                    text: [o.to("_wordsLabel")]
                                }],
                                attributes: {
                                    class: "ck-word-count__words"
                                }
                            })
                        }
                        if (i || i === undefined) {
                            this.bind("_charactersLabel").to(this, "characters", t => e("c", [t]));
                            s.push({
                                tag: "div",
                                children: [{
                                    text: [o.to("_charactersLabel")]
                                }],
                                attributes: {
                                    class: "ck-word-count__characters"
                                }
                            })
                        }
                        this._outputView.setTemplate({
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-word-count"]
                            },
                            children: s
                        });
                        this._outputView.render()
                    }
                    return this._outputView.element
                }
                _getCharacters() {
                    const t = XP(this.editor.model.document.getRoot());
                    return t.replace(/\n/g, "").length
                }
                _getWords() {
                    const t = XP(this.editor.model.document.getRoot());
                    const e = t.match(this._wordsMatchRegExp) || [];
                    return e.length
                }
                _refreshStats() {
                    const t = this.words = this._getWords();
                    const e = this.characters = this._getCharacters();
                    this.fire("update", {
                        words: t,
                        characters: e
                    })
                }
            }
            class tT extends Fw {
                execute() {
                    const t = this.editor.model;
                    const e = t.document;
                    t.change(n => {
                        eT(this.editor.model, n, e.selection, t.schema);
                        this.fire("afterExecute", {
                            writer: n
                        })
                    }
                    )
                }
            }
            function eT(t, e, n, i) {
                const o = n.isCollapsed;
                const s = n.getFirstRange();
                const r = s.start.parent;
                const a = s.end.parent;
                if (i.isLimit(r) || i.isLimit(a)) {
                    if (!o && r == a) {
                        t.deleteContent(n)
                    }
                    return
                }
                if (o) {
                    const t = uA(e.model.schema, n.getAttributes());
                    nT(e, s.start);
                    e.setSelectionAttribute(t)
                } else {
                    const i = !(s.start.isAtStart && s.end.isAtEnd);
                    const o = r == a;
                    t.deleteContent(n, {
                        leaveUnmerged: i
                    });
                    if (i) {
                        if (o) {
                            nT(e, n.focus)
                        } else {
                            e.setSelection(a, 0)
                        }
                    }
                }
            }
            function nT(t, e) {
                t.split(e);
                t.setSelection(e.parent.nextSibling, 0)
            }
            class iT extends Nw {
                static get pluginName() {
                    return "Enter"
                }
                init() {
                    const t = this.editor;
                    const e = t.editing.view;
                    const n = e.document;
                    e.addObserver(bA);
                    t.commands.add("enter", new tT(t));
                    this.listenTo(n, "enter", (n, i) => {
                        i.preventDefault();
                        if (i.isSoft) {
                            return
                        }
                        t.execute("enter");
                        e.scrollToTheSelection()
                    }
                        , {
                            priority: "low"
                        })
                }
            }
            class oT {
                constructor(t, e = 20) {
                    this.model = t;
                    this.size = 0;
                    this.limit = e;
                    this.isLocked = false;
                    this._changeCallback = (t, e) => {
                        if (e.type != "transparent" && e !== this._batch) {
                            this._reset(true)
                        }
                    }
                        ;
                    this._selectionChangeCallback = () => {
                        this._reset()
                    }
                        ;
                    this.model.document.on("change", this._changeCallback);
                    this.model.document.selection.on("change:range", this._selectionChangeCallback);
                    this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
                }
                get batch() {
                    if (!this._batch) {
                        this._batch = this.model.createBatch()
                    }
                    return this._batch
                }
                input(t) {
                    this.size += t;
                    if (this.size >= this.limit) {
                        this._reset(true)
                    }
                }
                lock() {
                    this.isLocked = true
                }
                unlock() {
                    this.isLocked = false
                }
                destroy() {
                    this.model.document.off("change", this._changeCallback);
                    this.model.document.selection.off("change:range", this._selectionChangeCallback);
                    this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
                }
                _reset(t) {
                    if (!this.isLocked || t) {
                        this._batch = null;
                        this.size = 0
                    }
                }
            }
            class sT extends Fw {
                constructor(t, e) {
                    super(t);
                    this._buffer = new oT(t.model, e);
                    this._batches = new WeakSet
                }
                get buffer() {
                    return this._buffer
                }
                destroy() {
                    super.destroy();
                    this._buffer.destroy()
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document;
                    const i = t.text || "";
                    const o = i.length;
                    const s = t.range || n.selection.getFirstRange();
                    const r = t.resultRange;
                    e.enqueueChange(this._buffer.batch, t => {
                        const a = s.isCollapsed;
                        this._buffer.lock();
                        e.deleteContent(e.createSelection(s));
                        if (i) {
                            e.insertContent(t.createText(i, n.selection.getAttributes()), s.start)
                        }
                        if (r) {
                            t.setSelection(r)
                        } else if (a) {
                            t.setSelection(s.start.getShiftedBy(o))
                        }
                        this._buffer.unlock();
                        this._buffer.input(o);
                        this._batches.add(this._buffer.batch)
                    }
                    )
                }
            }
            function rT(t) {
                let e = null;
                const n = t.model;
                const i = t.editing.view;
                const o = t.commands.get("input");
                if (Pl.isAndroid) {
                    i.document.on("beforeinput", (t, e) => s(e), {
                        priority: "lowest"
                    })
                } else {
                    i.document.on("keydown", (t, e) => s(e), {
                        priority: "lowest"
                    })
                }
                i.document.on("compositionstart", r, {
                    priority: "lowest"
                });
                i.document.on("compositionend", () => {
                    e = n.createSelection(n.document.selection)
                }
                    , {
                        priority: "lowest"
                    });
                function s(t) {
                    const s = n.document;
                    const r = i.document.isComposing;
                    const c = e && e.isEqual(s.selection);
                    e = null;
                    if (!o.isEnabled) {
                        return
                    }
                    if (cT(t) || s.selection.isCollapsed) {
                        return
                    }
                    if (r && t.keyCode === 229) {
                        return
                    }
                    if (!r && t.keyCode === 229 && c) {
                        return
                    }
                    a()
                }
                function r() {
                    const t = n.document;
                    const e = t.selection.rangeCount === 1 ? t.selection.getFirstRange().isFlat : true;
                    if (t.selection.isCollapsed || e) {
                        return
                    }
                    a()
                }
                function a() {
                    const t = o.buffer;
                    t.lock();
                    n.enqueueChange(t.batch, () => {
                        n.deleteContent(n.document.selection)
                    }
                    );
                    t.unlock()
                }
            }
            const aT = [Bl("arrowUp"), Bl("arrowRight"), Bl("arrowDown"), Bl("arrowLeft"), 9, 16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 45, 91, 93, 144, 145, 173, 174, 175, 176, 177, 178, 179, 255];
            for (let t = 112; t <= 135; t++) {
                aT.push(t)
            }
            function cT(t) {
                if (t.ctrlKey) {
                    return true
                }
                return aT.includes(t.keyCode)
            }
            function lT(t, e) {
                const n = [];
                let i = 0;
                let o;
                t.forEach(t => {
                    if (t == "equal") {
                        s();
                        i++
                    } else if (t == "insert") {
                        if (r("insert")) {
                            o.values.push(e[i])
                        } else {
                            s();
                            o = {
                                type: "insert",
                                index: i,
                                values: [e[i]]
                            }
                        }
                        i++
                    } else {
                        if (r("delete")) {
                            o.howMany++
                        } else {
                            s();
                            o = {
                                type: "delete",
                                index: i,
                                howMany: 1
                            }
                        }
                    }
                }
                );
                s();
                return n;
                function s() {
                    if (o) {
                        n.push(o);
                        o = null
                    }
                }
                function r(t) {
                    return o && o.type == t
                }
            }
            function dT(t) {
                if (t.length == 0) {
                    return false
                }
                for (const e of t) {
                    if (e.type === "children" && !uT(e)) {
                        return true
                    }
                }
                return false
            }
            function uT(t) {
                if (t.newChildren.length - t.oldChildren.length != 1) {
                    return
                }
                const e = vd(t.oldChildren, t.newChildren, hT);
                const n = lT(e, t.newChildren);
                if (n.length > 1) {
                    return
                }
                const i = n[0];
                if (!(!!i.values[0] && i.values[0].is("text"))) {
                    return
                }
                return i
            }
            function hT(t, e) {
                if (!!t && t.is("text") && !!e && e.is("text")) {
                    return t.data === e.data
                } else {
                    return t === e
                }
            }
            function fT(t) {
                t.editing.view.document.on("mutations", (e, n, i) => {
                    new pT(t).handle(n, i)
                }
                )
            }
            class pT {
                constructor(t) {
                    this.editor = t;
                    this.editing = this.editor.editing
                }
                handle(t, e) {
                    if (dT(t)) {
                        this._handleContainerChildrenMutations(t, e)
                    } else {
                        for (const n of t) {
                            this._handleTextMutation(n, e);
                            this._handleTextNodeInsertion(n)
                        }
                    }
                }
                _handleContainerChildrenMutations(t, e) {
                    const n = gT(t);
                    if (!n) {
                        return
                    }
                    const i = this.editor.editing.view.domConverter;
                    const o = i.mapViewToDom(n);
                    const s = new Dd;
                    const r = this.editor.data.toModel(s.domToView(o)).getChild(0);
                    const a = this.editor.editing.mapper.toModelElement(n);
                    if (!a) {
                        return
                    }
                    const c = Array.from(r.getChildren());
                    const l = Array.from(a.getChildren());
                    const d = c[c.length - 1];
                    const u = l[l.length - 1];
                    if (d && d.is("softBreak") && u && !u.is("softBreak")) {
                        c.pop()
                    }
                    const h = this.editor.model.schema;
                    if (!mT(c, h) || !mT(l, h)) {
                        return
                    }
                    const f = c.map(t => t.is("text") ? t.data : "@").join("").replace(/\u00A0/g, " ");
                    const p = l.map(t => t.is("text") ? t.data : "@").join("").replace(/\u00A0/g, " ");
                    if (p === f) {
                        return
                    }
                    const g = vd(p, f);
                    const { firstChangeAt: m, insertions: b, deletions: w } = bT(g);
                    let k = null;
                    if (e) {
                        k = this.editing.mapper.toModelRange(e.getFirstRange())
                    }
                    const _ = f.substr(m, b);
                    const v = this.editor.model.createRange(this.editor.model.createPositionAt(a, m), this.editor.model.createPositionAt(a, m + w));
                    this.editor.execute("input", {
                        text: _,
                        range: v,
                        resultRange: k
                    })
                }
                _handleTextMutation(t, e) {
                    if (t.type != "text") {
                        return
                    }
                    const n = t.newText.replace(/\u00A0/g, " ");
                    const i = t.oldText.replace(/\u00A0/g, " ");
                    if (i === n) {
                        return
                    }
                    const o = vd(i, n);
                    const { firstChangeAt: s, insertions: r, deletions: a } = bT(o);
                    let c = null;
                    if (e) {
                        c = this.editing.mapper.toModelRange(e.getFirstRange())
                    }
                    const l = this.editing.view.createPositionAt(t.node, s);
                    const d = this.editing.mapper.toModelPosition(l);
                    const u = this.editor.model.createRange(d, d.getShiftedBy(a));
                    const h = n.substr(s, r);
                    this.editor.execute("input", {
                        text: h,
                        range: u,
                        resultRange: c
                    })
                }
                _handleTextNodeInsertion(t) {
                    if (t.type != "children") {
                        return
                    }
                    const e = uT(t);
                    const n = this.editing.view.createPositionAt(t.node, e.index);
                    const i = this.editing.mapper.toModelPosition(n);
                    const o = e.values[0].data;
                    this.editor.execute("input", {
                        text: o.replace(/\u00A0/g, " "),
                        range: this.editor.model.createRange(i)
                    })
                }
            }
            function gT(t) {
                const e = t.map(t => t.node).reduce((t, e) => t.getCommonAncestor(e, {
                    includeSelf: true
                }));
                if (!e) {
                    return
                }
                return e.getAncestors({
                    includeSelf: true,
                    parentFirst: true
                }).find(t => t.is("containerElement") || t.is("rootElement"))
            }
            function mT(t, e) {
                return t.every(t => e.isInline(t))
            }
            function bT(t) {
                let e = null;
                let n = null;
                for (let i = 0; i < t.length; i++) {
                    const o = t[i];
                    if (o != "equal") {
                        e = e === null ? i : e;
                        n = i
                    }
                }
                let i = 0;
                let o = 0;
                for (let s = e; s <= n; s++) {
                    if (t[s] != "insert") {
                        i++
                    }
                    if (t[s] != "delete") {
                        o++
                    }
                }
                return {
                    insertions: o,
                    deletions: i,
                    firstChangeAt: e
                }
            }
            class wT extends Nw {
                static get pluginName() {
                    return "Input"
                }
                init() {
                    const t = this.editor;
                    const e = new sT(t, t.config.get("typing.undoStep") || 20);
                    t.commands.add("input", e);
                    rT(t);
                    fT(t)
                }
                isInput(t) {
                    const e = this.editor.commands.get("input");
                    return e._batches.has(t)
                }
            }
            class kT extends Fw {
                constructor(t, e) {
                    super(t);
                    this.direction = e;
                    this._buffer = new oT(t.model, t.config.get("typing.undoStep"))
                }
                get buffer() {
                    return this._buffer
                }
                execute(t = {}) {
                    const e = this.editor.model;
                    const n = e.document;
                    e.enqueueChange(this._buffer.batch, i => {
                        this._buffer.lock();
                        const o = i.createSelection(t.selection || n.selection);
                        const s = o.isCollapsed;
                        if (o.isCollapsed) {
                            e.modifySelection(o, {
                                direction: this.direction,
                                unit: t.unit
                            })
                        }
                        if (this._shouldEntireContentBeReplacedWithParagraph(t.sequence || 1)) {
                            this._replaceEntireContentWithParagraph(i);
                            return
                        }
                        if (o.isCollapsed) {
                            return
                        }
                        let r = 0;
                        o.getFirstRange().getMinimalFlatRanges().forEach(t => {
                            r += pl(t.getWalker({
                                singleCharacters: true,
                                ignoreElementEnd: true,
                                shallow: true
                            }))
                        }
                        );
                        e.deleteContent(o, {
                            doNotResetEntireContent: s
                        });
                        this._buffer.input(r);
                        i.setSelection(o);
                        this._buffer.unlock()
                    }
                    )
                }
                _shouldEntireContentBeReplacedWithParagraph(t) {
                    if (t > 1) {
                        return false
                    }
                    const e = this.editor.model;
                    const n = e.document;
                    const i = n.selection;
                    const o = e.schema.getLimitElement(i);
                    const s = i.isCollapsed && i.containsEntireContent(o);
                    if (!s) {
                        return false
                    }
                    if (!e.schema.checkChild(o, "paragraph")) {
                        return false
                    }
                    const r = o.getChild(0);
                    if (r && r.name === "paragraph") {
                        return false
                    }
                    return true
                }
                _replaceEntireContentWithParagraph(t) {
                    const e = this.editor.model;
                    const n = e.document;
                    const i = n.selection;
                    const o = e.schema.getLimitElement(i);
                    const s = t.createElement("paragraph");
                    t.remove(t.createRangeIn(o));
                    t.insert(s, o);
                    t.setSelection(s, 0)
                }
            }
            class _T extends Kd {
                constructor(t) {
                    super(t);
                    const e = t.document;
                    let n = 0;
                    e.on("keyup", (t, e) => {
                        if (e.keyCode == Vl.delete || e.keyCode == Vl.backspace) {
                            n = 0
                        }
                    }
                    );
                    e.on("keydown", (t, e) => {
                        const o = {};
                        if (e.keyCode == Vl.delete) {
                            o.direction = "forward";
                            o.unit = "character"
                        } else if (e.keyCode == Vl.backspace) {
                            o.direction = "backward";
                            o.unit = "codePoint"
                        } else {
                            return
                        }
                        const s = Pl.isMac ? e.altKey : e.ctrlKey;
                        o.unit = s ? "word" : o.unit;
                        o.sequence = ++n;
                        i(t, e.domEvent, o)
                    }
                    );
                    if (Pl.isAndroid) {
                        e.on("beforeinput", (e, n) => {
                            if (n.domEvent.inputType != "deleteContentBackward") {
                                return
                            }
                            const o = {
                                unit: "codepoint",
                                direction: "backward",
                                sequence: 1
                            };
                            const s = n.domTarget.ownerDocument.defaultView.getSelection();
                            if (s.anchorNode == s.focusNode && s.anchorOffset + 1 != s.focusOffset) {
                                o.selectionToRemove = t.domConverter.domSelectionToView(s)
                            }
                            i(e, n.domEvent, o)
                        }
                        )
                    }
                    function i(t, n, i) {
                        let o;
                        e.once("delete", t => o = t, {
                            priority: Number.POSITIVE_INFINITY
                        });
                        e.fire("delete", new Ju(e, n, i));
                        if (o && o.stop.called) {
                            t.stop()
                        }
                    }
                }
                observe() { }
            }
            class vT extends Nw {
                static get pluginName() {
                    return "Delete"
                }
                init() {
                    const t = this.editor;
                    const e = t.editing.view;
                    const n = e.document;
                    e.addObserver(_T);
                    t.commands.add("forwardDelete", new kT(t, "forward"));
                    t.commands.add("delete", new kT(t, "backward"));
                    this.listenTo(n, "delete", (n, i) => {
                        const o = {
                            unit: i.unit,
                            sequence: i.sequence
                        };
                        if (i.selectionToRemove) {
                            const e = t.model.createSelection();
                            const n = [];
                            for (const e of i.selectionToRemove.getRanges()) {
                                n.push(t.editing.mapper.toModelRange(e))
                            }
                            e.setTo(n);
                            o.selection = e
                        }
                        t.execute(i.direction == "forward" ? "forwardDelete" : "delete", o);
                        i.preventDefault();
                        e.scrollToTheSelection()
                    }
                    );
                    if (Pl.isAndroid) {
                        let t = null;
                        this.listenTo(n, "delete", (e, n) => {
                            const i = n.domTarget.ownerDocument.defaultView.getSelection();
                            t = {
                                anchorNode: i.anchorNode,
                                anchorOffset: i.anchorOffset,
                                focusNode: i.focusNode,
                                focusOffset: i.focusOffset
                            }
                        }
                            , {
                                priority: "lowest"
                            });
                        this.listenTo(n, "keyup", (e, n) => {
                            if (t) {
                                const e = n.domTarget.ownerDocument.defaultView.getSelection();
                                e.collapse(t.anchorNode, t.anchorOffset);
                                e.extend(t.focusNode, t.focusOffset);
                                t = null
                            }
                        }
                        )
                    }
                }
            }
            class yT extends Nw {
                static get requires() {
                    return [wT, vT]
                }
                static get pluginName() {
                    return "Typing"
                }
            }
            const xT = new Map;
            function CT(t, e, n) {
                let i = xT.get(t);
                if (!i) {
                    i = new Map;
                    xT.set(t, i)
                }
                i.set(e, n)
            }
            function AT(t, e) {
                const n = xT.get(t);
                if (n && n.has(e)) {
                    return n.get(e)
                }
                return PT
            }
            function PT(t) {
                return [t]
            }
            function TT(t, e, n = {}) {
                const i = AT(t.constructor, e.constructor);
                try {
                    t = t.clone();
                    return i(t, e, n)
                } catch (t) {
                    throw t
                }
            }
            function ST(t, e, n) {
                t = t.slice();
                e = e.slice();
                const i = new ET(n.document, n.useRelations, n.forceWeakRemove);
                i.setOriginalOperations(t);
                i.setOriginalOperations(e);
                const o = i.originalOperations;
                if (t.length == 0 || e.length == 0) {
                    return {
                        operationsA: t,
                        operationsB: e,
                        originalOperations: o
                    }
                }
                const s = new WeakMap;
                for (const e of t) {
                    s.set(e, 0)
                }
                const r = {
                    nextBaseVersionA: t[t.length - 1].baseVersion + 1,
                    nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                    originalOperationsACount: t.length,
                    originalOperationsBCount: e.length
                };
                let a = 0;
                while (a < t.length) {
                    const n = t[a];
                    const o = s.get(n);
                    if (o == e.length) {
                        a++;
                        continue
                    }
                    const r = e[o];
                    const c = TT(n, r, i.getContext(n, r, true));
                    const l = TT(r, n, i.getContext(r, n, false));
                    i.updateRelation(n, r);
                    i.setOriginalOperations(c, n);
                    i.setOriginalOperations(l, r);
                    for (const t of c) {
                        s.set(t, o + l.length)
                    }
                    t.splice(a, 1, ...c);
                    e.splice(o, 1, ...l)
                }
                if (n.padWithNoOps) {
                    const n = t.length - r.originalOperationsACount;
                    const i = e.length - r.originalOperationsBCount;
                    OT(t, i - n);
                    OT(e, n - i)
                }
                RT(t, r.nextBaseVersionB);
                RT(e, r.nextBaseVersionA);
                return {
                    operationsA: t,
                    operationsB: e,
                    originalOperations: o
                }
            }
            class ET {
                constructor(t, e, n = false) {
                    this.originalOperations = new Map;
                    this._history = t.history;
                    this._useRelations = e;
                    this._forceWeakRemove = !!n;
                    this._relations = new Map
                }
                setOriginalOperations(t, e = null) {
                    const n = e ? this.originalOperations.get(e) : null;
                    for (const e of t) {
                        this.originalOperations.set(e, n || e)
                    }
                }
                updateRelation(t, e) {
                    switch (t.constructor) {
                        case tg:
                            {
                                switch (e.constructor) {
                                    case sg:
                                        {
                                            if (t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)) {
                                                this._setRelation(t, e, "insertAtSource")
                                            } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                                                this._setRelation(t, e, "insertBetween")
                                            } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                                                this._setRelation(t, e, "moveTargetAfter")
                                            }
                                            break
                                        }
                                    case tg:
                                        {
                                            if (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)) {
                                                this._setRelation(t, e, "insertBefore")
                                            } else {
                                                this._setRelation(t, e, "insertAfter")
                                            }
                                            break
                                        }
                                }
                                break
                            }
                        case rg:
                            {
                                switch (e.constructor) {
                                    case sg:
                                        {
                                            if (t.splitPosition.isBefore(e.sourcePosition)) {
                                                this._setRelation(t, e, "splitBefore")
                                            }
                                            break
                                        }
                                    case tg:
                                        {
                                            if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) {
                                                this._setRelation(t, e, "splitBefore")
                                            }
                                            break
                                        }
                                }
                                break
                            }
                        case sg:
                            {
                                switch (e.constructor) {
                                    case sg:
                                        {
                                            if (!t.targetPosition.isEqual(e.sourcePosition)) {
                                                this._setRelation(t, e, "mergeTargetNotMoved")
                                            }
                                            if (t.sourcePosition.isEqual(e.targetPosition)) {
                                                this._setRelation(t, e, "mergeSourceNotMoved")
                                            }
                                            if (t.sourcePosition.isEqual(e.sourcePosition)) {
                                                this._setRelation(t, e, "mergeSameElement")
                                            }
                                            break
                                        }
                                    case rg:
                                        {
                                            if (t.sourcePosition.isEqual(e.splitPosition)) {
                                                this._setRelation(t, e, "splitAtSource")
                                            }
                                        }
                                }
                                break
                            }
                        case ng:
                            {
                                const n = t.newRange;
                                if (!n) {
                                    return
                                }
                                switch (e.constructor) {
                                    case tg:
                                        {
                                            const i = Gh._createFromPositionAndShift(e.sourcePosition, e.howMany);
                                            const o = i.containsPosition(n.start) || i.start.isEqual(n.start);
                                            const s = i.containsPosition(n.end) || i.end.isEqual(n.end);
                                            if ((o || s) && !i.containsRange(n)) {
                                                this._setRelation(t, e, {
                                                    side: o ? "left" : "right",
                                                    path: o ? n.start.path.slice() : n.end.path.slice()
                                                })
                                            }
                                            break
                                        }
                                    case sg:
                                        {
                                            const i = n.start.isEqual(e.targetPosition);
                                            const o = n.start.isEqual(e.deletionPosition);
                                            const s = n.end.isEqual(e.deletionPosition);
                                            const r = n.end.isEqual(e.sourcePosition);
                                            if (i || o || s || r) {
                                                this._setRelation(t, e, {
                                                    wasInLeftElement: i,
                                                    wasStartBeforeMergedElement: o,
                                                    wasEndBeforeMergedElement: s,
                                                    wasInRightElement: r
                                                })
                                            }
                                            break
                                        }
                                }
                                break
                            }
                    }
                }
                getContext(t, e, n) {
                    return {
                        aIsStrong: n,
                        aWasUndone: this._wasUndone(t),
                        bWasUndone: this._wasUndone(e),
                        abRelation: this._useRelations ? this._getRelation(t, e) : null,
                        baRelation: this._useRelations ? this._getRelation(e, t) : null,
                        forceWeakRemove: this._forceWeakRemove
                    }
                }
                _wasUndone(t) {
                    const e = this.originalOperations.get(t);
                    return e.wasUndone || this._history.isUndoneOperation(e)
                }
                _getRelation(t, e) {
                    const n = this.originalOperations.get(e);
                    const i = this._history.getUndoneOperation(n);
                    if (!i) {
                        return null
                    }
                    const o = this.originalOperations.get(t);
                    const s = this._relations.get(o);
                    if (s) {
                        return s.get(i) || null
                    }
                    return null
                }
                _setRelation(t, e, n) {
                    const i = this.originalOperations.get(t);
                    const o = this.originalOperations.get(e);
                    let s = this._relations.get(i);
                    if (!s) {
                        s = new Map;
                        this._relations.set(i, s)
                    }
                    s.set(o, n)
                }
            }
            function RT(t, e) {
                for (const n of t) {
                    n.baseVersion = e++
                }
            }
            function OT(t, e) {
                for (let n = 0; n < e; n++) {
                    t.push(new Eg(0))
                }
            }
            CT(Xp, Xp, (t, e, n) => {
                if (t.key === e.key) {
                    const i = t.range.getDifference(e.range).map(e => new Xp(e, t.key, t.oldValue, t.newValue, 0));
                    const o = t.range.getIntersection(e.range);
                    if (o) {
                        if (n.aIsStrong) {
                            i.push(new Xp(o, e.key, e.newValue, t.newValue, 0))
                        }
                    }
                    if (i.length == 0) {
                        return [new Eg(0)]
                    }
                    return i
                } else {
                    return [t]
                }
            }
            );
            CT(Xp, eg, (t, e) => {
                if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
                    const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes);
                    const i = n.map(e => new Xp(e, t.key, t.oldValue, t.newValue, t.baseVersion));
                    if (e.shouldReceiveAttributes) {
                        const n = MT(e, t.key, t.oldValue);
                        if (n) {
                            i.unshift(n)
                        }
                    }
                    return i
                }
                t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0];
                return [t]
            }
            );
            function MT(t, e, n) {
                const i = t.nodes;
                const o = i.getNode(0).getAttribute(e);
                if (o == n) {
                    return null
                }
                const s = new Gh(t.position, t.position.getShiftedBy(t.howMany));
                return new Xp(s, e, o, n, 0)
            }
            CT(Xp, sg, (t, e) => {
                const n = [];
                if (t.range.start.hasSameParentAs(e.deletionPosition)) {
                    if (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) {
                        n.push(Gh._createFromPositionAndShift(e.graveyardPosition, 1))
                    }
                }
                const i = t.range._getTransformedByMergeOperation(e);
                if (!i.isCollapsed) {
                    n.push(i)
                }
                return n.map(e => new Xp(e, t.key, t.oldValue, t.newValue, t.baseVersion))
            }
            );
            CT(Xp, tg, (t, e) => {
                const n = NT(t.range, e);
                return n.map(e => new Xp(e, t.key, t.oldValue, t.newValue, t.baseVersion))
            }
            );
            function NT(t, e) {
                const n = Gh._createFromPositionAndShift(e.sourcePosition, e.howMany);
                let i = null;
                let o = [];
                if (n.containsRange(t, true)) {
                    i = t
                } else if (t.start.hasSameParentAs(n.start)) {
                    o = t.getDifference(n);
                    i = t.getIntersection(n)
                } else {
                    o = [t]
                }
                const s = [];
                for (let t of o) {
                    t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    const n = e.getMovedRangeStart();
                    const i = t.start.hasSameParentAs(n);
                    t = t._getTransformedByInsertion(n, e.howMany, i);
                    s.push(...t)
                }
                if (i) {
                    s.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0])
                }
                return s
            }
            CT(Xp, rg, (t, e) => {
                if (t.range.end.isEqual(e.insertionPosition)) {
                    if (!e.graveyardPosition) {
                        t.range.end.offset++
                    }
                    return [t]
                }
                if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
                    const n = t.clone();
                    n.range = new Gh(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition));
                    t.range.end = e.splitPosition.clone();
                    t.range.end.stickiness = "toPrevious";
                    return [t, n]
                }
                t.range = t.range._getTransformedBySplitOperation(e);
                return [t]
            }
            );
            CT(eg, Xp, (t, e) => {
                const n = [t];
                if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) {
                    const i = MT(t, e.key, e.newValue);
                    if (i) {
                        n.push(i)
                    }
                }
                return n
            }
            );
            CT(eg, eg, (t, e, n) => {
                if (t.position.isEqual(e.position) && n.aIsStrong) {
                    return [t]
                }
                t.position = t.position._getTransformedByInsertOperation(e);
                return [t]
            }
            );
            CT(eg, tg, (t, e) => {
                t.position = t.position._getTransformedByMoveOperation(e);
                return [t]
            }
            );
            CT(eg, rg, (t, e) => {
                t.position = t.position._getTransformedBySplitOperation(e);
                return [t]
            }
            );
            CT(eg, sg, (t, e) => {
                t.position = t.position._getTransformedByMergeOperation(e);
                return [t]
            }
            );
            CT(ng, eg, (t, e) => {
                if (t.oldRange) {
                    t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]
                }
                if (t.newRange) {
                    t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]
                }
                return [t]
            }
            );
            CT(ng, ng, (t, e, n) => {
                if (t.name == e.name) {
                    if (n.aIsStrong) {
                        t.oldRange = e.newRange ? e.newRange.clone() : null
                    } else {
                        return [new Eg(0)]
                    }
                }
                return [t]
            }
            );
            CT(ng, sg, (t, e) => {
                if (t.oldRange) {
                    t.oldRange = t.oldRange._getTransformedByMergeOperation(e)
                }
                if (t.newRange) {
                    t.newRange = t.newRange._getTransformedByMergeOperation(e)
                }
                return [t]
            }
            );
            CT(ng, tg, (t, e, n) => {
                if (t.oldRange) {
                    t.oldRange = Gh._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))
                }
                if (t.newRange) {
                    if (n.abRelation) {
                        const i = Gh._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                        if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) {
                            t.newRange.start.path = n.abRelation.path;
                            t.newRange.end = i.end;
                            return [t]
                        } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) {
                            t.newRange.start = i.start;
                            t.newRange.end.path = n.abRelation.path;
                            return [t]
                        }
                    }
                    t.newRange = Gh._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
                }
                return [t]
            }
            );
            CT(ng, rg, (t, e, n) => {
                if (t.oldRange) {
                    t.oldRange = t.oldRange._getTransformedBySplitOperation(e)
                }
                if (t.newRange) {
                    if (n.abRelation) {
                        const i = t.newRange._getTransformedBySplitOperation(e);
                        if (t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement) {
                            t.newRange.start = $h._createAt(e.insertionPosition)
                        } else if (t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement) {
                            t.newRange.start = $h._createAt(e.moveTargetPosition)
                        }
                        if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) {
                            t.newRange.end = $h._createAt(e.moveTargetPosition)
                        } else if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement) {
                            t.newRange.end = $h._createAt(e.insertionPosition)
                        } else {
                            t.newRange.end = i.end
                        }
                        return [t]
                    }
                    t.newRange = t.newRange._getTransformedBySplitOperation(e)
                }
                return [t]
            }
            );
            CT(sg, eg, (t, e) => {
                if (t.sourcePosition.hasSameParentAs(e.position)) {
                    t.howMany += e.howMany
                }
                t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
                t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
                return [t]
            }
            );
            CT(sg, sg, (t, e, n) => {
                if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
                    if (!n.bWasUndone) {
                        return [new Eg(0)]
                    } else {
                        const n = e.graveyardPosition.path.slice();
                        n.push(0);
                        t.sourcePosition = new $h(e.graveyardPosition.root, n);
                        t.howMany = 0;
                        return [t]
                    }
                }
                if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && n.abRelation != "splitAtSource") {
                    const i = t.targetPosition.root.rootName == "$graveyard";
                    const o = e.targetPosition.root.rootName == "$graveyard";
                    const s = i && !o;
                    const r = o && !i;
                    const a = r || !s && n.aIsStrong;
                    if (a) {
                        const n = e.targetPosition._getTransformedByMergeOperation(e);
                        const i = t.targetPosition._getTransformedByMergeOperation(e);
                        return [new tg(n, t.howMany, i, 0)]
                    } else {
                        return [new Eg(0)]
                    }
                }
                if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                    t.howMany += e.howMany
                }
                t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
                t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
                if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
                    t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
                }
                return [t]
            }
            );
            CT(sg, tg, (t, e, n) => {
                const i = Gh._createFromPositionAndShift(e.sourcePosition, e.howMany);
                if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                    if (t.deletionPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.sourcePosition)) {
                        return [new Eg(0)]
                    }
                }
                if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                    t.howMany += e.howMany
                }
                if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
                    t.howMany -= e.howMany
                }
                t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
                t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
                if (!t.graveyardPosition.isEqual(e.targetPosition)) {
                    t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
                }
                return [t]
            }
            );
            CT(sg, rg, (t, e, n) => {
                if (e.graveyardPosition) {
                    t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1);
                    if (t.deletionPosition.isEqual(e.graveyardPosition)) {
                        t.howMany = e.howMany
                    }
                }
                if (t.targetPosition.isEqual(e.splitPosition)) {
                    const i = e.howMany != 0;
                    const o = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
                    if (i || o || n.abRelation == "mergeTargetNotMoved") {
                        t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
                        return [t]
                    }
                }
                if (t.sourcePosition.isEqual(e.splitPosition)) {
                    if (n.abRelation == "mergeSourceNotMoved") {
                        t.howMany = 0;
                        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                        return [t]
                    }
                    if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) {
                        t.sourcePosition = e.moveTargetPosition.clone();
                        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                        return [t]
                    }
                }
                if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
                    t.howMany = e.splitPosition.offset
                }
                t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
                t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                return [t]
            }
            );
            CT(tg, eg, (t, e) => {
                const n = Gh._createFromPositionAndShift(t.sourcePosition, t.howMany);
                const i = n._getTransformedByInsertOperation(e, false)[0];
                t.sourcePosition = i.start;
                t.howMany = i.end.offset - i.start.offset;
                if (!t.targetPosition.isEqual(e.position)) {
                    t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
                }
                return [t]
            }
            );
            CT(tg, tg, (t, e, n) => {
                const i = Gh._createFromPositionAndShift(t.sourcePosition, t.howMany);
                const o = Gh._createFromPositionAndShift(e.sourcePosition, e.howMany);
                let s = n.aIsStrong;
                let r = !n.aIsStrong;
                if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
                    r = true
                } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") {
                    r = false
                }
                let a;
                if (t.targetPosition.isEqual(e.targetPosition) && r) {
                    a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
                } else {
                    a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
                }
                if (IT(t, e) && IT(e, t)) {
                    return [e.getReversed()]
                }
                const c = i.containsPosition(e.targetPosition);
                if (c && i.containsRange(o, true)) {
                    i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                    i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                    return VT([i], a)
                }
                const l = o.containsPosition(t.targetPosition);
                if (l && o.containsRange(i, true)) {
                    i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                    i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                    return VT([i], a)
                }
                const d = Nr(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
                if (d == "prefix" || d == "extension") {
                    i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                    i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                    return VT([i], a)
                }
                if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) {
                    s = true
                } else if (t.type != "remove" && e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                    s = false
                }
                const u = [];
                const h = i.getDifference(o);
                for (const t of h) {
                    t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    const n = Nr(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same";
                    const i = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
                    u.push(...i)
                }
                const f = i.getIntersection(o);
                if (f !== null && s) {
                    f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                    f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                    if (u.length === 0) {
                        u.push(f)
                    } else if (u.length == 1) {
                        if (o.start.isBefore(i.start) || o.start.isEqual(i.start)) {
                            u.unshift(f)
                        } else {
                            u.push(f)
                        }
                    } else {
                        u.splice(1, 0, f)
                    }
                }
                if (u.length === 0) {
                    return [new Eg(t.baseVersion)]
                }
                return VT(u, a)
            }
            );
            CT(tg, rg, (t, e, n) => {
                let i = t.targetPosition.clone();
                if (!t.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || n.abRelation == "moveTargetAfter") {
                    i = t.targetPosition._getTransformedBySplitOperation(e)
                }
                const o = Gh._createFromPositionAndShift(t.sourcePosition, t.howMany);
                if (o.end.isEqual(e.insertionPosition)) {
                    if (!e.graveyardPosition) {
                        t.howMany++
                    }
                    t.targetPosition = i;
                    return [t]
                }
                if (o.start.hasSameParentAs(e.splitPosition) && o.containsPosition(e.splitPosition)) {
                    let t = new Gh(e.splitPosition, o.end);
                    t = t._getTransformedBySplitOperation(e);
                    const n = [new Gh(o.start, e.splitPosition), t];
                    return VT(n, i)
                }
                if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") {
                    i = e.moveTargetPosition
                }
                if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") {
                    i = t.targetPosition
                }
                const s = o._getTransformedBySplitOperation(e);
                const r = [s];
                if (e.graveyardPosition) {
                    const i = o.start.isEqual(e.graveyardPosition) || o.containsPosition(e.graveyardPosition);
                    if (t.howMany > 1 && i && !n.aWasUndone) {
                        r.push(Gh._createFromPositionAndShift(e.insertionPosition, 1))
                    }
                }
                return VT(r, i)
            }
            );
            CT(tg, sg, (t, e, n) => {
                const i = Gh._createFromPositionAndShift(t.sourcePosition, t.howMany);
                if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.sourcePosition)) {
                    if (t.type == "remove" && !n.forceWeakRemove) {
                        if (!n.aWasUndone) {
                            const n = [];
                            let i = e.graveyardPosition.clone();
                            let o = e.targetPosition._getTransformedByMergeOperation(e);
                            if (t.howMany > 1) {
                                n.push(new tg(t.sourcePosition, t.howMany - 1, t.targetPosition, 0));
                                i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1);
                                o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
                            }
                            const s = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition);
                            const r = new tg(i, 1, s, 0);
                            const a = r.getMovedRangeStart().path.slice();
                            a.push(0);
                            const c = new $h(r.targetPosition.root, a);
                            o = o._getTransformedByMove(i, s, 1);
                            const l = new tg(o, e.howMany, c, 0);
                            n.push(r);
                            n.push(l);
                            return n
                        }
                    } else {
                        if (t.howMany == 1) {
                            if (!n.bWasUndone) {
                                return [new Eg(0)]
                            } else {
                                t.sourcePosition = e.graveyardPosition.clone();
                                t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
                                return [t]
                            }
                        }
                    }
                }
                const o = Gh._createFromPositionAndShift(t.sourcePosition, t.howMany);
                const s = o._getTransformedByMergeOperation(e);
                t.sourcePosition = s.start;
                t.howMany = s.end.offset - s.start.offset;
                t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
                return [t]
            }
            );
            CT(ig, eg, (t, e) => {
                t.position = t.position._getTransformedByInsertOperation(e);
                return [t]
            }
            );
            CT(ig, sg, (t, e) => {
                if (t.position.isEqual(e.deletionPosition)) {
                    t.position = e.graveyardPosition.clone();
                    t.position.stickiness = "toNext";
                    return [t]
                }
                t.position = t.position._getTransformedByMergeOperation(e);
                return [t]
            }
            );
            CT(ig, tg, (t, e) => {
                t.position = t.position._getTransformedByMoveOperation(e);
                return [t]
            }
            );
            CT(ig, ig, (t, e, n) => {
                if (t.position.isEqual(e.position)) {
                    if (n.aIsStrong) {
                        t.oldName = e.newName
                    } else {
                        return [new Eg(0)]
                    }
                }
                return [t]
            }
            );
            CT(ig, rg, (t, e) => {
                const n = t.position.path;
                const i = e.splitPosition.getParentPath();
                if (Nr(n, i) == "same" && !e.graveyardPosition) {
                    const e = new ig(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
                    return [t, e]
                }
                t.position = t.position._getTransformedBySplitOperation(e);
                return [t]
            }
            );
            CT(og, og, (t, e, n) => {
                if (t.root === e.root && t.key === e.key) {
                    if (!n.aIsStrong || t.newValue === e.newValue) {
                        return [new Eg(0)]
                    } else {
                        t.oldValue = e.newValue
                    }
                }
                return [t]
            }
            );
            CT(rg, eg, (t, e) => {
                if (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset) {
                    t.howMany += e.howMany
                }
                t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
                t.insertionPosition = rg.getInsertionPosition(t.splitPosition);
                return [t]
            }
            );
            CT(rg, sg, (t, e, n) => {
                if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
                    const n = e.graveyardPosition.path.slice();
                    n.push(0);
                    const i = new $h(e.graveyardPosition.root, n);
                    const o = rg.getInsertionPosition(new $h(e.graveyardPosition.root, n));
                    const s = new rg(i, 0, null, 0);
                    s.insertionPosition = o;
                    t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
                    t.insertionPosition = rg.getInsertionPosition(t.splitPosition);
                    t.graveyardPosition = s.insertionPosition.clone();
                    t.graveyardPosition.stickiness = "toNext";
                    return [s, t]
                }
                if (t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition)) {
                    t.howMany--
                }
                if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
                    t.howMany += e.howMany
                }
                t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
                t.insertionPosition = rg.getInsertionPosition(t.splitPosition);
                if (t.graveyardPosition) {
                    t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
                }
                return [t]
            }
            );
            CT(rg, tg, (t, e, n) => {
                const i = Gh._createFromPositionAndShift(e.sourcePosition, e.howMany);
                if (t.graveyardPosition) {
                    const o = i.start.isEqual(t.graveyardPosition) || i.containsPosition(t.graveyardPosition);
                    if (!n.bWasUndone && o) {
                        const n = t.splitPosition._getTransformedByMoveOperation(e);
                        const i = t.graveyardPosition._getTransformedByMoveOperation(e);
                        const o = i.path.slice();
                        o.push(0);
                        const s = new $h(i.root, o);
                        const r = new tg(n, t.howMany, s, 0);
                        return [r]
                    }
                    t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
                }
                if (t.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.splitPosition)) {
                    const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
                    t.howMany -= n;
                    if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                        t.howMany += e.howMany
                    }
                    t.splitPosition = e.sourcePosition.clone();
                    t.insertionPosition = rg.getInsertionPosition(t.splitPosition);
                    return [t]
                }
                const o = t.splitPosition.isEqual(e.targetPosition);
                if (o && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) {
                    t.howMany += e.howMany;
                    t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    t.insertionPosition = rg.getInsertionPosition(t.splitPosition);
                    return [t]
                }
                if (!e.sourcePosition.isEqual(e.targetPosition)) {
                    if (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset) {
                        t.howMany -= e.howMany
                    }
                    if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                        t.howMany += e.howMany
                    }
                }
                t.splitPosition.stickiness = "toNone";
                t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
                t.splitPosition.stickiness = "toNext";
                if (t.graveyardPosition) {
                    t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e)
                } else {
                    t.insertionPosition = rg.getInsertionPosition(t.splitPosition)
                }
                return [t]
            }
            );
            CT(rg, rg, (t, e, n) => {
                if (t.splitPosition.isEqual(e.splitPosition)) {
                    if (!t.graveyardPosition && !e.graveyardPosition) {
                        return [new Eg(0)]
                    }
                    if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                        return [new Eg(0)]
                    }
                    if (n.abRelation == "splitBefore") {
                        t.howMany = 0;
                        t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e);
                        return [t]
                    }
                }
                if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                    const i = t.splitPosition.root.rootName == "$graveyard";
                    const o = e.splitPosition.root.rootName == "$graveyard";
                    const s = i && !o;
                    const r = o && !i;
                    const a = r || !s && n.aIsStrong;
                    if (a) {
                        const n = [];
                        if (e.howMany) {
                            n.push(new tg(e.moveTargetPosition, e.howMany, e.splitPosition, 0))
                        }
                        if (t.howMany) {
                            n.push(new tg(t.splitPosition, t.howMany, t.moveTargetPosition, 0))
                        }
                        return n
                    } else {
                        return [new Eg(0)]
                    }
                }
                if (t.graveyardPosition) {
                    t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
                }
                if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") {
                    t.howMany++;
                    return [t]
                }
                if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") {
                    const n = e.insertionPosition.path.slice();
                    n.push(0);
                    const i = new $h(e.insertionPosition.root, n);
                    const o = new tg(t.insertionPosition, 1, i, 0);
                    return [t, o]
                }
                if (t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset) {
                    t.howMany -= e.howMany
                }
                t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
                t.insertionPosition = rg.getInsertionPosition(t.splitPosition);
                return [t]
            }
            );
            function IT(t, e) {
                return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
            }
            function VT(t, e) {
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const o = t[i];
                    const s = new tg(o.start, o.end.offset - o.start.offset, e, 0);
                    n.push(s);
                    for (let e = i + 1; e < t.length; e++) {
                        t[e] = t[e]._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany)[0]
                    }
                    e = e._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany)
                }
                return n
            }
            class BT extends Fw {
                constructor(t) {
                    super(t);
                    this._stack = [];
                    this._createdBatches = new WeakSet;
                    this.refresh()
                }
                refresh() {
                    this.isEnabled = this._stack.length > 0
                }
                addBatch(t) {
                    const e = this.editor.model.document.selection;
                    const n = {
                        ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
                        isBackward: e.isBackward
                    };
                    this._stack.push({
                        batch: t,
                        selection: n
                    });
                    this.refresh()
                }
                clearStack() {
                    this._stack = [];
                    this.refresh()
                }
                _restoreSelection(t, e, n) {
                    const i = this.editor.model;
                    const o = i.document;
                    const s = [];
                    for (const e of t) {
                        const t = FT(e, n);
                        const i = t.find(t => t.start.root != o.graveyard);
                        if (i) {
                            s.push(i)
                        }
                    }
                    if (s.length) {
                        i.change(t => {
                            t.setSelection(s, {
                                backward: e
                            })
                        }
                        )
                    }
                }
                _undo(t, e) {
                    const n = this.editor.model;
                    const i = n.document;
                    this._createdBatches.add(e);
                    const o = t.operations.slice().filter(t => t.isDocumentOperation);
                    o.reverse();
                    for (const t of o) {
                        const o = t.baseVersion + 1;
                        const s = Array.from(i.history.getOperations(o));
                        const r = ST([t.getReversed()], s, {
                            useRelations: true,
                            document: this.editor.model.document,
                            padWithNoOps: false,
                            forceWeakRemove: true
                        });
                        const a = r.operationsA;
                        for (const o of a) {
                            e.addOperation(o);
                            n.applyOperation(o);
                            i.history.setOperationAsUndone(t, o)
                        }
                    }
                }
            }
            function FT(t, e) {
                const n = t.getTransformedByOperations(e);
                n.sort((t, e) => t.start.isBefore(e.start) ? -1 : 1);
                for (let t = 1; t < n.length; t++) {
                    const e = n[t - 1];
                    const i = n[t];
                    if (e.end.isTouching(i.start)) {
                        e.end = i.end;
                        n.splice(t, 1);
                        t--
                    }
                }
                return n
            }
            class DT extends BT {
                execute(t = null) {
                    const e = t ? this._stack.findIndex(e => e.batch == t) : this._stack.length - 1;
                    const n = this._stack.splice(e, 1)[0];
                    const i = this.editor.model.createBatch("transparent");
                    this.editor.model.enqueueChange(i, () => {
                        this._undo(n.batch, i);
                        const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
                        this._restoreSelection(n.selection.ranges, n.selection.isBackward, t);
                        this.fire("revert", n.batch, i)
                    }
                    );
                    this.refresh()
                }
            }
            class zT extends BT {
                execute() {
                    const t = this._stack.pop();
                    const e = this.editor.model.createBatch("transparent");
                    this.editor.model.enqueueChange(e, () => {
                        const n = t.batch.operations[t.batch.operations.length - 1];
                        const i = n.baseVersion + 1;
                        const o = this.editor.model.document.history.getOperations(i);
                        this._restoreSelection(t.selection.ranges, t.selection.isBackward, o);
                        this._undo(t.batch, e)
                    }
                    );
                    this.refresh()
                }
            }
            class LT extends Nw {
                static get pluginName() {
                    return "UndoEditing"
                }
                constructor(t) {
                    super(t);
                    this._batchRegistry = new WeakSet
                }
                init() {
                    const t = this.editor;
                    this._undoCommand = new DT(t);
                    this._redoCommand = new zT(t);
                    t.commands.add("undo", this._undoCommand);
                    t.commands.add("redo", this._redoCommand);
                    this.listenTo(t.model, "applyOperation", (t, e) => {
                        const n = e[0];
                        if (!n.isDocumentOperation) {
                            return
                        }
                        const i = n.batch;
                        const o = this._redoCommand._createdBatches.has(i);
                        const s = this._undoCommand._createdBatches.has(i);
                        const r = this._batchRegistry.has(i);
                        if (r || i.type == "transparent" && !o && !s) {
                            return
                        } else {
                            if (o) {
                                this._undoCommand.addBatch(i)
                            } else if (!s) {
                                this._undoCommand.addBatch(i);
                                this._redoCommand.clearStack()
                            }
                        }
                        this._batchRegistry.add(i)
                    }
                        , {
                            priority: "highest"
                        });
                    this.listenTo(this._undoCommand, "revert", (t, e, n) => {
                        this._redoCommand.addBatch(n)
                    }
                    );
                    t.keystrokes.set("CTRL+Z", "undo");
                    t.keystrokes.set("CTRL+Y", "redo");
                    t.keystrokes.set("CTRL+SHIFT+Z", "redo")
                }
            }
            var jT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.042 9.367l2.189 1.837a.75.75 0 01-.965 1.149l-3.788-3.18a.747.747 0 01-.21-.284.75.75 0 01.17-.945L6.23 4.762a.75.75 0 11.964 1.15L4.863 7.866h8.917A.75.75 0 0114 7.9a4 4 0 11-1.477 7.718l.344-1.489a2.5 2.5 0 101.094-4.73l.008-.032H5.042z"/></svg>';
            var HT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M14.958 9.367l-2.189 1.837a.75.75 0 00.965 1.149l3.788-3.18a.747.747 0 00.21-.284.75.75 0 00-.17-.945L13.77 4.762a.75.75 0 10-.964 1.15l2.331 1.955H6.22A.75.75 0 006 7.9a4 4 0 101.477 7.718l-.344-1.489A2.5 2.5 0 116.039 9.4l-.008-.032h8.927z"/></svg>';
            class qT extends Nw {
                init() {
                    const t = this.editor;
                    const e = t.locale;
                    const n = t.t;
                    const i = e.uiLanguageDirection == "ltr" ? jT : HT;
                    const o = e.uiLanguageDirection == "ltr" ? HT : jT;
                    this._addButton("undo", n("bn"), "CTRL+Z", i);
                    this._addButton("redo", n("bo"), "CTRL+Y", o)
                }
                _addButton(t, e, n, i) {
                    const o = this.editor;
                    o.ui.componentFactory.add(t, s => {
                        const r = o.commands.get(t);
                        const a = new Zb(s);
                        a.set({
                            label: e,
                            icon: i,
                            keystroke: n,
                            tooltip: true
                        });
                        a.bind("isEnabled").to(r, "isEnabled");
                        this.listenTo(a, "execute", () => {
                            o.execute(t);
                            o.editing.view.focus()
                        }
                        );
                        return a
                    }
                    )
                }
            }
            class WT extends Nw {
                static get requires() {
                    return [LT, qT]
                }
                static get pluginName() {
                    return "Undo"
                }
            }
            class UT extends Nw {
                static get requires() {
                    return [Cv, iT, wA, yT, WT]
                }
                static get pluginName() {
                    return "Essentials"
                }
            }
            n.d(e, "default", (function () {
                return $T
            }
            ));
            class $T extends Tw {
            }
            $T.builtinPlugins = [Vw, Kw, ek, gk, F_, Ov, Fv, dx, zC, WC, cA, lA, UA, _P, EP, UP, YP, ZP, UT, ok]
        }
    ])["default"]
}
));
//# sourceMappingURL=ckeditor.js.map



